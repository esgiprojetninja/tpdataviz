/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!*********************************!*\
  !*** ./~/jquery/dist/jquery.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.2.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2017-03-20T18:59Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.2.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( \">tbody\", elem )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with computed style\n\tvar valueIsBorderBox,\n\t\tstyles = getStyles( elem ),\n\t\tval = curCSS( elem, name, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Computed unit is not pixels. Stop here and return.\n\tif ( rnumnonpx.test( val ) ) {\n\t\treturn val;\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = isBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t// Fall back to offsetWidth/Height when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\tif ( val === \"auto\" ) {\n\t\tval = elem[ \"offset\" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\n\t}\n\n\t// Normalize \"\", auto, and prepare for extra\n\tval = parseFloat( val ) || 0;\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar doc, docElem, rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\tdoc = elem.ownerDocument;\n\t\tdocElem = doc.documentElement;\n\t\twin = doc.defaultView;\n\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzI3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjIuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDMtMjBUMTg6NTlaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjIuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2csXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2ltcGxlIHNlbGVjdG9yIHRoYXQgY2FuIGJlIGZpbHRlcmVkIGRpcmVjdGx5LCByZW1vdmluZyBub24tRWxlbWVudHNcblx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHR9XG5cblx0Ly8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIFwiPnRib2R5XCIsIGVsZW0gKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdGlmICggIXJldCApIHtcblx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpLFxuXHRcdHZhbCA9IDA7XG5cblx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdGlmICggZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRpID0gNDtcblxuXHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdH0gZWxzZSB7XG5cdFx0aSA9IG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRpZiAoIHZhbCA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApIF07XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvYywgZG9jRWxlbSwgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHR3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhbm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!********************************************************!*\
  !*** ./~/updated-jqplot/dist/jquery.updated-jqplot.js ***!
  \********************************************************/
/***/ (function(module, exports) {

eval("/**\n * Title: jqPlot Charts\n * \n * Pure JavaScript plotting plugin for jQuery.\n * \n * About: Version\n * \n * version: 1.0.9-1 \n * revision: 2dbcde8\n * \n * About: Copyright & License\n * \n * Copyright (c) 2009-2016 Chris Leonello\n * jqPlot is currently available for use in all personal or commercial projects \n * under both the MIT and GPL version 2.0 licenses. This means that you can \n * choose the license that best suits your project and use it accordingly.\n * \n * See <GPL Version 2> and <MIT License> contained within this distribution for further information. \n *\n * The author would appreciate an email letting him know of any substantial\n * use of jqPlot.  You can reach the author at: chris at jqplot dot com \n * or see http://www.jqplot.com/info.php.  This is, of course, not required.\n *\n * If you are feeling kind and generous, consider supporting the project by\n * making a donation at: http://www.jqplot.com/donate.php.\n *\n * sprintf functions contained in jqplot.sprintf.js by Ash Searle:\n * \n *     version 2007.04.27\n *     author Ash Searle\n *     http://hexmen.com/blog/2007/03/printf-sprintf/\n *     http://hexmen.com/js/sprintf.js\n *     The author (Ash Searle) has placed this code in the public domain:\n *     \"This code is unrestricted: you are free to use it however you like.\"\n * \n * \n * About: Introduction\n * \n * jqPlot requires jQuery (1.4+ required for certain features). jQuery 1.4.2 is included in the distribution.  \n * To use jqPlot include jQuery, the jqPlot jQuery plugin, the jqPlot css file and optionally \n * the excanvas script for IE support in your web page:\n * \n * > <!--[if lt IE 9]><script language=\"javascript\" type=\"text/javascript\" src=\"excanvas.js\"></script><![endif]-->\n * > <script language=\"javascript\" type=\"text/javascript\" src=\"jquery-1.4.4.min.js\"></script>\n * > <script language=\"javascript\" type=\"text/javascript\" src=\"jquery.jqplot.min.js\"></script>\n * > <link rel=\"stylesheet\" type=\"text/css\" href=\"jquery.jqplot.css\" />\n * \n * jqPlot can be customized by overriding the defaults of any of the objects which make\n * up the plot. The general usage of jqplot is:\n * \n * > chart = $.jqplot('targetElemId', [dataArray,...], {optionsObject});\n * \n * The options available to jqplot are detailed in <jqPlot Options> in the jqPlotOptions.txt file.\n * \n * An actual call to $.jqplot() may look like the \n * examples below:\n * \n * > chart = $.jqplot('chartdiv',  [[[1, 2],[3,5.12],[5,13.1],[7,33.6],[9,85.9],[11,219.9]]]);\n * \n * or\n * \n * > dataArray = [34,12,43,55,77];\n * > chart = $.jqplot('targetElemId', [dataArray, ...], {title:'My Plot', axes:{yaxis:{min:20, max:100}}});\n * \n * For more inforrmation, see <jqPlot Usage>.\n * \n * About: Usage\n * \n * See <jqPlot Usage>\n * \n * About: Available Options \n * \n * See <jqPlot Options> for a list of options available thorugh the options object (not complete yet!)\n * \n * About: Options Usage\n * \n * See <Options Tutorial>\n * \n * About: Changes\n * \n * See <Change Log>\n * \n */\n\n(function($) {\n    // make sure undefined is undefined\n    var undefined;\n    \n    $.fn.emptyForce = function() {\n      for ( var i = 0, elem; (elem = $(this)[i]) != null; i++ ) {\n        // Remove element nodes and prevent memory leaks\n        if ( elem.nodeType === 1 ) {\n          $.cleanData( elem.getElementsByTagName(\"*\") );\n        }\n  \n        // Remove any remaining nodes\n        if ($.jqplot.use_excanvas) {\n          elem.outerHTML = \"\";\n        }\n        else {\n          while ( elem.firstChild ) {\n            elem.removeChild( elem.firstChild );\n          }\n        }\n\n        elem = null;\n      }\n  \n      return $(this);\n    };\n  \n    $.fn.removeChildForce = function(parent) {\n      while ( parent.firstChild ) {\n        this.removeChildForce( parent.firstChild );\n        parent.removeChild( parent.firstChild );\n      }\n    };\n\n    $.fn.jqplot = function() {\n        var datas = [];\n        var options = [];\n        // see how many data arrays we have\n        for (var i=0, l=arguments.length; i<l; i++) {\n            if ($.isArray(arguments[i])) {\n                datas.push(arguments[i]);\n            }\n            else if ($.isPlainObject(arguments[i])) {\n                options.push(arguments[i]);\n            }\n        }\n\n        return this.each(function(index) {\n            var tid, \n                plot, \n                $this = $(this),\n                dl = datas.length,\n                ol = options.length,\n                data, \n                opts;\n\n            if (index < dl) {\n                data = datas[index];\n            }\n            else {\n                data = dl ? datas[dl-1] : null;\n            }\n\n            if (index < ol) {\n                opts = options[index];\n            }\n            else {\n                opts = ol ? options[ol-1] : null;\n            }\n\n            // does el have an id?\n            // if not assign it one.\n            tid = $this.attr('id');\n            if (tid === undefined) {\n                tid = 'jqplot_target_' + $.jqplot.targetCounter++;\n                $this.attr('id', tid);\n            }\n\n            plot = $.jqplot(tid, data, opts);\n\n            $this.data('jqplot', plot);\n        });\n    };\n\n\n    /**\n     * Namespace: $.jqplot\n     * jQuery function called by the user to create a plot.\n     *  \n     * Parameters:\n     * target - ID of target element to render the plot into.\n     * data - an array of data series.\n     * options - user defined options object.  See the individual classes for available options.\n     * \n     * Properties:\n     * config - object to hold configuration information for jqPlot plot object.\n     * \n     * attributes:\n     * enablePlugins - False to disable plugins by default.  Plugins must then be explicitly \n     *   enabled in the individual plot options.  Default: false.\n     *   This property sets the \"show\" property of certain plugins to true or false.\n     *   Only plugins that can be immediately active upon loading are affected.  This includes\n     *   non-renderer plugins like cursor, dragable, highlighter, and trendline.\n     * defaultHeight - Default height for plots where no css height specification exists.  This\n     *   is a jqplot wide default.\n     * defaultWidth - Default height for plots where no css height specification exists.  This\n     *   is a jqplot wide default.\n     */\n\n    $.jqplot = function(target, data, options) {\n        var _data = null, _options = null;\n\n        if (arguments.length === 3) {\n            _data = data;\n            _options = options;\n        }\n\n        else if (arguments.length === 2) {\n            if ($.isArray(data)) {\n                _data = data;\n            }\n\n            else if ($.isPlainObject(data)) {\n                _options = data;\n            }\n        }\n\n        if (_data === null && _options !== null && _options.data) {\n            _data = _options.data;\n        }\n\n        var plot = new jqPlot();\n        // remove any error class that may be stuck on target.\n        $('#'+target).removeClass('jqplot-error');\n        \n        if ($.jqplot.config.catchErrors) {\n            try {\n                plot.init(target, _data, _options);\n                plot.draw();\n                plot.themeEngine.init.call(plot);\n                return plot;\n            }\n            catch(e) {\n                var msg = $.jqplot.config.errorMessage || e.message;\n                $('#'+target).append('<div class=\"jqplot-error-message\">'+msg+'</div>');\n                $('#'+target).addClass('jqplot-error');\n                document.getElementById(target).style.background = $.jqplot.config.errorBackground;\n                document.getElementById(target).style.border = $.jqplot.config.errorBorder;\n                document.getElementById(target).style.fontFamily = $.jqplot.config.errorFontFamily;\n                document.getElementById(target).style.fontSize = $.jqplot.config.errorFontSize;\n                document.getElementById(target).style.fontStyle = $.jqplot.config.errorFontStyle;\n                document.getElementById(target).style.fontWeight = $.jqplot.config.errorFontWeight;\n            }\n        }\n        else {        \n            plot.init(target, _data, _options);\n            plot.draw();\n            plot.themeEngine.init.call(plot);\n            return plot;\n        }\n    };\n\n    $.jqplot.version = \"1.0.9-1\";\n    $.jqplot.revision = \"2dbcde8\";\n\n    $.jqplot.targetCounter = 1;\n\n    // canvas manager to reuse canvases on the plot.\n    // Should help solve problem of canvases not being freed and\n    // problem of waiting forever for firefox to decide to free memory.\n    $.jqplot.CanvasManager = function() {\n        // canvases are managed globally so that they can be reused\n        // across plots after they have been freed\n        if (typeof $.jqplot.CanvasManager.canvases == 'undefined') {\n            $.jqplot.CanvasManager.canvases = [];\n            $.jqplot.CanvasManager.free = [];\n        }\n        \n        var myCanvases = [];\n        \n        this.getCanvas = function() {\n            var canvas;\n            var makeNew = true;\n            \n            if (!$.jqplot.use_excanvas) {\n                for (var i = 0, l = $.jqplot.CanvasManager.canvases.length; i < l; i++) {\n                    if ($.jqplot.CanvasManager.free[i] === true) {\n                        makeNew = false;\n                        canvas = $.jqplot.CanvasManager.canvases[i];\n                        // $(canvas).removeClass('jqplot-canvasManager-free').addClass('jqplot-canvasManager-inuse');\n                        $.jqplot.CanvasManager.free[i] = false;\n                        myCanvases.push(i);\n                        break;\n                    }\n                }\n            }\n\n            if (makeNew) {\n                canvas = document.createElement('canvas');\n                myCanvases.push($.jqplot.CanvasManager.canvases.length);\n                $.jqplot.CanvasManager.canvases.push(canvas);\n                $.jqplot.CanvasManager.free.push(false);\n            }   \n            \n            return canvas;\n        };\n        \n        // this method has to be used after settings the dimesions\n        // on the element returned by getCanvas()\n        this.initCanvas = function(canvas) {\n            if ($.jqplot.use_excanvas) {\n                return window.G_vmlCanvasManager.initElement(canvas);\n            }\n\n            var cctx = canvas.getContext('2d');\n\n            var canvasBackingScale = 1;\n            if (window.devicePixelRatio > 1 && (cctx.webkitBackingStorePixelRatio === undefined || \n                                                cctx.webkitBackingStorePixelRatio < 2)) {\n                canvasBackingScale = window.devicePixelRatio;\n            }\n            var oldWidth = canvas.width;\n            var oldHeight = canvas.height;\n\n            canvas.width = canvasBackingScale * canvas.width;\n            canvas.height = canvasBackingScale * canvas.height;\n            canvas.style.width = oldWidth + 'px';\n            canvas.style.height = oldHeight + 'px';\n            cctx.save();\n\n            cctx.scale(canvasBackingScale, canvasBackingScale);\n\n            return canvas;\n        };\n\n        this.freeAllCanvases = function() {\n            for (var i = 0, l=myCanvases.length; i < l; i++) {\n                this.freeCanvas(myCanvases[i]);\n            }\n            myCanvases = [];\n        };\n\n        this.freeCanvas = function(idx) {\n            if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {\n                // excanvas can't be reused, but properly unset\n                window.G_vmlCanvasManager.uninitElement($.jqplot.CanvasManager.canvases[idx]);\n                $.jqplot.CanvasManager.canvases[idx] = null;\n            } \n            else {\n                var canvas = $.jqplot.CanvasManager.canvases[idx];\n                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n                $(canvas).unbind().removeAttr('class').removeAttr('style');\n                // Style attributes seemed to be still hanging around.  wierd.  Some ticks\n                // still retained a left: 0px attribute after reusing a canvas.\n                $(canvas).css({left: '', top: '', position: ''});\n                // setting size to 0 may save memory of unused canvases?\n                canvas.width = 0;\n                canvas.height = 0;\n                $.jqplot.CanvasManager.free[idx] = true;\n            }\n        };\n        \n    };\n\n            \n    // Convienence function that won't hang IE or FF without FireBug.\n    $.jqplot.log = function() {\n        if (window.console) {\n            window.console.log.apply(window.console, arguments);\n        }\n    };\n        \n    $.jqplot.config = {\n        addDomReference: false,\n        enablePlugins:false,\n        defaultHeight:300,\n        defaultWidth:400,\n        UTCAdjust:false,\n        timezoneOffset: new Date(new Date().getTimezoneOffset() * 60000),\n        errorMessage: '',\n        errorBackground: '',\n        errorBorder: '',\n        errorFontFamily: '',\n        errorFontSize: '',\n        errorFontStyle: '',\n        errorFontWeight: '',\n        catchErrors: false,\n        defaultTickFormatString: \"%.1f\",\n        defaultColors: [ \"#4bb2c5\", \"#EAA228\", \"#c5b47f\", \"#579575\", \"#839557\", \"#958c12\", \"#953579\", \"#4b5de4\", \"#d8b83f\", \"#ff5800\", \"#0085cc\", \"#c747a3\", \"#cddf54\", \"#FBD178\", \"#26B4E3\", \"#bd70c7\"],\n        defaultNegativeColors: [ \"#498991\", \"#C08840\", \"#9F9274\", \"#546D61\", \"#646C4A\", \"#6F6621\", \"#6E3F5F\", \"#4F64B0\", \"#A89050\", \"#C45923\", \"#187399\", \"#945381\", \"#959E5C\", \"#C7AF7B\", \"#478396\", \"#907294\"],\n        dashLength: 4,\n        gapLength: 4,\n        dotGapLength: 2.5,\n        srcLocation: 'jqplot/src/',\n        pluginLocation: 'jqplot/src/plugins/'\n    };\n    \n    \n    $.jqplot.arrayMax = function( array ){\n        return Math.max.apply( Math, array );\n    };\n    \n    $.jqplot.arrayMin = function( array ){\n        return Math.min.apply( Math, array );\n    };\n    \n    $.jqplot.enablePlugins = $.jqplot.config.enablePlugins;\n    \n    // canvas related tests taken from modernizer:\n    // Copyright (c) 2009 - 2010 Faruk Ates.\n    // http://www.modernizr.com\n    \n    $.jqplot.support_canvas = function() {\n        if (typeof $.jqplot.support_canvas.result == 'undefined') {\n            $.jqplot.support_canvas.result = !!document.createElement('canvas').getContext; \n        }\n        return $.jqplot.support_canvas.result;\n    };\n            \n    $.jqplot.support_canvas_text = function() {\n        if (typeof $.jqplot.support_canvas_text.result == 'undefined') {\n            if (window.G_vmlCanvasManager !== undefined && window.G_vmlCanvasManager._version > 887) {\n                $.jqplot.support_canvas_text.result = true;\n            }\n            else {\n                $.jqplot.support_canvas_text.result = !!(document.createElement('canvas').getContext && typeof document.createElement('canvas').getContext('2d').fillText == 'function');\n            }\n             \n        }\n        return $.jqplot.support_canvas_text.result;\n    };\n    \n    $.jqplot.use_excanvas = ((!$.support.boxModel || !$.support.objectAll || !$support.leadingWhitespace) && !$.jqplot.support_canvas()) ? true : false;\n    \n    /**\n     * \n     * Hooks: jqPlot Pugin Hooks\n     * \n     * $.jqplot.preInitHooks - called before initialization.\n     * $.jqplot.postInitHooks - called after initialization.\n     * $.jqplot.preParseOptionsHooks - called before user options are parsed.\n     * $.jqplot.postParseOptionsHooks - called after user options are parsed.\n     * $.jqplot.preDrawHooks - called before plot draw.\n     * $.jqplot.postDrawHooks - called after plot draw.\n     * $.jqplot.preDrawSeriesHooks - called before each series is drawn.\n     * $.jqplot.postDrawSeriesHooks - called after each series is drawn.\n     * $.jqplot.preDrawLegendHooks - called before the legend is drawn.\n     * $.jqplot.addLegendRowHooks - called at the end of legend draw, so plugins\n     *     can add rows to the legend table.\n     * $.jqplot.preSeriesInitHooks - called before series is initialized.\n     * $.jqplot.postSeriesInitHooks - called after series is initialized.\n     * $.jqplot.preParseSeriesOptionsHooks - called before series related options\n     *     are parsed.\n     * $.jqplot.postParseSeriesOptionsHooks - called after series related options\n     *     are parsed.\n     * $.jqplot.eventListenerHooks - called at the end of plot drawing, binds\n     *     listeners to the event canvas which lays on top of the grid area.\n     * $.jqplot.preDrawSeriesShadowHooks - called before series shadows are drawn.\n     * $.jqplot.postDrawSeriesShadowHooks - called after series shadows are drawn.\n     * \n     */\n    \n    $.jqplot.preInitHooks = [];\n    $.jqplot.postInitHooks = [];\n    $.jqplot.preParseOptionsHooks = [];\n    $.jqplot.postParseOptionsHooks = [];\n    $.jqplot.preDrawHooks = [];\n    $.jqplot.postDrawHooks = [];\n    $.jqplot.preDrawSeriesHooks = [];\n    $.jqplot.postDrawSeriesHooks = [];\n    $.jqplot.preDrawLegendHooks = [];\n    $.jqplot.addLegendRowHooks = [];\n    $.jqplot.preSeriesInitHooks = [];\n    $.jqplot.postSeriesInitHooks = [];\n    $.jqplot.preParseSeriesOptionsHooks = [];\n    $.jqplot.postParseSeriesOptionsHooks = [];\n    $.jqplot.eventListenerHooks = [];\n    $.jqplot.preDrawSeriesShadowHooks = [];\n    $.jqplot.postDrawSeriesShadowHooks = [];\n\n    // A superclass holding some common properties and methods.\n    $.jqplot.ElemContainer = function() {\n        this._elem;\n        this._plotWidth;\n        this._plotHeight;\n        this._plotDimensions = {height:null, width:null};\n    };\n    \n    $.jqplot.ElemContainer.prototype.createElement = function(el, offsets, clss, cssopts, attrib) {\n        this._offsets = offsets;\n        var klass = clss || 'jqplot';\n        var elem = document.createElement(el);\n        this._elem = $(elem);\n        this._elem.addClass(klass);\n        this._elem.css(cssopts);\n        this._elem.attr(attrib);\n        // avoid memory leak;\n        elem = null;\n        return this._elem;\n    };\n    \n    $.jqplot.ElemContainer.prototype.getWidth = function() {\n        if (this._elem) {\n            return this._elem.outerWidth(true);\n        }\n        else {\n            return null;\n        }\n    };\n    \n    $.jqplot.ElemContainer.prototype.getHeight = function() {\n        if (this._elem) {\n            return this._elem.outerHeight(true);\n        }\n        else {\n            return null;\n        }\n    };\n    \n    $.jqplot.ElemContainer.prototype.getPosition = function() {\n        if (this._elem) {\n            return this._elem.position();\n        }\n        else {\n            return {top:null, left:null, bottom:null, right:null};\n        }\n    };\n    \n    $.jqplot.ElemContainer.prototype.getTop = function() {\n        return this.getPosition().top;\n    };\n    \n    $.jqplot.ElemContainer.prototype.getLeft = function() {\n        return this.getPosition().left;\n    };\n    \n    $.jqplot.ElemContainer.prototype.getBottom = function() {\n        return this._elem.css('bottom');\n    };\n    \n    $.jqplot.ElemContainer.prototype.getRight = function() {\n        return this._elem.css('right');\n    };\n    \n\n    /**\n     * Class: Axis\n     * An individual axis object.  Cannot be instantiated directly, but created\n     * by the Plot object.  Axis properties can be set or overridden by the \n     * options passed in from the user.\n     * \n     */\n    function Axis(name) {\n        $.jqplot.ElemContainer.call(this);\n        // Group: Properties\n        //\n        // Axes options are specified within an axes object at the top level of the \n        // plot options like so:\n        // > {\n        // >    axes: {\n        // >        xaxis: {min: 5},\n        // >        yaxis: {min: 2, max: 8, numberTicks:4},\n        // >        x2axis: {pad: 1.5},\n        // >        y2axis: {ticks:[22, 44, 66, 88]}\n        // >        }\n        // > }\n        // There are 2 x axes, 'xaxis' and 'x2axis', and \n        // 9 yaxes, 'yaxis', 'y2axis'. 'y3axis', ...  Any or all of which may be specified.\n        this.name = name;\n        this._series = [];\n        // prop: show\n        // Wether to display the axis on the graph.\n        this.show = false;\n        // prop: tickRenderer\n        // A class of a rendering engine for creating the ticks labels displayed on the plot, \n        // See <$.jqplot.AxisTickRenderer>.\n        this.tickRenderer = $.jqplot.AxisTickRenderer;\n        // prop: tickOptions\n        // Options that will be passed to the tickRenderer, see <$.jqplot.AxisTickRenderer> options.\n        this.tickOptions = {};\n        // prop: labelRenderer\n        // A class of a rendering engine for creating an axis label.\n        this.labelRenderer = $.jqplot.AxisLabelRenderer;\n        // prop: labelOptions\n        // Options passed to the label renderer.\n        this.labelOptions = {};\n        // prop: label\n        // Label for the axis\n        this.label = null;\n        // prop: showLabel\n        // true to show the axis label.\n        this.showLabel = true;\n        // prop: min\n        // minimum value of the axis (in data units, not pixels).\n        this.min = null;\n        // prop: max\n        // maximum value of the axis (in data units, not pixels).\n        this.max = null;\n        // prop: autoscale\n        // DEPRECATED\n        // the default scaling algorithm produces superior results.\n        this.autoscale = false;\n        // prop: pad\n        // Padding to extend the range above and below the data bounds.\n        // The data range is multiplied by this factor to determine minimum and maximum axis bounds.\n        // A value of 0 will be interpreted to mean no padding, and pad will be set to 1.0.\n        this.pad = 1.2;\n        // prop: padMax\n        // Padding to extend the range above data bounds.\n        // The top of the data range is multiplied by this factor to determine maximum axis bounds.\n        // A value of 0 will be interpreted to mean no padding, and padMax will be set to 1.0.\n        this.padMax = null;\n        // prop: padMin\n        // Padding to extend the range below data bounds.\n        // The bottom of the data range is multiplied by this factor to determine minimum axis bounds.\n        // A value of 0 will be interpreted to mean no padding, and padMin will be set to 1.0.\n        this.padMin = null;\n        // prop: ticks\n        // 1D [val, val, ...] or 2D [[val, label], [val, label], ...] array of ticks for the axis.\n        // If no label is specified, the value is formatted into an appropriate label.\n        this.ticks = [];\n        // prop: numberTicks\n        // Desired number of ticks.  Default is to compute automatically.\n        this.numberTicks;\n        // prop: tickInterval\n        // number of units between ticks.  Mutually exclusive with numberTicks.\n        this.tickInterval;\n        // prop: renderer\n        // A class of a rendering engine that handles tick generation, \n        // scaling input data to pixel grid units and drawing the axis element.\n        this.renderer = $.jqplot.LinearAxisRenderer;\n        // prop: rendererOptions\n        // renderer specific options.  See <$.jqplot.LinearAxisRenderer> for options.\n        this.rendererOptions = {};\n        // prop: showTicks\n        // Wether to show the ticks (both marks and labels) or not.\n        // Will not override showMark and showLabel options if specified on the ticks themselves.\n        this.showTicks = true;\n        // prop: showTickMarks\n        // Wether to show the tick marks (line crossing grid) or not.\n        // Overridden by showTicks and showMark option of tick itself.\n        this.showTickMarks = true;\n        // prop: showMinorTicks\n        // Wether or not to show minor ticks.  This is renderer dependent.\n        this.showMinorTicks = true;\n        // prop: drawMajorGridlines\n        // True to draw gridlines for major axis ticks.\n        this.drawMajorGridlines = true;\n        // prop: drawMinorGridlines\n        // True to draw gridlines for minor ticks.\n        this.drawMinorGridlines = false;\n        // prop: drawMajorTickMarks\n        // True to draw tick marks for major axis ticks.\n        this.drawMajorTickMarks = true;\n        // prop: drawMinorTickMarks\n        // True to draw tick marks for minor ticks.  This is renderer dependent.\n        this.drawMinorTickMarks = true;\n        // prop: useSeriesColor\n        // Use the color of the first series associated with this axis for the\n        // tick marks and line bordering this axis.\n        this.useSeriesColor = false;\n        // prop: borderWidth\n        // width of line stroked at the border of the axis.  Defaults\n        // to the width of the grid boarder.\n        this.borderWidth = null;\n        // prop: borderColor\n        // color of the border adjacent to the axis.  Defaults to grid border color.\n        this.borderColor = null;\n        // prop: scaleToHiddenSeries\n        // True to include hidden series when computing axes bounds and scaling.\n        this.scaleToHiddenSeries = false;\n        // minimum and maximum values on the axis.\n        this._dataBounds = {min:null, max:null};\n        // statistics (min, max, mean) as well as actual data intervals for each series attached to axis.\n        // holds collection of {intervals:[], min:, max:, mean: } objects for each series on axis.\n        this._intervalStats = [];\n        // pixel position from the top left of the min value and max value on the axis.\n        this._offsets = {min:null, max:null};\n        this._ticks=[];\n        this._label = null;\n        // prop: syncTicks\n        // true to try and synchronize tick spacing across multiple axes so that ticks and\n        // grid lines line up.  This has an impact on autoscaling algorithm, however.\n        // In general, autoscaling an individual axis will work better if it does not\n        // have to sync ticks.\n        this.syncTicks = null;\n        // prop: tickSpacing\n        // Approximate pixel spacing between ticks on graph.  Used during autoscaling.\n        // This number will be an upper bound, actual spacing will be less.\n        this.tickSpacing = 75;\n        // Properties to hold the original values for min, max, ticks, tickInterval and numberTicks\n        // so they can be restored if altered by plugins.\n        this._min = null;\n        this._max = null;\n        this._tickInterval = null;\n        this._numberTicks = null;\n        this.__ticks = null;\n        // hold original user options.\n        this._options = {};\n    }\n    \n    Axis.prototype = new $.jqplot.ElemContainer();\n    Axis.prototype.constructor = Axis;\n    \n    Axis.prototype.init = function() {\n        if ($.isFunction(this.renderer)) {\n            this.renderer = new this.renderer();  \n        }\n        // set the axis name\n        this.tickOptions.axis = this.name;\n        // if showMark or showLabel tick options not specified, use value of axis option.\n        // showTicks overrides showTickMarks.\n        if (this.tickOptions.showMark == null) {\n            this.tickOptions.showMark = this.showTicks;\n        }\n        if (this.tickOptions.showMark == null) {\n            this.tickOptions.showMark = this.showTickMarks;\n        }\n        if (this.tickOptions.showLabel == null) {\n            this.tickOptions.showLabel = this.showTicks;\n        }\n        \n        if (this.label == null || this.label == '') {\n            this.showLabel = false;\n        }\n        else {\n            this.labelOptions.label = this.label;\n        }\n        if (this.showLabel == false) {\n            this.labelOptions.show = false;\n        }\n        // set the default padMax, padMin if not specified\n        // special check, if no padding desired, padding\n        // should be set to 1.0\n        if (this.pad == 0) {\n            this.pad = 1.0;\n        }\n        if (this.padMax == 0) {\n            this.padMax = 1.0;\n        }\n        if (this.padMin == 0) {\n            this.padMin = 1.0;\n        }\n        if (this.padMax == null) {\n            this.padMax = (this.pad-1)/2 + 1;\n        }\n        if (this.padMin == null) {\n            this.padMin = (this.pad-1)/2 + 1;\n        }\n        // now that padMin and padMax are correctly set, reset pad in case user has supplied \n        // padMin and/or padMax\n        this.pad = this.padMax + this.padMin - 1;\n        if (this.min != null || this.max != null) {\n            this.autoscale = false;\n        }\n        // if not set, sync ticks for y axes but not x by default.\n        if (this.syncTicks == null && this.name.indexOf('y') > -1) {\n            this.syncTicks = true;\n        }\n        else if (this.syncTicks == null){\n            this.syncTicks = false;\n        }\n        this.renderer.init.call(this, this.rendererOptions);\n        \n    };\n    \n    Axis.prototype.draw = function(ctx, plot) {\n        // Memory Leaks patch\n        if (this.__ticks) {\n          this.__ticks = null;\n        }\n\n        return this.renderer.draw.call(this, ctx, plot);\n        \n    };\n    \n    Axis.prototype.set = function() {\n        this.renderer.set.call(this);\n    };\n    \n    Axis.prototype.pack = function(pos, offsets) {\n        if (this.show) {\n            this.renderer.pack.call(this, pos, offsets);\n        }\n        // these properties should all be available now.\n        if (this._min == null) {\n            this._min = this.min;\n            this._max = this.max;\n            this._tickInterval = this.tickInterval;\n            this._numberTicks = this.numberTicks;\n            this.__ticks = this._ticks;\n        }\n    };\n    \n    // reset the axis back to original values if it has been scaled, zoomed, etc.\n    Axis.prototype.reset = function() {\n        this.renderer.reset.call(this);\n    };\n    \n    Axis.prototype.resetScale = function(opts) {\n        $.extend(true, this, {min: null, max: null, numberTicks: null, tickInterval: null, _ticks: [], ticks: []}, opts);\n        this.resetDataBounds();\n    };\n    \n    Axis.prototype.resetDataBounds = function() {\n        // Go through all the series attached to this axis and find\n        // the min/max bounds for this axis.\n        var db = this._dataBounds;\n        db.min = null;\n        db.max = null;\n        var l, s, d;\n        // check for when to force min 0 on bar series plots.\n        var doforce = (this.show) ? true : false;\n        for (var i=0; i<this._series.length; i++) {\n            s = this._series[i];\n            if (s.show || this.scaleToHiddenSeries) {\n                d = s._plotData;\n                if (s._type === 'line' && s.renderer.bands.show && this.name.charAt(0) !== 'x') {\n                    d = [[0, s.renderer.bands._min], [1, s.renderer.bands._max]];\n                }\n\n                var minyidx = 1, maxyidx = 1;\n\n                if (s._type != null && s._type == 'ohlc') {\n                    minyidx = 3;\n                    maxyidx = 2;\n                }\n                \n                for (var j=0, l=d.length; j<l; j++) { \n                    if (this.name == 'xaxis' || this.name == 'x2axis') {\n                        if ((d[j][0] != null && d[j][0] < db.min) || db.min == null) {\n                            db.min = d[j][0];\n                        }\n                        if ((d[j][0] != null && d[j][0] > db.max) || db.max == null) {\n                            db.max = d[j][0];\n                        }\n                    }              \n                    else {\n                        if ((d[j][minyidx] != null && d[j][minyidx] < db.min) || db.min == null) {\n                            db.min = d[j][minyidx];\n                        }\n                        if ((d[j][maxyidx] != null && d[j][maxyidx] > db.max) || db.max == null) {\n                            db.max = d[j][maxyidx];\n                        }\n                    }              \n                }\n\n                // Hack to not pad out bottom of bar plots unless user has specified a padding.\n                // every series will have a chance to set doforce to false.  once it is set to \n                // false, it cannot be reset to true.\n                // If any series attached to axis is not a bar, wont force 0.\n                if (doforce && s.renderer.constructor !== $.jqplot.BarRenderer) {\n                    doforce = false;\n                }\n\n                else if (doforce && this._options.hasOwnProperty('forceTickAt0') && this._options.forceTickAt0 == false) {\n                    doforce = false;\n                }\n\n                else if (doforce && s.renderer.constructor === $.jqplot.BarRenderer) {\n                    if (s.barDirection == 'vertical' && this.name != 'xaxis' && this.name != 'x2axis') { \n                        if (this._options.pad != null || this._options.padMin != null) {\n                            doforce = false;\n                        }\n                    }\n\n                    else if (s.barDirection == 'horizontal' && (this.name == 'xaxis' || this.name == 'x2axis')) {\n                        if (this._options.pad != null || this._options.padMin != null) {\n                            doforce = false;\n                        }\n                    }\n\n                }\n            }\n        }\n\n        if (doforce && this.renderer.constructor === $.jqplot.LinearAxisRenderer && db.min >= 0) {\n            this.padMin = 1.0;\n            this.forceTickAt0 = true;\n        }\n    };\n\n    /**\n     * Class: Legend\n     * Legend object.  Cannot be instantiated directly, but created\n     * by the Plot object.  Legend properties can be set or overridden by the \n     * options passed in from the user.\n     */\n    function Legend(options) {\n        $.jqplot.ElemContainer.call(this);\n        // Group: Properties\n        \n        // prop: show\n        // Wether to display the legend on the graph.\n        this.show = false;\n        // prop: location\n        // Placement of the legend.  one of the compass directions: nw, n, ne, e, se, s, sw, w\n        this.location = 'ne';\n        // prop: labels\n        // Array of labels to use.  By default the renderer will look for labels on the series.\n        // Labels specified in this array will override labels specified on the series.\n        this.labels = [];\n        // prop: showLabels\n        // true to show the label text on the  legend.\n        this.showLabels = true;\n        // prop: showSwatch\n        // true to show the color swatches on the legend.\n        this.showSwatches = true;\n        // prop: placement\n        // \"insideGrid\" places legend inside the grid area of the plot.\n        // \"outsideGrid\" places the legend outside the grid but inside the plot container, \n        // shrinking the grid to accommodate the legend.\n        // \"inside\" synonym for \"insideGrid\", \n        // \"outside\" places the legend ouside the grid area, but does not shrink the grid which\n        // can cause the legend to overflow the plot container.\n        this.placement = \"insideGrid\";\n        // prop: xoffset\n        // DEPRECATED.  Set the margins on the legend using the marginTop, marginLeft, etc. \n        // properties or via CSS margin styling of the .jqplot-table-legend class.\n        this.xoffset = 0;\n        // prop: yoffset\n        // DEPRECATED.  Set the margins on the legend using the marginTop, marginLeft, etc. \n        // properties or via CSS margin styling of the .jqplot-table-legend class.\n        this.yoffset = 0;\n        // prop: border\n        // css spec for the border around the legend box.\n        this.border;\n        // prop: background\n        // css spec for the background of the legend box.\n        this.background;\n        // prop: textColor\n        // css color spec for the legend text.\n        this.textColor;\n        // prop: fontFamily\n        // css font-family spec for the legend text.\n        this.fontFamily; \n        // prop: fontSize\n        // css font-size spec for the legend text.\n        this.fontSize ;\n        // prop: rowSpacing\n        // css padding-top spec for the rows in the legend.\n        this.rowSpacing = '0.5em';\n        // renderer\n        // A class that will create a DOM object for the legend,\n        // see <$.jqplot.TableLegendRenderer>.\n        this.renderer = $.jqplot.TableLegendRenderer;\n        // prop: rendererOptions\n        // renderer specific options passed to the renderer.\n        this.rendererOptions = {};\n        // prop: predraw\n        // Wether to draw the legend before the series or not.\n        // Used with series specific legend renderers for pie, donut, mekko charts, etc.\n        this.preDraw = false;\n        // prop: marginTop\n        // CSS margin for the legend DOM element. This will set an element \n        // CSS style for the margin which will override any style sheet setting.\n        // The default will be taken from the stylesheet.\n        this.marginTop = null;\n        // prop: marginRight\n        // CSS margin for the legend DOM element. This will set an element \n        // CSS style for the margin which will override any style sheet setting.\n        // The default will be taken from the stylesheet.\n        this.marginRight = null;\n        // prop: marginBottom\n        // CSS margin for the legend DOM element. This will set an element \n        // CSS style for the margin which will override any style sheet setting.\n        // The default will be taken from the stylesheet.\n        this.marginBottom = null;\n        // prop: marginLeft\n        // CSS margin for the legend DOM element. This will set an element \n        // CSS style for the margin which will override any style sheet setting.\n        // The default will be taken from the stylesheet.\n        this.marginLeft = null;\n        // prop: escapeHtml\n        // True to escape special characters with their html entity equivalents\n        // in legend text.  \"<\" becomes &lt; and so on, so html tags are not rendered.\n        this.escapeHtml = false;\n        this._series = [];\n        \n        $.extend(true, this, options);\n    }\n    \n    Legend.prototype = new $.jqplot.ElemContainer();\n    Legend.prototype.constructor = Legend;\n    \n    Legend.prototype.setOptions = function(options) {\n        $.extend(true, this, options);\n        \n        // Try to emulate deprecated behaviour\n        // if user has specified xoffset or yoffset, copy these to\n        // the margin properties.\n        \n        if (this.placement ==  'inside') {\n            this.placement = 'insideGrid';\n        }\n        \n        if (this.xoffset >0) {\n            if (this.placement == 'insideGrid') {\n                switch (this.location) {\n                    case 'nw':\n                    case 'w':\n                    case 'sw':\n                        if (this.marginLeft == null) {\n                            this.marginLeft = this.xoffset + 'px';\n                        }\n                        this.marginRight = '0px';\n                        break;\n                    case 'ne':\n                    case 'e':\n                    case 'se':\n                    default:\n                        if (this.marginRight == null) {\n                            this.marginRight = this.xoffset + 'px';\n                        }\n                        this.marginLeft = '0px';\n                        break;\n                }\n            }\n            else if (this.placement == 'outside') {\n                switch (this.location) {\n                    case 'nw':\n                    case 'w':\n                    case 'sw':\n                        if (this.marginRight == null) {\n                            this.marginRight = this.xoffset + 'px';\n                        }\n                        this.marginLeft = '0px';\n                        break;\n                    case 'ne':\n                    case 'e':\n                    case 'se':\n                    default:\n                        if (this.marginLeft == null) {\n                            this.marginLeft = this.xoffset + 'px';\n                        }\n                        this.marginRight = '0px';\n                        break;\n                }\n            }\n            this.xoffset = 0;\n        }\n        \n        if (this.yoffset >0) {\n            if (this.placement == 'outside') {\n                switch (this.location) {\n                    case 'sw':\n                    case 's':\n                    case 'se':\n                        if (this.marginTop == null) {\n                            this.marginTop = this.yoffset + 'px';\n                        }\n                        this.marginBottom = '0px';\n                        break;\n                    case 'ne':\n                    case 'n':\n                    case 'nw':\n                    default:\n                        if (this.marginBottom == null) {\n                            this.marginBottom = this.yoffset + 'px';\n                        }\n                        this.marginTop = '0px';\n                        break;\n                }\n            }\n            else if (this.placement == 'insideGrid') {\n                switch (this.location) {\n                    case 'sw':\n                    case 's':\n                    case 'se':\n                        if (this.marginBottom == null) {\n                            this.marginBottom = this.yoffset + 'px';\n                        }\n                        this.marginTop = '0px';\n                        break;\n                    case 'ne':\n                    case 'n':\n                    case 'nw':\n                    default:\n                        if (this.marginTop == null) {\n                            this.marginTop = this.yoffset + 'px';\n                        }\n                        this.marginBottom = '0px';\n                        break;\n                }\n            }\n            this.yoffset = 0;\n        }\n        \n        // TO-DO:\n        // Handle case where offsets are < 0.\n        //\n    };\n    \n    Legend.prototype.init = function() {\n        if ($.isFunction(this.renderer)) {\n            this.renderer = new this.renderer();  \n        }\n        this.renderer.init.call(this, this.rendererOptions);\n    };\n    \n    Legend.prototype.draw = function(offsets, plot) {\n        for (var i=0; i<$.jqplot.preDrawLegendHooks.length; i++){\n            $.jqplot.preDrawLegendHooks[i].call(this, offsets);\n        }\n        return this.renderer.draw.call(this, offsets, plot);\n    };\n    \n    Legend.prototype.pack = function(offsets) {\n        this.renderer.pack.call(this, offsets);\n    };\n\n    /**\n     * Class: Title\n     * Plot Title object.  Cannot be instantiated directly, but created\n     * by the Plot object.  Title properties can be set or overridden by the \n     * options passed in from the user.\n     * \n     * Parameters:\n     * text - text of the title.\n     */\n    function Title(text) {\n        $.jqplot.ElemContainer.call(this);\n        // Group: Properties\n        \n        // prop: text\n        // text of the title;\n        this.text = text;\n        // prop: show\n        // whether or not to show the title\n        this.show = true;\n        // prop: fontFamily\n        // css font-family spec for the text.\n        this.fontFamily;\n        // prop: fontSize\n        // css font-size spec for the text.\n        this.fontSize ;\n        // prop: textAlign\n        // css text-align spec for the text.\n        this.textAlign;\n        // prop: textColor\n        // css color spec for the text.\n        this.textColor;\n        // prop: renderer\n        // A class for creating a DOM element for the title,\n        // see <$.jqplot.DivTitleRenderer>.\n        this.renderer = $.jqplot.DivTitleRenderer;\n        // prop: rendererOptions\n        // renderer specific options passed to the renderer.\n        this.rendererOptions = {};   \n        // prop: escapeHtml\n        // True to escape special characters with their html entity equivalents\n        // in title text.  \"<\" becomes &lt; and so on, so html tags are not rendered.\n        this.escapeHtml = false;\n    }\n    \n    Title.prototype = new $.jqplot.ElemContainer();\n    Title.prototype.constructor = Title;\n    \n    Title.prototype.init = function() {\n        if ($.isFunction(this.renderer)) {\n            this.renderer = new this.renderer();  \n        }\n        this.renderer.init.call(this, this.rendererOptions);\n    };\n    \n    Title.prototype.draw = function(width) {\n        return this.renderer.draw.call(this, width);\n    };\n    \n    Title.prototype.pack = function() {\n        this.renderer.pack.call(this);\n    };\n\n\n    /**\n     * Class: Series\n     * An individual data series object.  Cannot be instantiated directly, but created\n     * by the Plot object.  Series properties can be set or overridden by the \n     * options passed in from the user.\n     */\n    function Series(options) {\n        options = options || {};\n        $.jqplot.ElemContainer.call(this);\n        // Group: Properties\n        // Properties will be assigned from a series array at the top level of the\n        // options.  If you had two series and wanted to change the color and line\n        // width of the first and set the second to use the secondary y axis with\n        // no shadow and supply custom labels for each:\n        // > {\n        // >    series:[\n        // >        {color: '#ff4466', lineWidth: 5, label:'good line'},\n        // >        {yaxis: 'y2axis', shadow: false, label:'bad line'}\n        // >    ]\n        // > }\n\n        // prop: show\n        // whether or not to draw the series.\n        this.show = true;\n        // prop: xaxis\n        // which x axis to use with this series, either 'xaxis' or 'x2axis'.\n        this.xaxis = 'xaxis';\n        this._xaxis;\n        // prop: yaxis\n        // which y axis to use with this series, either 'yaxis' or 'y2axis'.\n        this.yaxis = 'yaxis';\n        this._yaxis;\n        this.gridBorderWidth = 2.0;\n        // prop: renderer\n        // A class of a renderer which will draw the series, \n        // see <$.jqplot.LineRenderer>.\n        this.renderer = $.jqplot.LineRenderer;\n        // prop: rendererOptions\n        // Options to pass on to the renderer.\n        this.rendererOptions = {};\n        this.data = [];\n        this.gridData = [];\n        // prop: label\n        // Line label to use in the legend.\n        this.label = '';\n        // prop: showLabel\n        // true to show label for this series in the legend.\n        this.showLabel = true;\n        // prop: color\n        // css color spec for the series\n        this.color;\n        // prop: negativeColor\n        // css color spec used for filled (area) plots that are filled to zero and\n        // the \"useNegativeColors\" option is true.\n        this.negativeColor;\n        // prop: lineWidth\n        // width of the line in pixels.  May have different meanings depending on renderer.\n        this.lineWidth = 2.5;\n        // prop: lineJoin\n        // Canvas lineJoin style between segments of series.\n        this.lineJoin = 'round';\n        // prop: lineCap\n        // Canvas lineCap style at ends of line.\n        this.lineCap = 'round';\n        // prop: linePattern\n        // line pattern 'dashed', 'dotted', 'solid', some combination\n        // of '-' and '.' characters such as '.-.' or a numerical array like \n        // [draw, skip, draw, skip, ...] such as [1, 10] to draw a dotted line, \n        // [1, 10, 20, 10] to draw a dot-dash line, and so on.\n        this.linePattern = 'solid';\n        this.shadow = true;\n        // prop: shadowAngle\n        // Shadow angle in degrees\n        this.shadowAngle = 45;\n        // prop: shadowOffset\n        // Shadow offset from line in pixels\n        this.shadowOffset = 1.25;\n        // prop: shadowDepth\n        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.\n        this.shadowDepth = 3;\n        // prop: shadowAlpha\n        // Alpha channel transparency of shadow.  0 = transparent.\n        this.shadowAlpha = '0.1';\n        // prop: breakOnNull\n        // Wether line segments should be be broken at null value.\n        // False will join point on either side of line.\n        this.breakOnNull = false;\n        // prop: markerRenderer\n        // A class of a renderer which will draw marker (e.g. circle, square, ...) at the data points,\n        // see <$.jqplot.MarkerRenderer>.\n        this.markerRenderer = $.jqplot.MarkerRenderer;\n        // prop: markerOptions\n        // renderer specific options to pass to the markerRenderer,\n        // see <$.jqplot.MarkerRenderer>.\n        this.markerOptions = {};\n        // prop: showLine\n        // whether to actually draw the line or not.  Series will still be renderered, even if no line is drawn.\n        this.showLine = true;\n        // prop: showMarker\n        // whether or not to show the markers at the data points.\n        this.showMarker = true;\n        // prop: index\n        // 0 based index of this series in the plot series array.\n        this.index;\n        // prop: fill\n        // true or false, whether to fill under lines or in bars.\n        // May not be implemented in all renderers.\n        this.fill = false;\n        // prop: fillColor\n        // CSS color spec to use for fill under line.  Defaults to line color.\n        this.fillColor;\n        // prop: fillAlpha\n        // Alpha transparency to apply to the fill under the line.\n        // Use this to adjust alpha separate from fill color.\n        this.fillAlpha;\n        // prop: fillAndStroke\n        // If true will stroke the line (with color this.color) as well as fill under it.\n        // Applies only when fill is true.\n        this.fillAndStroke = false;\n        // prop: disableStack\n        // true to not stack this series with other series in the plot.\n        // To render properly, non-stacked series must come after any stacked series\n        // in the plot's data series array.  So, the plot's data series array would look like:\n        // > [stackedSeries1, stackedSeries2, ..., nonStackedSeries1, nonStackedSeries2, ...]\n        // disableStack will put a gap in the stacking order of series, and subsequent\n        // stacked series will not fill down through the non-stacked series and will\n        // most likely not stack properly on top of the non-stacked series.\n        this.disableStack = false;\n        // _stack is set by the Plot if the plot is a stacked chart.\n        // will stack lines or bars on top of one another to build a \"mountain\" style chart.\n        // May not be implemented in all renderers.\n        this._stack = false;\n        // prop: neighborThreshold\n        // how close or far (in pixels) the cursor must be from a point marker to detect the point.\n        this.neighborThreshold = 4;\n        // prop: fillToZero\n        // true will force bar and filled series to fill toward zero on the fill Axis.\n        this.fillToZero = false;\n        // prop: fillToValue\n        // fill a filled series to this value on the fill axis.\n        // Works in conjunction with fillToZero, so that must be true.\n        this.fillToValue = 0;\n        // prop: fillAxis\n        // Either 'x' or 'y'.  Which axis to fill the line toward if fillToZero is true.\n        // 'y' means fill up/down to 0 on the y axis for this series.\n        this.fillAxis = 'y';\n        // prop: useNegativeColors\n        // true to color negative values differently in filled and bar charts.\n        this.useNegativeColors = true;\n        this._stackData = [];\n        // _plotData accounts for stacking.  If plots not stacked, _plotData and data are same.  If\n        // stacked, _plotData is accumulation of stacking data.\n        this._plotData = [];\n        // _plotValues hold the individual x and y values that will be plotted for this series.\n        this._plotValues = {x:[], y:[]};\n        // statistics about the intervals between data points.  Used for auto scaling.\n        this._intervals = {x:{}, y:{}};\n        // data from the previous series, for stacked charts.\n        this._prevPlotData = [];\n        this._prevGridData = [];\n        this._stackAxis = 'y';\n        this._primaryAxis = '_xaxis';\n        // give each series a canvas to draw on.  This should allow for redrawing speedups.\n        this.canvas = new $.jqplot.GenericCanvas();\n        this.shadowCanvas = new $.jqplot.GenericCanvas();\n        this.plugins = {};\n        // sum of y values in this series.\n        this._sumy = 0;\n        this._sumx = 0;\n        this._type = '';\n        this.step = false;\n    }\n    \n    Series.prototype = new $.jqplot.ElemContainer();\n    Series.prototype.constructor = Series;\n    \n    Series.prototype.init = function(index, gridbw, plot) {\n        // weed out any null values in the data.\n        this.index = index;\n        this.gridBorderWidth = gridbw;\n        var d = this.data;\n        var temp = [], i, l;\n        for (i=0, l=d.length; i<l; i++) {\n            if (! this.breakOnNull) {\n                if (d[i] == null || d[i][0] == null || d[i][1] == null) {\n                    continue;\n                }\n                else {\n                    temp.push(d[i]);\n                }\n            }\n            else {\n                // TODO: figure out what to do with null values\n                // probably involve keeping nulls in data array\n                // and then updating renderers to break line\n                // when it hits null value.\n                // For now, just keep value.\n                temp.push(d[i]);\n            }\n        }\n        this.data = temp;\n\n        // parse the renderer options and apply default colors if not provided\n        // Set color even if not shown, so series don't change colors when other\n        // series on plot shown/hidden.\n        if (!this.color) {\n            this.color = plot.colorGenerator.get(this.index);\n        }\n        if (!this.negativeColor) {\n            this.negativeColor = plot.negativeColorGenerator.get(this.index);\n        }\n\n\n        if (!this.fillColor) {\n            this.fillColor = this.color;\n        }\n        if (this.fillAlpha) {\n            var comp = $.jqplot.normalize2rgb(this.fillColor);\n            var comp = $.jqplot.getColorComponents(comp);\n            this.fillColor = 'rgba('+comp[0]+','+comp[1]+','+comp[2]+','+this.fillAlpha+')';\n        }\n        if ($.isFunction(this.renderer)) {\n            this.renderer = new this.renderer();  \n        }\n        this.renderer.init.call(this, this.rendererOptions, plot);\n        this.markerRenderer = new this.markerRenderer();\n        if (!this.markerOptions.color) {\n            this.markerOptions.color = this.color;\n        }\n        if (this.markerOptions.show == null) {\n            this.markerOptions.show = this.showMarker;\n        }\n        this.showMarker = this.markerOptions.show;\n        // the markerRenderer is called within its own scope, don't want to overwrite series options!!\n        this.markerRenderer.init(this.markerOptions);\n    };\n    \n    // data - optional data point array to draw using this series renderer\n    // gridData - optional grid data point array to draw using this series renderer\n    // stackData - array of cumulative data for stacked plots.\n    Series.prototype.draw = function(sctx, opts, plot) {\n        var options = (opts == undefined) ? {} : opts;\n        sctx = (sctx == undefined) ? this.canvas._ctx : sctx;\n        \n        var j, data, gridData;\n        \n        // hooks get called even if series not shown\n        // we don't clear canvas here, it would wipe out all other series as well.\n        for (j=0; j<$.jqplot.preDrawSeriesHooks.length; j++) {\n            $.jqplot.preDrawSeriesHooks[j].call(this, sctx, options);\n        }\n        if (this.show) {\n            this.renderer.setGridData.call(this, plot);\n            if (!options.preventJqPlotSeriesDrawTrigger) {\n                $(sctx.canvas).trigger('jqplotSeriesDraw', [this.data, this.gridData]);\n            }\n            data = [];\n            if (options.data) {\n                data = options.data;\n            }\n            else if (!this._stack) {\n                data = this.data;\n            }\n            else {\n                data = this._plotData;\n            }\n            gridData = options.gridData || this.renderer.makeGridData.call(this, data, plot);\n\n            if (this._type === 'line' && this.renderer.smooth && this.renderer._smoothedData.length) {\n                gridData = this.renderer._smoothedData;\n            }\n\n            this.renderer.draw.call(this, sctx, gridData, options, plot);\n        }\n        \n        for (j=0; j<$.jqplot.postDrawSeriesHooks.length; j++) {\n            $.jqplot.postDrawSeriesHooks[j].call(this, sctx, options, plot);\n        }\n        \n        sctx = opts = plot = j = data = gridData = null;\n    };\n    \n    Series.prototype.drawShadow = function(sctx, opts, plot) {\n        var options = (opts == undefined) ? {} : opts;\n        sctx = (sctx == undefined) ? this.shadowCanvas._ctx : sctx;\n        \n        var j, data, gridData;\n        \n        // hooks get called even if series not shown\n        // we don't clear canvas here, it would wipe out all other series as well.\n        for (j=0; j<$.jqplot.preDrawSeriesShadowHooks.length; j++) {\n            $.jqplot.preDrawSeriesShadowHooks[j].call(this, sctx, options);\n        }\n        if (this.shadow) {\n            this.renderer.setGridData.call(this, plot);\n\n            data = [];\n            if (options.data) {\n                data = options.data;\n            }\n            else if (!this._stack) {\n                data = this.data;\n            }\n            else {\n                data = this._plotData;\n            }\n            gridData = options.gridData || this.renderer.makeGridData.call(this, data, plot);\n        \n            this.renderer.drawShadow.call(this, sctx, gridData, options, plot);\n        }\n        \n        for (j=0; j<$.jqplot.postDrawSeriesShadowHooks.length; j++) {\n            $.jqplot.postDrawSeriesShadowHooks[j].call(this, sctx, options);\n        }\n        \n        sctx = opts = plot = j = data = gridData = null;\n        \n    };\n    \n    // toggles series display on plot, e.g. show/hide series\n    Series.prototype.toggleDisplay = function(ev, callback) {\n        var s, speed;\n        if (ev.data.series) {\n            s = ev.data.series;\n        }\n        else {\n            s = this;\n        }\n\n        if (ev.data.speed) {\n            speed = ev.data.speed;\n        }\n        if (speed) {\n            // this can be tricky because series may not have a canvas element if replotting.\n            if (s.canvas._elem.is(':hidden') || !s.show) {\n                s.show = true;\n\n                s.canvas._elem.removeClass('jqplot-series-hidden');\n                if (s.shadowCanvas._elem) {\n                    s.shadowCanvas._elem.fadeIn(speed);\n                }\n                s.canvas._elem.fadeIn(speed, callback);\n                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).fadeIn(speed);\n            }\n            else {\n                s.show = false;\n\n                s.canvas._elem.addClass('jqplot-series-hidden');\n                if (s.shadowCanvas._elem) {\n                    s.shadowCanvas._elem.fadeOut(speed);\n                }\n                s.canvas._elem.fadeOut(speed, callback);\n                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).fadeOut(speed);\n            }\n        }\n        else {\n            // this can be tricky because series may not have a canvas element if replotting.\n            if (s.canvas._elem.is(':hidden') || !s.show) {\n                s.show = true;\n\n                s.canvas._elem.removeClass('jqplot-series-hidden');\n                if (s.shadowCanvas._elem) {\n                    s.shadowCanvas._elem.show();\n                }\n                s.canvas._elem.show(0, callback);\n                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).show();\n            }\n            else {\n                s.show = false;\n\n                s.canvas._elem.addClass('jqplot-series-hidden');\n                if (s.shadowCanvas._elem) {\n                    s.shadowCanvas._elem.hide();\n                }\n                s.canvas._elem.hide(0, callback);\n                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).hide();\n            }\n        }\n    };\n    \n\n\n    /**\n     * Class: Grid\n     * \n     * Object representing the grid on which the plot is drawn.  The grid in this\n     * context is the area bounded by the axes, the area which will contain the series.\n     * Note, the series are drawn on their own canvas.\n     * The Grid object cannot be instantiated directly, but is created by the Plot object.  \n     * Grid properties can be set or overridden by the options passed in from the user.\n     */\n    function Grid() {\n        $.jqplot.ElemContainer.call(this);\n        // Group: Properties\n        \n        // prop: drawGridlines\n        // whether to draw the gridlines on the plot.\n        this.drawGridlines = true;\n        // prop: gridLineColor\n        // color of the grid lines.\n        this.gridLineColor = '#cccccc';\n        // prop: gridLineWidth\n        // width of the grid lines.\n        this.gridLineWidth = 1.0;\n        // prop: background\n        // css spec for the background color.\n        this.background = '#fffdf6';\n        // prop: borderColor\n        // css spec for the color of the grid border.\n        this.borderColor = '#999999';\n        // prop: borderWidth\n        // width of the border in pixels.\n        this.borderWidth = 2.0;\n        // prop: drawBorder\n        // True to draw border around grid.\n        this.drawBorder = true;\n        // prop: shadow\n        // whether to show a shadow behind the grid.\n        this.shadow = true;\n        // prop: shadowAngle\n        // shadow angle in degrees\n        this.shadowAngle = 45;\n        // prop: shadowOffset\n        // Offset of each shadow stroke from the border in pixels\n        this.shadowOffset = 1.5;\n        // prop: shadowWidth\n        // width of the stoke for the shadow\n        this.shadowWidth = 3;\n        // prop: shadowDepth\n        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.\n        this.shadowDepth = 3;\n        // prop: shadowColor\n        // an optional css color spec for the shadow in 'rgba(n, n, n, n)' form\n        this.shadowColor = null;\n        // prop: shadowAlpha\n        // Alpha channel transparency of shadow.  0 = transparent.\n        this.shadowAlpha = '0.07';\n        this._left;\n        this._top;\n        this._right;\n        this._bottom;\n        this._width;\n        this._height;\n        this._axes = [];\n        // prop: renderer\n        // Instance of a renderer which will actually render the grid,\n        // see <$.jqplot.CanvasGridRenderer>.\n        this.renderer = $.jqplot.CanvasGridRenderer;\n        // prop: rendererOptions\n        // Options to pass on to the renderer,\n        // see <$.jqplot.CanvasGridRenderer>.\n        this.rendererOptions = {};\n        this._offsets = {top:null, bottom:null, left:null, right:null};\n    }\n    \n    Grid.prototype = new $.jqplot.ElemContainer();\n    Grid.prototype.constructor = Grid;\n    \n    Grid.prototype.init = function() {\n        if ($.isFunction(this.renderer)) {\n            this.renderer = new this.renderer();  \n        }\n        this.renderer.init.call(this, this.rendererOptions);\n    };\n    \n    Grid.prototype.createElement = function(offsets,plot) {\n        this._offsets = offsets;\n        return this.renderer.createElement.call(this, plot);\n    };\n    \n    Grid.prototype.draw = function() {\n        this.renderer.draw.call(this);\n    };\n    \n    $.jqplot.GenericCanvas = function() {\n        $.jqplot.ElemContainer.call(this);\n        this._ctx;  \n    };\n    \n    $.jqplot.GenericCanvas.prototype = new $.jqplot.ElemContainer();\n    $.jqplot.GenericCanvas.prototype.constructor = $.jqplot.GenericCanvas;\n    \n    $.jqplot.GenericCanvas.prototype.createElement = function(offsets, clss, plotDimensions, plot) {\n        this._offsets = offsets;\n        var klass = 'jqplot';\n        if (clss != undefined) {\n            klass = clss;\n        }\n        var elem;\n\n        elem = plot.canvasManager.getCanvas();\n        \n        // if new plotDimensions supplied, use them.\n        if (plotDimensions != null) {\n            this._plotDimensions = plotDimensions;\n        }\n        \n        elem.width = this._plotDimensions.width - this._offsets.left - this._offsets.right;\n        elem.height = this._plotDimensions.height - this._offsets.top - this._offsets.bottom;\n        this._elem = $(elem);\n        this._elem.css({ position: 'absolute', left: this._offsets.left, top: this._offsets.top });\n        \n        this._elem.addClass(klass);\n        \n        elem = plot.canvasManager.initCanvas(elem);\n        \n        elem = null;\n        return this._elem;\n    };\n    \n    $.jqplot.GenericCanvas.prototype.setContext = function() {\n        this._ctx = this._elem.get(0).getContext(\"2d\");\n        return this._ctx;\n    };\n    \n    // Memory Leaks patch\n    $.jqplot.GenericCanvas.prototype.resetCanvas = function() {\n      if (this._elem) {\n        if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {\n           window.G_vmlCanvasManager.uninitElement(this._elem.get(0));\n        }\n        \n        //this._elem.remove();\n        this._elem.emptyForce();\n      }\n      \n      this._ctx = null;\n    };\n    \n    $.jqplot.HooksManager = function () {\n        this.hooks =[];\n        this.args = [];\n    };\n    \n    $.jqplot.HooksManager.prototype.addOnce = function(fn, args) {\n        args = args || [];\n        var havehook = false;\n        for (var i=0, l=this.hooks.length; i<l; i++) {\n            if (this.hooks[i] == fn) {\n                havehook = true;\n            }\n        }\n        if (!havehook) {\n            this.hooks.push(fn);\n            this.args.push(args);\n        }\n    };\n    \n    $.jqplot.HooksManager.prototype.add = function(fn, args) {\n        args = args || [];\n        this.hooks.push(fn);\n        this.args.push(args);\n    };\n    \n    $.jqplot.EventListenerManager = function () {\n        this.hooks =[];\n    };\n    \n    $.jqplot.EventListenerManager.prototype.addOnce = function(ev, fn) {\n        var havehook = false, h, i;\n        for (var i=0, l=this.hooks.length; i<l; i++) {\n            h = this.hooks[i];\n            if (h[0] == ev && h[1] == fn) {\n                havehook = true;\n            }\n        }\n        if (!havehook) {\n            this.hooks.push([ev, fn]);\n        }\n    };\n    \n    $.jqplot.EventListenerManager.prototype.add = function(ev, fn) {\n        this.hooks.push([ev, fn]);\n    };\n\n\n    var _axisNames = ['yMidAxis', 'xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];\n\n    /**\n     * Class: jqPlot\n     * Plot object returned by call to $.jqplot.  Handles parsing user options,\n     * creating sub objects (Axes, legend, title, series) and rendering the plot.\n     */\n    function jqPlot() {\n        // Group: Properties\n        // These properties are specified at the top of the options object\n        // like so:\n        // > {\n        // >     axesDefaults:{min:0},\n        // >     series:[{color:'#6633dd'}],\n        // >     title: 'A Plot'\n        // > }\n        //\n\n        // prop: animate\n        // True to animate the series on initial plot draw (renderer dependent).\n        // Actual animation functionality must be supported in the renderer.\n        this.animate = false;\n        // prop: animateReplot\n        // True to animate series after a call to the replot() method.\n        // Use with caution!  Replots can happen very frequently under\n        // certain circumstances (e.g. resizing, dragging points) and\n        // animation in these situations can cause problems.\n        this.animateReplot = false;\n        // prop: axes\n        // up to 4 axes are supported, each with its own options, \n        // See <Axis> for axis specific options.\n        this.axes = {xaxis: new Axis('xaxis'), yaxis: new Axis('yaxis'), x2axis: new Axis('x2axis'), y2axis: new Axis('y2axis'), y3axis: new Axis('y3axis'), y4axis: new Axis('y4axis'), y5axis: new Axis('y5axis'), y6axis: new Axis('y6axis'), y7axis: new Axis('y7axis'), y8axis: new Axis('y8axis'), y9axis: new Axis('y9axis'), yMidAxis: new Axis('yMidAxis')};\n        this.baseCanvas = new $.jqplot.GenericCanvas();\n        // true to intercept right click events and fire a 'jqplotRightClick' event.\n        // this will also block the context menu.\n        this.captureRightClick = false;\n        // prop: data\n        // user's data.  Data should *NOT* be specified in the options object,\n        // but be passed in as the second argument to the $.jqplot() function.\n        // The data property is described here soley for reference. \n        // The data should be in the form of an array of 2D or 1D arrays like\n        // > [ [[x1, y1], [x2, y2],...], [y1, y2, ...] ].\n        this.data = [];\n        // prop: dataRenderer\n        // A callable which can be used to preprocess data passed into the plot.\n        // Will be called with 3 arguments: the plot data, a reference to the plot,\n        // and the value of dataRendererOptions.\n        this.dataRenderer;\n        // prop: dataRendererOptions\n        // Options that will be passed to the dataRenderer.\n        // Can be of any type.\n        this.dataRendererOptions;\n        this.defaults = {\n            // prop: axesDefaults\n            // default options that will be applied to all axes.\n            // see <Axis> for axes options.\n            axesDefaults: {},\n            axes: {xaxis:{}, yaxis:{}, x2axis:{}, y2axis:{}, y3axis:{}, y4axis:{}, y5axis:{}, y6axis:{}, y7axis:{}, y8axis:{}, y9axis:{}, yMidAxis:{}},\n            // prop: seriesDefaults\n            // default options that will be applied to all series.\n            // see <Series> for series options.\n            seriesDefaults: {},\n            series:[]\n        };\n        // prop: defaultAxisStart\n        // 1-D data series are internally converted into 2-D [x,y] data point arrays\n        // by jqPlot.  This is the default starting value for the missing x or y value.\n        // The added data will be a monotonically increasing series (e.g. [1, 2, 3, ...])\n        // starting at this value.\n        this.defaultAxisStart = 1;\n        // this.doCustomEventBinding = true;\n        // prop: drawIfHidden\n        // True to execute the draw method even if the plot target is hidden.\n        // Generally, this should be false.  Most plot elements will not be sized/\n        // positioned correclty if renderered into a hidden container.  To render into\n        // a hidden container, call the replot method when the container is shown.\n        this.drawIfHidden = false;\n        this.eventCanvas = new $.jqplot.GenericCanvas();\n        // prop: fillBetween\n        // Fill between 2 line series in a plot.\n        // Options object:\n        // {\n        //    series1: first index (0 based) of series in fill\n        //    series2: second index (0 based) of series in fill\n        //    color: color of fill [default fillColor of series1]\n        //    baseSeries:  fill will be drawn below this series (0 based index)\n        //    fill: false to turn off fill [default true].\n        //  }\n        this.fillBetween = {\n            series1: null,\n            series2: null,\n            color: null,\n            baseSeries: 0,\n            fill: true\n        };\n        // prop; fontFamily\n        // css spec for the font-family attribute.  Default for the entire plot.\n        this.fontFamily;\n        // prop: fontSize\n        // css spec for the font-size attribute.  Default for the entire plot.\n        this.fontSize;\n        // prop: grid\n        // See <Grid> for grid specific options.\n        this.grid = new Grid();\n        // prop: legend\n        // see <$.jqplot.TableLegendRenderer>\n        this.legend = new Legend();\n        // prop: noDataIndicator\n        // Options to set up a mock plot with a data loading indicator if no data is specified.\n        this.noDataIndicator = {    \n            show: false,\n            indicator: 'Loading Data...',\n            axes: {\n                xaxis: {\n                    min: 0,\n                    max: 10,\n                    tickInterval: 2,\n                    show: true\n                },\n                yaxis: {\n                    min: 0,\n                    max: 12,\n                    tickInterval: 3,\n                    show: true\n                }\n            }\n        };\n        // prop: negativeSeriesColors \n        // colors to use for portions of the line below zero.\n        this.negativeSeriesColors = $.jqplot.config.defaultNegativeColors;\n        // container to hold all of the merged options.  Convienence for plugins.\n        this.options = {};\n        this.previousSeriesStack = [];\n        // Namespace to hold plugins.  Generally non-renderer plugins add themselves to here.\n        this.plugins = {};\n        // prop: series\n        // Array of series object options.\n        // see <Series> for series specific options.\n        this.series = [];\n        // array of series indices. Keep track of order\n        // which series canvases are displayed, lowest\n        // to highest, back to front.\n        this.seriesStack = [];\n        // prop: seriesColors\n        // Ann array of CSS color specifications that will be applied, in order,\n        // to the series in the plot.  Colors will wrap around so, if their\n        // are more series than colors, colors will be reused starting at the\n        // beginning.  For pie charts, this specifies the colors of the slices.\n        this.seriesColors = $.jqplot.config.defaultColors;\n        // prop: sortData\n        // false to not sort the data passed in by the user.\n        // Many bar, stacked and other graphs as well as many plugins depend on\n        // having sorted data.\n        this.sortData = true;\n        // prop: stackSeries\n        // true or false, creates a stack or \"mountain\" plot.\n        // Not all series renderers may implement this option.\n        this.stackSeries = false;\n        // a shortcut for axis syncTicks options.  Not implemented yet.\n        this.syncXTicks = true;\n        // a shortcut for axis syncTicks options.  Not implemented yet.\n        this.syncYTicks = true;\n        // the jquery object for the dom target.\n        this.target = null; \n        // The id of the dom element to render the plot into\n        this.targetId = null;\n        // prop textColor\n        // css spec for the css color attribute.  Default for the entire plot.\n        this.textColor;\n        // prop: title\n        // Title object.  See <Title> for specific options.  As a shortcut, you\n        // can specify the title option as just a string like: title: 'My Plot'\n        // and this will create a new title object with the specified text.\n        this.title = new Title();\n        // Count how many times the draw method has been called while the plot is visible.\n        // Mostly used to test if plot has never been dran (=0), has been successfully drawn\n        // into a visible container once (=1) or draw more than once into a visible container.\n        // Can use this in tests to see if plot has been visibly drawn at least one time.\n        // After plot has been visibly drawn once, it generally doesn't need redrawing if its\n        // container is hidden and shown.\n        this._drawCount = 0;\n        // sum of y values for all series in plot.\n        // used in mekko chart.\n        this._sumy = 0;\n        this._sumx = 0;\n        // array to hold the cumulative stacked series data.\n        // used to ajust the individual series data, which won't have access to other\n        // series data.\n        this._stackData = [];\n        // array that holds the data to be plotted. This will be the series data\n        // merged with the the appropriate data from _stackData according to the stackAxis.\n        this._plotData = [];\n        this._width = null;\n        this._height = null; \n        this._plotDimensions = {height:null, width:null};\n        this._gridPadding = {top:null, right:null, bottom:null, left:null};\n        this._defaultGridPadding = {top:10, right:10, bottom:23, left:10};\n\n        this._addDomReference = $.jqplot.config.addDomReference;\n\n        this.preInitHooks = new $.jqplot.HooksManager();\n        this.postInitHooks = new $.jqplot.HooksManager();\n        this.preParseOptionsHooks = new $.jqplot.HooksManager();\n        this.postParseOptionsHooks = new $.jqplot.HooksManager();\n        this.preDrawHooks = new $.jqplot.HooksManager();\n        this.postDrawHooks = new $.jqplot.HooksManager();\n        this.preDrawSeriesHooks = new $.jqplot.HooksManager();\n        this.postDrawSeriesHooks = new $.jqplot.HooksManager();\n        this.preDrawLegendHooks = new $.jqplot.HooksManager();\n        this.addLegendRowHooks = new $.jqplot.HooksManager();\n        this.preSeriesInitHooks = new $.jqplot.HooksManager();\n        this.postSeriesInitHooks = new $.jqplot.HooksManager();\n        this.preParseSeriesOptionsHooks = new $.jqplot.HooksManager();\n        this.postParseSeriesOptionsHooks = new $.jqplot.HooksManager();\n        this.eventListenerHooks = new $.jqplot.EventListenerManager();\n        this.preDrawSeriesShadowHooks = new $.jqplot.HooksManager();\n        this.postDrawSeriesShadowHooks = new $.jqplot.HooksManager();\n        \n        this.colorGenerator = new $.jqplot.ColorGenerator();\n        this.negativeColorGenerator = new $.jqplot.ColorGenerator();\n\n        this.canvasManager = new $.jqplot.CanvasManager();\n\n        this.themeEngine = new $.jqplot.ThemeEngine();\n        \n        var seriesColorsIndex = 0;\n\n        // Group: methods\n        //\n        // method: init\n        // sets the plot target, checks data and applies user\n        // options to plot.\n        this.init = function(target, data, options) {\n            options = options || {};\n            for (var i=0; i<$.jqplot.preInitHooks.length; i++) {\n                $.jqplot.preInitHooks[i].call(this, target, data, options);\n            }\n\n            for (var i=0; i<this.preInitHooks.hooks.length; i++) {\n                this.preInitHooks.hooks[i].call(this, target, data, options);\n            }\n            \n            this.targetId = '#'+target;\n            this.target = $('#'+target);\n\n            //////\n            // Add a reference to plot\n            //////\n            if (this._addDomReference) {\n                this.target.data('jqplot', this);\n            }\n            // remove any error class that may be stuck on target.\n            this.target.removeClass('jqplot-error');\n            if (!this.target.get(0)) {\n                throw new Error(\"No plot target specified\");\n            }\n            \n            // make sure the target is positioned by some means and set css\n            if (this.target.css('position') == 'static') {\n                this.target.css('position', 'relative');\n            }\n            if (!this.target.hasClass('jqplot-target')) {\n                this.target.addClass('jqplot-target');\n            }\n            \n            // if no height or width specified, use a default.\n            if (!this.target.height()) {\n                var h;\n                if (options && options.height) {\n                    h = parseInt(options.height, 10);\n                }\n                else if (this.target.attr('data-height')) {\n                    h = parseInt(this.target.attr('data-height'), 10);\n                }\n                else {\n                    h = parseInt($.jqplot.config.defaultHeight, 10);\n                }\n                this._height = h;\n                this.target.css('height', h+'px');\n            }\n            else {\n                this._height = h = this.target.height();\n            }\n            if (!this.target.width()) {\n                var w;\n                if (options && options.width) {\n                    w = parseInt(options.width, 10);\n                }\n                else if (this.target.attr('data-width')) {\n                    w = parseInt(this.target.attr('data-width'), 10);\n                }\n                else {\n                    w = parseInt($.jqplot.config.defaultWidth, 10);\n                }\n                this._width = w;\n                this.target.css('width', w+'px');\n            }\n            else {\n                this._width = w = this.target.width();\n            }\n\n            for (var i=0, l=_axisNames.length; i<l; i++) {\n                this.axes[_axisNames[i]] = new Axis(_axisNames[i]);\n            }\n            \n            this._plotDimensions.height = this._height;\n            this._plotDimensions.width = this._width;\n            this.grid._plotDimensions = this._plotDimensions;\n            this.title._plotDimensions = this._plotDimensions;\n            this.baseCanvas._plotDimensions = this._plotDimensions;\n            this.eventCanvas._plotDimensions = this._plotDimensions;\n            this.legend._plotDimensions = this._plotDimensions;\n            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {\n                throw new Error(\"Canvas dimension not set\");\n            }\n            \n            if (options.dataRenderer && $.isFunction(options.dataRenderer)) {\n                if (options.dataRendererOptions) {\n                    this.dataRendererOptions = options.dataRendererOptions;\n                }\n                this.dataRenderer = options.dataRenderer;\n                data = this.dataRenderer(data, this, this.dataRendererOptions);\n            }\n            \n            if (options.noDataIndicator && $.isPlainObject(options.noDataIndicator)) {\n                $.extend(true, this.noDataIndicator, options.noDataIndicator);\n            }\n            \n            if (data == null || $.isArray(data) == false || data.length == 0 || $.isArray(data[0]) == false || data[0].length == 0) {\n                \n                if (this.noDataIndicator.show == false) {\n                    throw new Error(\"No data specified\");\n                }\n                \n                else {\n                    // have to be descructive here in order for plot to not try and render series.\n                    // This means that $.jqplot() will have to be called again when there is data.\n                    //delete options.series;\n                    \n                    for (var ax in this.noDataIndicator.axes) {\n                        for (var prop in this.noDataIndicator.axes[ax]) {\n                            this.axes[ax][prop] = this.noDataIndicator.axes[ax][prop];\n                        }\n                    }\n                    \n                    this.postDrawHooks.add(function() {\n                        var eh = this.eventCanvas.getHeight();\n                        var ew = this.eventCanvas.getWidth();\n                        var temp = $('<div class=\"jqplot-noData-container\" style=\"position:absolute;\"></div>');\n                        this.target.append(temp);\n                        temp.height(eh);\n                        temp.width(ew);\n                        temp.css('top', this.eventCanvas._offsets.top);\n                        temp.css('left', this.eventCanvas._offsets.left);\n                        \n                        var temp2 = $('<div class=\"jqplot-noData-contents\" style=\"text-align:center; position:relative; margin-left:auto; margin-right:auto;\"></div>');\n                        temp.append(temp2);\n                        temp2.html(this.noDataIndicator.indicator);\n                        var th = temp2.height();\n                        var tw = temp2.width();\n                        temp2.height(th);\n                        temp2.width(tw);\n                        temp2.css('top', (eh - th)/2 + 'px');\n                    });\n\n                }\n            }\n            \n            // make a copy of the data\n            this.data = $.extend(true, [], data);\n            \n            this.parseOptions(options);\n            \n            if (this.textColor) {\n                this.target.css('color', this.textColor);\n            }\n            if (this.fontFamily) {\n                this.target.css('font-family', this.fontFamily);\n            }\n            if (this.fontSize) {\n                this.target.css('font-size', this.fontSize);\n            }\n            \n            this.title.init();\n            this.legend.init();\n            this._sumy = 0;\n            this._sumx = 0;\n            this.computePlotData();\n            for (var i=0; i<this.series.length; i++) {\n                // set default stacking order for series canvases\n                this.seriesStack.push(i);\n                this.previousSeriesStack.push(i);\n                this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;\n                this.series[i].canvas._plotDimensions = this._plotDimensions;\n                for (var j=0; j<$.jqplot.preSeriesInitHooks.length; j++) {\n                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                for (var j=0; j<this.preSeriesInitHooks.hooks.length; j++) {\n                    this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                // this.populatePlotData(this.series[i], i);\n                this.series[i]._plotDimensions = this._plotDimensions;\n                this.series[i].init(i, this.grid.borderWidth, this);\n                for (var j=0; j<$.jqplot.postSeriesInitHooks.length; j++) {\n                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                for (var j=0; j<this.postSeriesInitHooks.hooks.length; j++) {\n                    this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                this._sumy += this.series[i]._sumy;\n                this._sumx += this.series[i]._sumx;\n            }\n\n            var name,\n                axis;\n            for (var i=0, l=_axisNames.length; i<l; i++) {\n                name = _axisNames[i];\n                axis = this.axes[name];\n                axis._plotDimensions = this._plotDimensions;\n                axis.init();\n                if (this.axes[name].borderColor == null) {\n                    if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {\n                        axis.borderColor = axis._series[0].color;\n                    }\n                    else {\n                        axis.borderColor = this.grid.borderColor;\n                    }\n                }\n            }\n            \n            if (this.sortData) {\n                sortData(this.series);\n            }\n            this.grid.init();\n            this.grid._axes = this.axes;\n            \n            this.legend._series = this.series;\n\n            for (var i=0; i<$.jqplot.postInitHooks.length; i++) {\n                $.jqplot.postInitHooks[i].call(this, target, this.data, options);\n            }\n\n            for (var i=0; i<this.postInitHooks.hooks.length; i++) {\n                this.postInitHooks.hooks[i].call(this, target, this.data, options);\n            }\n        };  \n        \n        // method: resetAxesScale\n        // Reset the specified axes min, max, numberTicks and tickInterval properties to null\n        // or reset these properties on all axes if no list of axes is provided.\n        //\n        // Parameters:\n        // axes - Boolean to reset or not reset all axes or an array or object of axis names to reset.\n        this.resetAxesScale = function(axes, options) {\n            var opts = options || {};\n            var ax = axes || this.axes;\n            if (ax === true) {\n                ax = this.axes;\n            }\n            if ($.isArray(ax)) {\n                for (var i = 0; i < ax.length; i++) {\n                    this.axes[ax[i]].resetScale(opts[ax[i]]);\n                }\n            }\n            else if (typeof(ax) === 'object') {\n                for (var name in ax) {\n                    this.axes[name].resetScale(opts[name]);\n                }\n            }\n        };\n        // method: reInitialize\n        // reinitialize plot for replotting.\n        // not called directly.\n        this.reInitialize = function (data, opts) {\n            // Plot should be visible and have a height and width.\n            // If plot doesn't have height and width for some\n            // reason, set it by other means.  Plot must not have\n            // a display:none attribute, however.\n\n            var options = $.extend(true, {}, this.options, opts);\n\n            var target = this.targetId.substr(1);\n            var tdata = (data == null) ? this.data : data;\n\n            for (var i=0; i<$.jqplot.preInitHooks.length; i++) {\n                $.jqplot.preInitHooks[i].call(this, target, tdata, options);\n            }\n\n            for (var i=0; i<this.preInitHooks.hooks.length; i++) {\n                this.preInitHooks.hooks[i].call(this, target, tdata, options);\n            }\n            \n            this._height = this.target.height();\n            this._width = this.target.width();\n            \n            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {\n                throw new Error(\"Target dimension not set\");\n            }\n            \n            this._plotDimensions.height = this._height;\n            this._plotDimensions.width = this._width;\n            this.grid._plotDimensions = this._plotDimensions;\n            this.title._plotDimensions = this._plotDimensions;\n            this.baseCanvas._plotDimensions = this._plotDimensions;\n            this.eventCanvas._plotDimensions = this._plotDimensions;\n            this.legend._plotDimensions = this._plotDimensions;\n\n            var name,\n                t, \n                j, \n                axis;\n\n            for (var i=0, l=_axisNames.length; i<l; i++) {\n                name = _axisNames[i];\n                axis = this.axes[name];\n\n                // Memory Leaks patch : clear ticks elements\n                t = axis._ticks;\n                for (var j = 0, tlen = t.length; j < tlen; j++) {\n                  var el = t[j]._elem;\n                  if (el) {\n                    // if canvas renderer\n                    if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {\n                      window.G_vmlCanvasManager.uninitElement(el.get(0));\n                    }\n                    el.emptyForce();\n                    el = null;\n                    t._elem = null;\n                  }\n                }\n                t = null;\n\n                delete axis.ticks;\n                delete axis._ticks;\n                this.axes[name] = new Axis(name);\n                this.axes[name]._plotWidth = this._width;\n                this.axes[name]._plotHeight = this._height;\n            }\n            \n            if (data) {\n                if (options.dataRenderer && $.isFunction(options.dataRenderer)) {\n                    if (options.dataRendererOptions) {\n                        this.dataRendererOptions = options.dataRendererOptions;\n                    }\n                    this.dataRenderer = options.dataRenderer;\n                    data = this.dataRenderer(data, this, this.dataRendererOptions);\n                }\n                \n                // make a copy of the data\n                this.data = $.extend(true, [], data);\n            }\n\n            if (opts) {\n                this.parseOptions(options);\n            }\n            \n            this.title._plotWidth = this._width;\n            \n            if (this.textColor) {\n                this.target.css('color', this.textColor);\n            }\n            if (this.fontFamily) {\n                this.target.css('font-family', this.fontFamily);\n            }\n            if (this.fontSize) {\n                this.target.css('font-size', this.fontSize);\n            }\n\n            this.title.init();\n            this.legend.init();\n            this._sumy = 0;\n            this._sumx = 0;\n\n            this.seriesStack = [];\n            this.previousSeriesStack = [];\n\n            this.computePlotData();\n            for (var i=0, l=this.series.length; i<l; i++) {\n                // set default stacking order for series canvases\n                this.seriesStack.push(i);\n                this.previousSeriesStack.push(i);\n                this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;\n                this.series[i].canvas._plotDimensions = this._plotDimensions;\n                for (var j=0; j<$.jqplot.preSeriesInitHooks.length; j++) {\n                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                for (var j=0; j<this.preSeriesInitHooks.hooks.length; j++) {\n                    this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                // this.populatePlotData(this.series[i], i);\n                this.series[i]._plotDimensions = this._plotDimensions;\n                this.series[i].init(i, this.grid.borderWidth, this);\n                for (var j=0; j<$.jqplot.postSeriesInitHooks.length; j++) {\n                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                for (var j=0; j<this.postSeriesInitHooks.hooks.length; j++) {\n                    this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);\n                }\n                this._sumy += this.series[i]._sumy;\n                this._sumx += this.series[i]._sumx;\n            }\n\n            for (var i=0, l=_axisNames.length; i<l; i++) {\n                name = _axisNames[i];\n                axis = this.axes[name];\n\n                axis._plotDimensions = this._plotDimensions;\n                axis.init();\n                if (axis.borderColor == null) {\n                    if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {\n                        axis.borderColor = axis._series[0].color;\n                    }\n                    else {\n                        axis.borderColor = this.grid.borderColor;\n                    }\n                }\n            }\n            \n            if (this.sortData) {\n                sortData(this.series);\n            }\n            this.grid.init();\n            this.grid._axes = this.axes;\n            \n            this.legend._series = this.series;\n\n            for (var i=0, l=$.jqplot.postInitHooks.length; i<l; i++) {\n                $.jqplot.postInitHooks[i].call(this, target, this.data, options);\n            }\n\n            for (var i=0, l=this.postInitHooks.hooks.length; i<l; i++) {\n                this.postInitHooks.hooks[i].call(this, target, this.data, options);\n            }\n        };\n\n\n\n        // method: quickInit\n        // \n        // Quick reinitialization plot for replotting.\n        // Does not parse options ore recreate axes and series.\n        // not called directly.\n        this.quickInit = function () {\n            // Plot should be visible and have a height and width.\n            // If plot doesn't have height and width for some\n            // reason, set it by other means.  Plot must not have\n            // a display:none attribute, however.\n            \n            this._height = this.target.height();\n            this._width = this.target.width();\n            \n            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {\n                throw new Error(\"Target dimension not set\");\n            }\n            \n            this._plotDimensions.height = this._height;\n            this._plotDimensions.width = this._width;\n            this.grid._plotDimensions = this._plotDimensions;\n            this.title._plotDimensions = this._plotDimensions;\n            this.baseCanvas._plotDimensions = this._plotDimensions;\n            this.eventCanvas._plotDimensions = this._plotDimensions;\n            this.legend._plotDimensions = this._plotDimensions;\n            \n            for (var n in this.axes) {\n                this.axes[n]._plotWidth = this._width;\n                this.axes[n]._plotHeight = this._height;\n            }\n            \n            this.title._plotWidth = this._width;\n            \n            if (this.textColor) {\n                this.target.css('color', this.textColor);\n            }\n            if (this.fontFamily) {\n                this.target.css('font-family', this.fontFamily);\n            }\n            if (this.fontSize) {\n                this.target.css('font-size', this.fontSize);\n            }\n            \n            this._sumy = 0;\n            this._sumx = 0;\n            this.computePlotData();\n            for (var i=0; i<this.series.length; i++) {\n                // this.populatePlotData(this.series[i], i);\n                if (this.series[i]._type === 'line' && this.series[i].renderer.bands.show) {\n                    this.series[i].renderer.initBands.call(this.series[i], this.series[i].renderer.options, this);\n                }\n                this.series[i]._plotDimensions = this._plotDimensions;\n                this.series[i].canvas._plotDimensions = this._plotDimensions;\n                //this.series[i].init(i, this.grid.borderWidth);\n                this._sumy += this.series[i]._sumy;\n                this._sumx += this.series[i]._sumx;\n            }\n\n            var name;\n            \n            for (var j=0; j<12; j++) {\n                name = _axisNames[j];\n                // Memory Leaks patch : clear ticks elements\n                var t = this.axes[name]._ticks;\n                for (var i = 0; i < t.length; i++) {\n                  var el = t[i]._elem;\n                  if (el) {\n                    // if canvas renderer\n                    if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {\n                      window.G_vmlCanvasManager.uninitElement(el.get(0));\n                    }\n                    el.emptyForce();\n                    el = null;\n                    t._elem = null;\n                  }\n                }\n                t = null;\n                \n                this.axes[name]._plotDimensions = this._plotDimensions;\n                this.axes[name]._ticks = [];\n                // this.axes[name].renderer.init.call(this.axes[name], {});\n            }\n            \n            if (this.sortData) {\n                sortData(this.series);\n            }\n            \n            this.grid._axes = this.axes;\n            \n            this.legend._series = this.series;\n        };\n        \n        // sort the series data in increasing order.\n        function sortData(series) {\n            var d, sd, pd, ppd, ret;\n            for (var i=0; i<series.length; i++) {\n                var check;\n                var bat = [series[i].data, series[i]._stackData, series[i]._plotData, series[i]._prevPlotData];\n                for (var n=0; n<4; n++) {\n                    check = true;\n                    d = bat[n];\n                    if (series[i]._stackAxis == 'x') {\n                        for (var j = 0; j < d.length; j++) {\n                            if (typeof(d[j][1]) != \"number\") {\n                                check = false;\n                                break;\n                            }\n                        }\n                        if (check) {\n                            d.sort(function(a,b) { return a[1] - b[1]; });\n                        }\n                    }\n                    else {\n                        for (var j = 0; j < d.length; j++) {\n                            if (typeof(d[j][0]) != \"number\") {\n                                check = false;\n                                break;\n                            }\n                        }\n                        if (check) {\n                            d.sort(function(a,b) { return a[0] - b[0]; });\n                        }\n                    }\n                }\n               \n            }\n        }\n\n        this.computePlotData = function() {\n            this._plotData = [];\n            this._stackData = [];\n            var series,\n                index,\n                l;\n\n\n            for (index=0, l=this.series.length; index<l; index++) {\n                series = this.series[index];\n                this._plotData.push([]);\n                this._stackData.push([]);\n                var cd = series.data;\n                this._plotData[index] = $.extend(true, [], cd);\n                this._stackData[index] = $.extend(true, [], cd);\n                series._plotData = this._plotData[index];\n                series._stackData = this._stackData[index];\n                var plotValues = {x:[], y:[]};\n\n                if (this.stackSeries && !series.disableStack) {\n                    series._stack = true;\n                    ///////////////////////////\n                    // have to check for nulls\n                    ///////////////////////////\n                    var sidx = (series._stackAxis === 'x') ? 0 : 1;\n\n                    for (var k=0, cdl=cd.length; k<cdl; k++) {\n                        var temp = cd[k][sidx];\n                        if (temp == null) {\n                            temp = 0;\n                        }\n                        this._plotData[index][k][sidx] = temp;\n                        this._stackData[index][k][sidx] = temp;\n\n                        if (index > 0) {\n                            for (var j=index; j--;) {\n                                var prevval = this._plotData[j][k][sidx];\n                                // only need to sum up the stack axis column of data\n                                // and only sum if it is of same sign.\n                                // if previous series isn't same sign, keep looking\n                                // at earlier series untill we find one of same sign.\n                                if (temp * prevval >= 0) {\n                                    this._plotData[index][k][sidx] += prevval;\n                                    this._stackData[index][k][sidx] += prevval;\n                                    break;\n                                } \n                            }\n                        }\n                    }\n\n                }\n                else {\n                    for (var i=0; i<series.data.length; i++) {\n                        plotValues.x.push(series.data[i][0]);\n                        plotValues.y.push(series.data[i][1]);\n                    }\n                    this._stackData.push(series.data);\n                    this.series[index]._stackData = series.data;\n                    this._plotData.push(series.data);\n                    series._plotData = series.data;\n                    series._plotValues = plotValues;\n                }\n                if (index>0) {\n                    series._prevPlotData = this.series[index-1]._plotData;\n                }\n                series._sumy = 0;\n                series._sumx = 0;\n                for (i=series.data.length-1; i>-1; i--) {\n                    series._sumy += series.data[i][1];\n                    series._sumx += series.data[i][0];\n                }\n            }\n\n        };\n        \n        // populate the _stackData and _plotData arrays for the plot and the series.\n        this.populatePlotData = function(series, index) {\n            // if a stacked chart, compute the stacked data\n            this._plotData = [];\n            this._stackData = [];\n            series._stackData = [];\n            series._plotData = [];\n            var plotValues = {x:[], y:[]};\n            if (this.stackSeries && !series.disableStack) {\n                series._stack = true;\n                var sidx = (series._stackAxis === 'x') ? 0 : 1;\n                // var idx = sidx ? 0 : 1;\n                // push the current data into stackData\n                //this._stackData.push(this.series[i].data);\n                var temp = $.extend(true, [], series.data);\n                // create the data that will be plotted for this series\n                var plotdata = $.extend(true, [], series.data);\n                var tempx, tempy, dval, stackval, comparator;\n                // for first series, nothing to add to stackData.\n                for (var j=0; j<index; j++) {\n                    var cd = this.series[j].data;\n                    for (var k=0; k<cd.length; k++) {\n                        dval = cd[k];\n                        tempx = (dval[0] != null) ? dval[0] : 0;\n                        tempy = (dval[1] != null) ? dval[1] : 0;\n                        temp[k][0] += tempx;\n                        temp[k][1] += tempy;\n                        stackval = (sidx) ? tempy : tempx;\n                        // only need to sum up the stack axis column of data\n                        // and only sum if it is of same sign.\n                        if (series.data[k][sidx] * stackval >= 0) {\n                            plotdata[k][sidx] += stackval;\n                        }\n                    }\n                }\n                for (var i=0; i<plotdata.length; i++) {\n                    plotValues.x.push(plotdata[i][0]);\n                    plotValues.y.push(plotdata[i][1]);\n                }\n                this._plotData.push(plotdata);\n                this._stackData.push(temp);\n                series._stackData = temp;\n                series._plotData = plotdata;\n                series._plotValues = plotValues;\n            }\n            else {\n                for (var i=0; i<series.data.length; i++) {\n                    plotValues.x.push(series.data[i][0]);\n                    plotValues.y.push(series.data[i][1]);\n                }\n                this._stackData.push(series.data);\n                this.series[index]._stackData = series.data;\n                this._plotData.push(series.data);\n                series._plotData = series.data;\n                series._plotValues = plotValues;\n            }\n            if (index>0) {\n                series._prevPlotData = this.series[index-1]._plotData;\n            }\n            series._sumy = 0;\n            series._sumx = 0;\n            for (i=series.data.length-1; i>-1; i--) {\n                series._sumy += series.data[i][1];\n                series._sumx += series.data[i][0];\n            }\n        };\n        \n        // function to safely return colors from the color array and wrap around at the end.\n        this.getNextSeriesColor = (function(t) {\n            var idx = 0;\n            var sc = t.seriesColors;\n            \n            return function () { \n                if (idx < sc.length) {\n                    return sc[idx++];\n                }\n                else {\n                    idx = 0;\n                    return sc[idx++];\n                }\n            };\n        })(this);\n    \n        this.parseOptions = function(options){\n            for (var i=0; i<this.preParseOptionsHooks.hooks.length; i++) {\n                this.preParseOptionsHooks.hooks[i].call(this, options);\n            }\n            for (var i=0; i<$.jqplot.preParseOptionsHooks.length; i++) {\n                $.jqplot.preParseOptionsHooks[i].call(this, options);\n            }\n            this.options = $.extend(true, {}, this.defaults, options);\n            var opts = this.options;\n            this.animate = opts.animate;\n            this.animateReplot = opts.animateReplot;\n            this.stackSeries = opts.stackSeries;\n            if ($.isPlainObject(opts.fillBetween)) {\n\n                var temp = ['series1', 'series2', 'color', 'baseSeries', 'fill'], \n                    tempi;\n\n                for (var i=0, l=temp.length; i<l; i++) {\n                    tempi = temp[i];\n                    if (opts.fillBetween[tempi] != null) {\n                        this.fillBetween[tempi] = opts.fillBetween[tempi];\n                    }\n                }\n            }\n\n            if (opts.seriesColors) {\n                this.seriesColors = opts.seriesColors;\n            }\n            if (opts.negativeSeriesColors) {\n                this.negativeSeriesColors = opts.negativeSeriesColors;\n            }\n            if (opts.captureRightClick) {\n                this.captureRightClick = opts.captureRightClick;\n            }\n            this.defaultAxisStart = (options && options.defaultAxisStart != null) ? options.defaultAxisStart : this.defaultAxisStart;\n            this.colorGenerator.setColors(this.seriesColors);\n            this.negativeColorGenerator.setColors(this.negativeSeriesColors);\n            // var cg = new this.colorGenerator(this.seriesColors);\n            // var ncg = new this.colorGenerator(this.negativeSeriesColors);\n            // this._gridPadding = this.options.gridPadding;\n            $.extend(true, this._gridPadding, opts.gridPadding);\n            this.sortData = (opts.sortData != null) ? opts.sortData : this.sortData;\n            for (var i=0; i<12; i++) {\n                var n = _axisNames[i];\n                var axis = this.axes[n];\n                axis._options = $.extend(true, {}, opts.axesDefaults, opts.axes[n]);\n                $.extend(true, axis, opts.axesDefaults, opts.axes[n]);\n                axis._plotWidth = this._width;\n                axis._plotHeight = this._height;\n            }\n            // if (this.data.length == 0) {\n            //     this.data = [];\n            //     for (var i=0; i<this.options.series.length; i++) {\n            //         this.data.push(this.options.series.data);\n            //     }    \n            // }\n                \n            var normalizeData = function(data, dir, start) {\n                // return data as an array of point arrays,\n                // in form [[x1,y1...], [x2,y2...], ...]\n                var temp = [];\n                var i, l;\n                dir = dir || 'vertical';\n                if (!$.isArray(data[0])) {\n                    // we have a series of scalars.  One line with just y values.\n                    // turn the scalar list of data into a data array of form:\n                    // [[1, data[0]], [2, data[1]], ...]\n                    for (i=0, l=data.length; i<l; i++) {\n                        if (dir == 'vertical') {\n                            temp.push([start + i, data[i]]);   \n                        }\n                        else {\n                            temp.push([data[i], start+i]);\n                        }\n                    }\n                }            \n                else {\n                    // we have a properly formatted data series, copy it.\n                    $.extend(true, temp, data);\n                }\n                return temp;\n            };\n\n            var colorIndex = 0;\n            this.series = [];\n            for (var i=0; i<this.data.length; i++) {\n                var sopts = $.extend(true, {index: i}, {seriesColors:this.seriesColors, negativeSeriesColors:this.negativeSeriesColors}, this.options.seriesDefaults, this.options.series[i], {rendererOptions:{animation:{show: this.animate}}});\n                // pass in options in case something needs set prior to initialization.\n                var temp = new Series(sopts);\n                for (var j=0; j<$.jqplot.preParseSeriesOptionsHooks.length; j++) {\n                    $.jqplot.preParseSeriesOptionsHooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);\n                }\n                for (var j=0; j<this.preParseSeriesOptionsHooks.hooks.length; j++) {\n                    this.preParseSeriesOptionsHooks.hooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);\n                }\n                // Now go back and apply the options to the series.  Really should just do this during initializaiton, but don't want to\n                // mess up preParseSeriesOptionsHooks at this point.\n                $.extend(true, temp, sopts);\n                var dir = 'vertical';\n                if (temp.renderer === $.jqplot.BarRenderer && temp.rendererOptions && temp.rendererOptions.barDirection == 'horizontal') {\n                    dir = 'horizontal';\n                    temp._stackAxis = 'x';\n                    temp._primaryAxis = '_yaxis';\n                }\n                temp.data = normalizeData(this.data[i], dir, this.defaultAxisStart);\n                switch (temp.xaxis) {\n                    case 'xaxis':\n                        temp._xaxis = this.axes.xaxis;\n                        break;\n                    case 'x2axis':\n                        temp._xaxis = this.axes.x2axis;\n                        break;\n                    default:\n                        break;\n                }\n                temp._yaxis = this.axes[temp.yaxis];\n                temp._xaxis._series.push(temp);\n                temp._yaxis._series.push(temp);\n                if (temp.show) {\n                    temp._xaxis.show = true;\n                    temp._yaxis.show = true;\n                }\n                else {\n                    if (temp._xaxis.scaleToHiddenSeries) {\n                        temp._xaxis.show = true;\n                    }\n                    if (temp._yaxis.scaleToHiddenSeries) {\n                        temp._yaxis.show = true;\n                    }\n                }\n\n                // // parse the renderer options and apply default colors if not provided\n                // if (!temp.color && temp.show != false) {\n                //     temp.color = cg.next();\n                //     colorIndex = cg.getIndex() - 1;;\n                // }\n                // if (!temp.negativeColor && temp.show != false) {\n                //     temp.negativeColor = ncg.get(colorIndex);\n                //     ncg.setIndex(colorIndex);\n                // }\n                if (!temp.label) {\n                    temp.label = 'Series '+ (i+1).toString();\n                }\n                // temp.rendererOptions.show = temp.show;\n                // $.extend(true, temp.renderer, {color:this.seriesColors[i]}, this.rendererOptions);\n                this.series.push(temp);  \n                for (var j=0; j<$.jqplot.postParseSeriesOptionsHooks.length; j++) {\n                    $.jqplot.postParseSeriesOptionsHooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);\n                }\n                for (var j=0; j<this.postParseSeriesOptionsHooks.hooks.length; j++) {\n                    this.postParseSeriesOptionsHooks.hooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);\n                }\n            }\n            \n            // copy the grid and title options into this object.\n            $.extend(true, this.grid, this.options.grid);\n            // if axis border properties aren't set, set default.\n            for (var i=0, l=_axisNames.length; i<l; i++) {\n                var n = _axisNames[i];\n                var axis = this.axes[n];\n                if (axis.borderWidth == null) {\n                    axis.borderWidth =this.grid.borderWidth;\n                }\n            }\n            \n            if (typeof this.options.title == 'string') {\n                this.title.text = this.options.title;\n            }\n            else if (typeof this.options.title == 'object') {\n                $.extend(true, this.title, this.options.title);\n            }\n            this.title._plotWidth = this._width;\n            this.legend.setOptions(this.options.legend);\n            \n            for (var i=0; i<$.jqplot.postParseOptionsHooks.length; i++) {\n                $.jqplot.postParseOptionsHooks[i].call(this, options);\n            }\n            for (var i=0; i<this.postParseOptionsHooks.hooks.length; i++) {\n                this.postParseOptionsHooks.hooks[i].call(this, options);\n            }\n        };\n        \n        // method: destroy\n        // Releases all resources occupied by the plot\n        this.destroy = function() {\n            this.canvasManager.freeAllCanvases();\n            if (this.eventCanvas && this.eventCanvas._elem) {\n                this.eventCanvas._elem.unbind();\n            }\n            // Couple of posts on Stack Overflow indicate that empty() doesn't\n            // always cear up the dom and release memory.  Sometimes setting\n            // innerHTML property to null is needed.  Particularly on IE, may \n            // have to directly set it to null, bypassing $.\n            this.target.empty();\n\n            this.target[0].innerHTML = '';\n        };\n        \n        // method: replot\n        // Does a reinitialization of the plot followed by\n        // a redraw.  Method could be used to interactively\n        // change plot characteristics and then replot.\n        //\n        // Parameters:\n        // options - Options used for replotting.\n        //\n        // Properties:\n        // clear - false to not clear (empty) the plot container before replotting (default: true).\n        // resetAxes - true to reset all axes min, max, numberTicks and tickInterval setting so axes will rescale themselves.\n        //             optionally pass in list of axes to reset (e.g. ['xaxis', 'y2axis']) (default: false).\n        this.replot = function(options) {\n            var opts =  options || {};\n            var data = opts.data || null;\n            var clear = (opts.clear === false) ? false : true;\n            var resetAxes = opts.resetAxes || false;\n            delete opts.data;\n            delete opts.clear;\n            delete opts.resetAxes;\n\n            this.target.trigger('jqplotPreReplot');\n            \n            if (clear) {\n                this.destroy();\n            }\n            // if have data or other options, full reinit.\n            // otherwise, quickinit.\n            if (data || !$.isEmptyObject(opts)) {\n                this.reInitialize(data, opts);\n            }\n            else {\n                this.quickInit();\n            }\n\n            if (resetAxes) {\n                this.resetAxesScale(resetAxes, opts.axes);\n            }\n            this.draw();\n            this.target.trigger('jqplotPostReplot');\n        };\n        \n        // method: redraw\n        // Empties the plot target div and redraws the plot.\n        // This enables plot data and properties to be changed\n        // and then to comletely clear the plot and redraw.\n        // redraw *will not* reinitialize any plot elements.\n        // That is, axes will not be autoscaled and defaults\n        // will not be reapplied to any plot elements.  redraw\n        // is used primarily with zooming. \n        //\n        // Parameters:\n        // clear - false to not clear (empty) the plot container before redrawing (default: true).\n        this.redraw = function(clear) {\n            clear = (clear != null) ? clear : true;\n            this.target.trigger('jqplotPreRedraw');\n            if (clear) {\n                this.canvasManager.freeAllCanvases();\n                this.eventCanvas._elem.unbind();\n                // Dont think I bind any events to the target, this shouldn't be necessary.\n                // It will remove user's events.\n                // this.target.unbind();\n                this.target.empty();\n            }\n             for (var ax in this.axes) {\n                this.axes[ax]._ticks = [];\n            }\n            this.computePlotData();\n            // for (var i=0; i<this.series.length; i++) {\n            //     this.populatePlotData(this.series[i], i);\n            // }\n            this._sumy = 0;\n            this._sumx = 0;\n            for (var i=0, tsl = this.series.length; i<tsl; i++) {\n                this._sumy += this.series[i]._sumy;\n                this._sumx += this.series[i]._sumx;\n            }\n            this.draw();\n            this.target.trigger('jqplotPostRedraw');\n        };\n        \n        // method: draw\n        // Draws all elements of the plot into the container.\n        // Does not clear the container before drawing.\n        this.draw = function(){\n            if (this.drawIfHidden || this.target.is(':visible')) {\n                this.target.trigger('jqplotPreDraw');\n                var i,\n                    j,\n                    l,\n                    tempseries;\n                for (i=0, l=$.jqplot.preDrawHooks.length; i<l; i++) {\n                    $.jqplot.preDrawHooks[i].call(this);\n                }\n                for (i=0, l=this.preDrawHooks.hooks.length; i<l; i++) {\n                    this.preDrawHooks.hooks[i].apply(this, this.preDrawSeriesHooks.args[i]);\n                }\n                // create an underlying canvas to be used for special features.\n                this.target.append(this.baseCanvas.createElement({left:0, right:0, top:0, bottom:0}, 'jqplot-base-canvas', null, this));\n                this.baseCanvas.setContext();\n                this.target.append(this.title.draw());\n                this.title.pack({top:0, left:0});\n                \n                // make room  for the legend between the grid and the edge.\n                // pass a dummy offsets object and a reference to the plot.\n                var legendElem = this.legend.draw({}, this);\n                \n                var gridPadding = {top:0, left:0, bottom:0, right:0};\n                \n                if (this.legend.placement == \"outsideGrid\") {\n                    // temporarily append the legend to get dimensions\n                    this.target.append(legendElem);\n                    switch (this.legend.location) {\n                        case 'n':\n                            gridPadding.top += this.legend.getHeight();\n                            break;\n                        case 's':\n                            gridPadding.bottom += this.legend.getHeight();\n                            break;\n                        case 'ne':\n                        case 'e':\n                        case 'se':\n                            gridPadding.right += this.legend.getWidth();\n                            break;\n                        case 'nw':\n                        case 'w':\n                        case 'sw':\n                            gridPadding.left += this.legend.getWidth();\n                            break;\n                        default:  // same as 'ne'\n                            gridPadding.right += this.legend.getWidth();\n                            break;\n                    }\n                    legendElem = legendElem.detach();\n                }\n                \n                var ax = this.axes;\n                var name;\n                // draw the yMidAxis first, so xaxis of pyramid chart can adjust itself if needed.\n                for (i=0; i<12; i++) {\n                    name = _axisNames[i];\n                    this.target.append(ax[name].draw(this.baseCanvas._ctx, this));\n                    ax[name].set();\n                }\n                if (ax.yaxis.show) {\n                    gridPadding.left += ax.yaxis.getWidth();\n                }\n                var ra = ['y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];\n                var rapad = [0, 0, 0, 0, 0, 0, 0, 0];\n                var gpr = 0;\n                var n;\n                for (n=0; n<8; n++) {\n                    if (ax[ra[n]].show) {\n                        gpr += ax[ra[n]].getWidth();\n                        rapad[n] = gpr;\n                    }\n                }\n                gridPadding.right += gpr;\n                if (ax.x2axis.show) {\n                    gridPadding.top += ax.x2axis.getHeight();\n                }\n                if (this.title.show) {\n                    gridPadding.top += this.title.getHeight();\n                }\n                if (ax.xaxis.show) {\n                    gridPadding.bottom += ax.xaxis.getHeight();\n                }\n                \n                // end of gridPadding adjustments.\n\n                // if user passed in gridDimensions option, check against calculated gridPadding\n                if (this.options.gridDimensions && $.isPlainObject(this.options.gridDimensions)) {\n                    var gdw = parseInt(this.options.gridDimensions.width, 10) || 0;\n                    var gdh = parseInt(this.options.gridDimensions.height, 10) || 0;\n                    var widthAdj = (this._width - gridPadding.left - gridPadding.right - gdw)/2;\n                    var heightAdj = (this._height - gridPadding.top - gridPadding.bottom - gdh)/2;\n\n                    if (heightAdj >= 0 && widthAdj >= 0) {\n                        gridPadding.top += heightAdj;\n                        gridPadding.bottom += heightAdj;\n                        gridPadding.left += widthAdj;\n                        gridPadding.right += widthAdj;\n                    }\n                }\n                var arr = ['top', 'bottom', 'left', 'right'];\n                for (var n in arr) {\n                    if (this._gridPadding[arr[n]] == null && gridPadding[arr[n]] > 0) {\n                        this._gridPadding[arr[n]] = gridPadding[arr[n]];\n                    }\n                    else if (this._gridPadding[arr[n]] == null) {\n                        this._gridPadding[arr[n]] = this._defaultGridPadding[arr[n]];\n                    }\n                }\n                \n                var legendPadding = this._gridPadding;\n                \n                if (this.legend.placement === 'outsideGrid') {\n                    legendPadding = {top:this.title.getHeight(), left: 0, right: 0, bottom: 0};\n                }\n                \n                ax.xaxis.pack({position:'absolute', bottom:this._gridPadding.bottom - ax.xaxis.getHeight(), left:0, width:this._width}, {min:this._gridPadding.left, max:this._width - this._gridPadding.right});\n                ax.yaxis.pack({position:'absolute', top:0, left:this._gridPadding.left - ax.yaxis.getWidth(), height:this._height}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});\n                ax.x2axis.pack({position:'absolute', top:this._gridPadding.top - ax.x2axis.getHeight(), left:0, width:this._width}, {min:this._gridPadding.left, max:this._width - this._gridPadding.right});\n                for (i=8; i>0; i--) {\n                    ax[ra[i-1]].pack({position:'absolute', top:0, right:this._gridPadding.right - rapad[i-1]}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});\n                }\n                var ltemp = (this._width - this._gridPadding.left - this._gridPadding.right)/2.0 + this._gridPadding.left - ax.yMidAxis.getWidth()/2.0;\n                ax.yMidAxis.pack({position:'absolute', top:0, left:ltemp, zIndex:9, textAlign: 'center'}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});\n            \n                this.target.append(this.grid.createElement(this._gridPadding, this));\n                this.grid.draw();\n                \n                var series = this.series;\n                var seriesLength = series.length;\n                // put the shadow canvases behind the series canvases so shadows don't overlap on stacked bars.\n                for (i=0, l=seriesLength; i<l; i++) {\n                    // draw series in order of stacking.  This affects only\n                    // order in which canvases are added to dom.\n                    j = this.seriesStack[i];\n                    this.target.append(series[j].shadowCanvas.createElement(this._gridPadding, 'jqplot-series-shadowCanvas', null, this));\n                    series[j].shadowCanvas.setContext();\n                    series[j].shadowCanvas._elem.data('seriesIndex', j);\n                }\n                \n                for (i=0, l=seriesLength; i<l; i++) {\n                    // draw series in order of stacking.  This affects only\n                    // order in which canvases are added to dom.\n                    j = this.seriesStack[i];\n                    this.target.append(series[j].canvas.createElement(this._gridPadding, 'jqplot-series-canvas', null, this));\n                    series[j].canvas.setContext();\n                    series[j].canvas._elem.data('seriesIndex', j);\n                }\n                // Need to use filled canvas to capture events in IE.\n                // Also, canvas seems to block selection of other elements in document on FF.\n                this.target.append(this.eventCanvas.createElement(this._gridPadding, 'jqplot-event-canvas', null, this));\n                this.eventCanvas.setContext();\n                this.eventCanvas._ctx.fillStyle = 'rgba(0,0,0,0)';\n                this.eventCanvas._ctx.fillRect(0,0,this.eventCanvas._ctx.canvas.width, this.eventCanvas._ctx.canvas.height);\n            \n                // bind custom event handlers to regular events.\n                this.bindCustomEvents();\n            \n                // draw legend before series if the series needs to know the legend dimensions.\n                if (this.legend.preDraw) {  \n                    this.eventCanvas._elem.before(legendElem);\n                    this.legend.pack(legendPadding);\n                    if (this.legend._elem) {\n                        this.drawSeries({legendInfo:{location:this.legend.location, placement:this.legend.placement, width:this.legend.getWidth(), height:this.legend.getHeight(), xoffset:this.legend.xoffset, yoffset:this.legend.yoffset}});\n                    }\n                    else {\n                        this.drawSeries();\n                    }\n                }\n                else {  // draw series before legend\n                    this.drawSeries();\n                    if (seriesLength) {\n                        $(series[seriesLength-1].canvas._elem).after(legendElem);\n                    }\n                    this.legend.pack(legendPadding);                \n                }\n            \n                // register event listeners on the overlay canvas\n                for (var i=0, l=$.jqplot.eventListenerHooks.length; i<l; i++) {\n                    // in the handler, this will refer to the eventCanvas dom element.\n                    // make sure there are references back into plot objects.\n                    this.eventCanvas._elem.bind($.jqplot.eventListenerHooks[i][0], {plot:this}, $.jqplot.eventListenerHooks[i][1]);\n                }\n            \n                // register event listeners on the overlay canvas\n                for (var i=0, l=this.eventListenerHooks.hooks.length; i<l; i++) {\n                    // in the handler, this will refer to the eventCanvas dom element.\n                    // make sure there are references back into plot objects.\n                    this.eventCanvas._elem.bind(this.eventListenerHooks.hooks[i][0], {plot:this}, this.eventListenerHooks.hooks[i][1]);\n                }\n\n                var fb = this.fillBetween;\n                if(typeof fb.series1 == 'number'){\n                    if(fb.fill&&fb.series1!==fb.series2&&fb.series1<seriesLength&&fb.series2<seriesLength&&series[fb.series1]._type===\"line\"&&series[fb.series2]._type===\"line\")\n                    this.doFillBetweenLines();\n                }\n                else{\n                    if(fb.series1 != null && fb.series2 != null){\n                        var doFb = false;\n                        if(fb.series1.length === fb.series2.length){\n                            var tempSeries1 = 0;\n                            var tempSeries2 = 0;\n                            \n                            for(var cnt = 0; cnt < fb.series1.length; cnt++){\n                                tempSeries1 = fb.series1[cnt];\n                                tempSeries2 = fb.series2[cnt];\n                                if(tempSeries1!==tempSeries2&&tempSeries1<seriesLength&&tempSeries2<seriesLength&&series[tempSeries1]._type===\"line\"&&series[tempSeries2]._type===\"line\"){\n                                    doFb = true;\n                                }\n                                else{\n                                    doFb = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(fb.fill && doFb){\n                            this.doFillBetweenLines();\n                        }\n                    }\n                }\n\n                for (var i=0, l=$.jqplot.postDrawHooks.length; i<l; i++) {\n                    $.jqplot.postDrawHooks[i].call(this);\n                }\n\n                for (var i=0, l=this.postDrawHooks.hooks.length; i<l; i++) {\n                    this.postDrawHooks.hooks[i].apply(this, this.postDrawHooks.args[i]);\n                }\n            \n                if (this.target.is(':visible')) {\n                    this._drawCount += 1;\n                }\n\n                var temps, \n                    tempr,\n                    sel,\n                    _els;\n                // ughh.  ideally would hide all series then show them.\n                for (i=0, l=seriesLength; i<l; i++) {\n                    temps = series[i];\n                    tempr = temps.renderer;\n                    sel = '.jqplot-point-label.jqplot-series-'+i;\n                    if (tempr.animation && tempr.animation._supported && tempr.animation.show && (this._drawCount < 2 || this.animateReplot)) {\n                        _els = this.target.find(sel);\n                        _els.stop(true, true).hide();\n                        temps.canvas._elem.stop(true, true).hide();\n                        temps.shadowCanvas._elem.stop(true, true).hide();\n                        temps.canvas._elem.jqplotEffect('blind', {mode: 'show', direction: tempr.animation.direction}, tempr.animation.speed);\n                        temps.shadowCanvas._elem.jqplotEffect('blind', {mode: 'show', direction: tempr.animation.direction}, tempr.animation.speed);\n                        _els.fadeIn(tempr.animation.speed*0.8);\n                    }\n                }\n                _els = null;\n            \n                this.target.trigger('jqplotPostDraw', [this]);\n            }\n        };\n\n        jqPlot.prototype.doFillBetweenLines = function () {\n            var fb = this.fillBetween;\n            var series = this.series;\n            var sid1 = fb.series1;\n            var sid2 = fb.series2;\n            var id1 = 0, id2 = 0;\n\n            function fill(id1, id2){\n                var series1 = series[id1];\n                var series2 = series[id2];\n                if (series2.renderer.smooth)\n                    var tempgd = series2.renderer._smoothedData.slice(0).reverse();\n                else\n                    var tempgd = series2.gridData.slice(0).reverse();\n                if (series1.renderer.smooth)\n                    var gd = series1.renderer._smoothedData.concat(tempgd);\n                else\n                    var gd = series1.gridData.concat(tempgd);\n                var color = fb.color !== null ? fb.color : series[id1].fillColor;\n                var baseSeries = fb.baseSeries !== null ? fb.baseSeries : id1;\n                var sr =\n                    series[baseSeries].renderer.shapeRenderer;\n                var opts =\n                {\n                    fillStyle : color,\n                    fill : true,\n                    closePath : true\n                };\n                sr.draw(series1.shadowCanvas._ctx, gd, opts)\n            }\n\n            if(typeof sid1 == 'number' && typeof sid2 == 'number'){\n                id1 = sid1 < sid2 ? sid1 : sid2;\n                id2 = sid2 > sid1 ? sid2 : sid1;\n                fill(id1, id2);\n            }\n            else{\n                for(var cnt = 0; cnt < sid1.length ; cnt++){\n                    id1 = sid1[cnt] < sid2[cnt] ? sid1[cnt] : sid2[cnt];\n                    id2 = sid2[cnt] > sid1[cnt] ? sid2[cnt] : sid1[cnt];\n                    fill(id1, id2);\n                }\n            }\n        };\n        \n        this.bindCustomEvents = function() {\n            this.eventCanvas._elem.bind('click', {plot:this}, this.onClick);\n            this.eventCanvas._elem.bind('dblclick', {plot:this}, this.onDblClick);\n            this.eventCanvas._elem.bind('mousedown', {plot:this}, this.onMouseDown);\n            this.eventCanvas._elem.bind('mousemove', {plot:this}, this.onMouseMove);\n            this.eventCanvas._elem.bind('mouseenter', {plot:this}, this.onMouseEnter);\n            this.eventCanvas._elem.bind('mouseleave', {plot:this}, this.onMouseLeave);\n            if (this.captureRightClick) {\n                this.eventCanvas._elem.bind('mouseup', {plot:this}, this.onRightClick);\n                this.eventCanvas._elem.get(0).oncontextmenu = function() {\n                    return false;\n                };\n            }\n            else {\n                this.eventCanvas._elem.bind('mouseup', {plot:this}, this.onMouseUp);\n            }\n        };\n        \n        function getEventPosition(ev) {\n            var plot = ev.data.plot;\n            var go = plot.eventCanvas._elem.offset();\n            var gridPos = {x:ev.pageX - go.left, y:ev.pageY - go.top};\n            var dataPos = {xaxis:null, yaxis:null, x2axis:null, y2axis:null, y3axis:null, y4axis:null, y5axis:null, y6axis:null, y7axis:null, y8axis:null, y9axis:null, yMidAxis:null};\n            var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];\n            var ax = plot.axes;\n            var n, axis;\n            for (n=11; n>0; n--) {\n                axis = an[n-1];\n                if (ax[axis].show) {\n                    dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);\n                }\n            }\n\n            return {offsets:go, gridPos:gridPos, dataPos:dataPos};\n        }\n        \n        \n        // function to check if event location is over a area area\n        function checkIntersection(gridpos, plot) {\n            var series = plot.series;\n            var i, j, k, s, r, x, y, theta, sm, sa, minang, maxang;\n            var d0, d, p, pp, points, bw, hp;\n            var threshold, t;\n            for (k=plot.seriesStack.length-1; k>=0; k--) {\n                i = plot.seriesStack[k];\n                s = series[i];\n                hp = s._highlightThreshold;\n                switch (s.renderer.constructor) {\n                    case $.jqplot.BarRenderer:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        for (j=0; j<s._barPoints.length; j++) {\n                            points = s._barPoints[j];\n                            p = s.gridData[j];\n                            if (x>points[0][0] && x<points[2][0] && (y>points[2][1] && y<points[0][1] || y<points[2][1] && y>points[0][1])) {\n                                return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};\n                            }\n                        }\n                        break;\n                    case $.jqplot.PyramidRenderer:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        for (j=0; j<s._barPoints.length; j++) {\n                            points = s._barPoints[j];\n                            p = s.gridData[j];\n                            if (x > points[0][0] + hp[0][0] && x < points[2][0] + hp[2][0] && y > points[2][1] && y < points[0][1]) {\n                                return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};\n                            }\n                        }\n                        break;\n                    \n                    case $.jqplot.DonutRenderer:\n                        sa = s.startAngle/180*Math.PI;\n                        x = gridpos.x - s._center[0];\n                        y = gridpos.y - s._center[1];\n                        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n                        if (x > 0 && -y >= 0) {\n                            theta = 2*Math.PI - Math.atan(-y/x);\n                        }\n                        else if (x > 0 && -y < 0) {\n                            theta = -Math.atan(-y/x);\n                        }\n                        else if (x < 0) {\n                            theta = Math.PI - Math.atan(-y/x);\n                        }\n                        else if (x == 0 && -y > 0) {\n                            theta = 3*Math.PI/2;\n                        }\n                        else if (x == 0 && -y < 0) {\n                            theta = Math.PI/2;\n                        }\n                        else if (x == 0 && y == 0) {\n                            theta = 0;\n                        }\n                        if (sa) {\n                            theta -= sa;\n                            if (theta < 0) {\n                                theta += 2*Math.PI;\n                            }\n                            else if (theta > 2*Math.PI) {\n                                theta -= 2*Math.PI;\n                            }\n                        }\n            \n                        sm = s.sliceMargin/180*Math.PI;\n                        if (r < s._radius && r > s._innerRadius) {\n                            for (j=0; j<s.gridData.length; j++) {\n                                minang = (j>0) ? s.gridData[j-1][1]+sm : sm;\n                                maxang = s.gridData[j][1];\n                                if (theta > minang && theta < maxang) {\n                                    return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};\n                                }\n                            }\n                        }\n                        break;\n                        \n                    case $.jqplot.PieRenderer:\n                        sa = s.startAngle/180*Math.PI;\n                        x = gridpos.x - s._center[0];\n                        y = gridpos.y - s._center[1];\n                        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n                        if (x > 0 && -y >= 0) {\n                            theta = 2*Math.PI - Math.atan(-y/x);\n                        }\n                        else if (x > 0 && -y < 0) {\n                            theta = -Math.atan(-y/x);\n                        }\n                        else if (x < 0) {\n                            theta = Math.PI - Math.atan(-y/x);\n                        }\n                        else if (x == 0 && -y > 0) {\n                            theta = 3*Math.PI/2;\n                        }\n                        else if (x == 0 && -y < 0) {\n                            theta = Math.PI/2;\n                        }\n                        else if (x == 0 && y == 0) {\n                            theta = 0;\n                        }\n                        if (sa) {\n                            theta -= sa;\n                            if (theta < 0) {\n                                theta += 2*Math.PI;\n                            }\n                            else if (theta > 2*Math.PI) {\n                                theta -= 2*Math.PI;\n                            }\n                        }\n            \n                        sm = s.sliceMargin/180*Math.PI;\n                        if (r < s._radius) {\n                            for (j=0; j<s.gridData.length; j++) {\n                                minang = (j>0) ? s.gridData[j-1][1]+sm : sm;\n                                maxang = s.gridData[j][1];\n                                if (theta > minang && theta < maxang) {\n                                    return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};\n                                }\n                            }\n                        }\n                        break;\n                        \n                    case $.jqplot.BubbleRenderer:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        var ret = null;\n                        \n                        if (s.show) {\n                            for (var j=0; j<s.gridData.length; j++) {\n                                p = s.gridData[j];\n                                d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );\n                                if (d <= p[2] && (d <= d0 || d0 == null)) {\n                                   d0 = d;\n                                   ret = {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                }\n                            }\n                            if (ret != null) {\n                                return ret;\n                            }\n                        }\n                        break;\n                        \n                    case $.jqplot.FunnelRenderer:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        var v = s._vertices,\n                            vfirst = v[0],\n                            vlast = v[v.length-1],\n                            lex,\n                            rex,\n                            cv;\n    \n                        // equations of right and left sides, returns x, y values given height of section (y value and 2 points)\n    \n                        function findedge (l, p1 , p2) {\n                            var m = (p1[1] - p2[1])/(p1[0] - p2[0]);\n                            var b = p1[1] - m*p1[0];\n                            var y = l + p1[1];\n        \n                            return [(y - b)/m, y];\n                        }\n    \n                        // check each section\n                        lex = findedge(y, vfirst[0], vlast[3]);\n                        rex = findedge(y, vfirst[1], vlast[2]);\n                        for (j=0; j<v.length; j++) {\n                            cv = v[j];\n                            if (y >= cv[0][1] && y <= cv[3][1] && x >= lex[0] && x <= rex[0]) {\n                                return {seriesIndex:s.index, pointIndex:j, gridData:null, data:s.data[j]};\n                            }\n                        }         \n                        break;           \n                    \n                    case $.jqplot.LineRenderer:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        r = s.renderer;\n                        if (s.show) {\n                            if ((s.fill || (s.renderer.bands.show && s.renderer.bands.fill)) && (!plot.plugins.highlighter || !plot.plugins.highlighter.show)) {\n                                // first check if it is in bounding box\n                                var inside = false;\n                                if (x>s._boundingBox[0][0] && x<s._boundingBox[1][0] && y>s._boundingBox[1][1] && y<s._boundingBox[0][1]) { \n                                    // now check the crossing number   \n                                    \n                                    var numPoints = s._areaPoints.length;\n                                    var ii;\n                                    var j = numPoints-1;\n\n                                    for(var ii=0; ii < numPoints; ii++) { \n                                        var vertex1 = [s._areaPoints[ii][0], s._areaPoints[ii][1]];\n                                        var vertex2 = [s._areaPoints[j][0], s._areaPoints[j][1]];\n\n                                        if (vertex1[1] < y && vertex2[1] >= y || vertex2[1] < y && vertex1[1] >= y)     {\n                                            if (vertex1[0] + (y - vertex1[1]) / (vertex2[1] - vertex1[1]) * (vertex2[0] - vertex1[0]) < x) {\n                                                inside = !inside;\n                                            }\n                                        }\n\n                                        j = ii;\n                                    }        \n                                }\n                                if (inside) {\n                                    return {seriesIndex:i, pointIndex:null, gridData:s.gridData, data:s.data, points:s._areaPoints};\n                                }\n                                break;\n                                \n                            }\n\n                            else {\n                                t = s.markerRenderer.size/2+s.neighborThreshold;\n                                threshold = (t > 0) ? t : 0;\n                                for (var j=0; j<s.gridData.length; j++) {\n                                    p = s.gridData[j];\n                                    // neighbor looks different to OHLC chart.\n                                    if (r.constructor == $.jqplot.OHLCRenderer) {\n                                        if (r.candleStick) {\n                                            var yp = s._yaxis.series_u2p;\n                                            if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {\n                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                            }\n                                        }\n                                        // if an open hi low close chart\n                                        else if (!r.hlc){\n                                            var yp = s._yaxis.series_u2p;\n                                            if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {\n                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                            }\n                                        }\n                                        // a hi low close chart\n                                        else {\n                                            var yp = s._yaxis.series_u2p;\n                                            if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {\n                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                            }\n                                        }\n                            \n                                    }\n                                    else if (p[0] != null && p[1] != null){\n                                        d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );\n                                        if (d <= threshold && (d <= d0 || d0 == null)) {\n                                           d0 = d;\n                                           return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                        }\n                                    }\n                                } \n                            }\n                        }\n                        break;\n                        \n                    default:\n                        x = gridpos.x;\n                        y = gridpos.y;\n                        r = s.renderer;\n                        if (s.show) {\n                            t = s.markerRenderer.size/2+s.neighborThreshold;\n                            threshold = (t > 0) ? t : 0;\n                            for (var j=0; j<s.gridData.length; j++) {\n                                p = s.gridData[j];\n                                // neighbor looks different to OHLC chart.\n                                if (r.constructor == $.jqplot.OHLCRenderer) {\n                                    if (r.candleStick) {\n                                        var yp = s._yaxis.series_u2p;\n                                        if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {\n                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                        }\n                                    }\n                                    // if an open hi low close chart\n                                    else if (!r.hlc){\n                                        var yp = s._yaxis.series_u2p;\n                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {\n                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                        }\n                                    }\n                                    // a hi low close chart\n                                    else {\n                                        var yp = s._yaxis.series_u2p;\n                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {\n                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                        }\n                                    }\n                            \n                                }\n                                else {\n                                    d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );\n                                    if (d <= threshold && (d <= d0 || d0 == null)) {\n                                       d0 = d;\n                                       return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};\n                                    }\n                                }\n                            } \n                        }\n                        break;\n                }\n            }\n            \n            return null;\n        }\n        \n        \n        \n        this.onClick = function(ev) {\n            // Event passed in is normalized and will have data attribute.\n            // Event passed out is unnormalized.\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var neighbor = checkIntersection(positions.gridPos, p);\n            var evt = $.Event('jqplotClick');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n        };\n        \n        this.onDblClick = function(ev) {\n            // Event passed in is normalized and will have data attribute.\n            // Event passed out is unnormalized.\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var neighbor = checkIntersection(positions.gridPos, p);\n            var evt = $.Event('jqplotDblClick');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n        };\n        \n        this.onMouseDown = function(ev) {\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var neighbor = checkIntersection(positions.gridPos, p);\n            var evt = $.Event('jqplotMouseDown');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n        };\n        \n        this.onMouseUp = function(ev) {\n            var positions = getEventPosition(ev);\n            var evt = $.Event('jqplotMouseUp');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, ev.data.plot]);\n        };\n        \n        this.onRightClick = function(ev) {\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var neighbor = checkIntersection(positions.gridPos, p);\n            if (p.captureRightClick) {\n                if (ev.which == 3) {\n                var evt = $.Event('jqplotRightClick');\n                evt.pageX = ev.pageX;\n                evt.pageY = ev.pageY;\n                    $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n                }\n                else {\n                var evt = $.Event('jqplotMouseUp');\n                evt.pageX = ev.pageX;\n                evt.pageY = ev.pageY;\n                    $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n                }\n            }\n        };\n        \n        this.onMouseMove = function(ev) {\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var neighbor = checkIntersection(positions.gridPos, p);\n            var evt = $.Event('jqplotMouseMove');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);\n        };\n        \n        this.onMouseEnter = function(ev) {\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var evt = $.Event('jqplotMouseEnter');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            evt.relatedTarget = ev.relatedTarget;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);\n        };\n        \n        this.onMouseLeave = function(ev) {\n            var positions = getEventPosition(ev);\n            var p = ev.data.plot;\n            var evt = $.Event('jqplotMouseLeave');\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            evt.relatedTarget = ev.relatedTarget;\n            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);\n        };\n        \n        // method: drawSeries\n        // Redraws all or just one series on the plot.  No axis scaling\n        // is performed and no other elements on the plot are redrawn.\n        // options is an options object to pass on to the series renderers.\n        // It can be an empty object {}.  idx is the series index\n        // to redraw if only one series is to be redrawn.\n        this.drawSeries = function(options, idx){\n            var i, series, ctx;\n            // if only one argument passed in and it is a number, use it ad idx.\n            idx = (typeof(options) === \"number\" && idx == null) ? options : idx;\n            options = (typeof(options) === \"object\") ? options : {};\n            // draw specified series\n            if (idx != undefined) {\n                series = this.series[idx];\n                ctx = series.shadowCanvas._ctx;\n                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                series.drawShadow(ctx, options, this);\n                ctx = series.canvas._ctx;\n                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                series.draw(ctx, options, this);\n                if (series.renderer.constructor == $.jqplot.BezierCurveRenderer) {\n                    if (idx < this.series.length - 1) {\n                        this.drawSeries(idx+1); \n                    }\n                }\n            }\n            \n            else {\n                // if call series drawShadow method first, in case all series shadows\n                // should be drawn before any series.  This will ensure, like for \n                // stacked bar plots, that shadows don't overlap series.\n                for (i=0; i<this.series.length; i++) {\n                    // first clear the canvas\n                    series = this.series[i];\n                    ctx = series.shadowCanvas._ctx;\n                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                    series.drawShadow(ctx, options, this);\n                    ctx = series.canvas._ctx;\n                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                    series.draw(ctx, options, this);\n                }\n            }\n            options = idx = i = series = ctx = null;\n        };\n        \n        // method: moveSeriesToFront\n        // This method requires jQuery 1.4+\n        // Moves the specified series canvas in front of all other series canvases.\n        // This effectively \"draws\" the specified series on top of all other series,\n        // although it is performed through DOM manipulation, no redrawing is performed.\n        //\n        // Parameters:\n        // idx - 0 based index of the series to move.  This will be the index of the series\n        // as it was first passed into the jqplot function.\n        this.moveSeriesToFront = function (idx) { \n            idx = parseInt(idx, 10);\n            var stackIndex = $.inArray(idx, this.seriesStack);\n            // if already in front, return\n            if (stackIndex == -1) {\n                return;\n            }\n            if (stackIndex == this.seriesStack.length -1) {\n                this.previousSeriesStack = this.seriesStack.slice(0);\n                return;\n            }\n            var opidx = this.seriesStack[this.seriesStack.length -1];\n            var serelem = this.series[idx].canvas._elem.detach();\n            var shadelem = this.series[idx].shadowCanvas._elem.detach();\n            this.series[opidx].shadowCanvas._elem.after(shadelem);\n            this.series[opidx].canvas._elem.after(serelem);\n            this.previousSeriesStack = this.seriesStack.slice(0);\n            this.seriesStack.splice(stackIndex, 1);\n            this.seriesStack.push(idx);\n        };\n        \n        // method: moveSeriesToBack\n        // This method requires jQuery 1.4+\n        // Moves the specified series canvas behind all other series canvases.\n        //\n        // Parameters:\n        // idx - 0 based index of the series to move.  This will be the index of the series\n        // as it was first passed into the jqplot function.\n        this.moveSeriesToBack = function (idx) {\n            idx = parseInt(idx, 10);\n            var stackIndex = $.inArray(idx, this.seriesStack);\n            // if already in back, return\n            if (stackIndex == 0 || stackIndex == -1) {\n                return;\n            }\n            var opidx = this.seriesStack[0];\n            var serelem = this.series[idx].canvas._elem.detach();\n            var shadelem = this.series[idx].shadowCanvas._elem.detach();\n            this.series[opidx].shadowCanvas._elem.before(shadelem);\n            this.series[opidx].canvas._elem.before(serelem);\n            this.previousSeriesStack = this.seriesStack.slice(0);\n            this.seriesStack.splice(stackIndex, 1);\n            this.seriesStack.unshift(idx);\n        };\n        \n        // method: restorePreviousSeriesOrder\n        // This method requires jQuery 1.4+\n        // Restore the series canvas order to its previous state.\n        // Useful to put a series back where it belongs after moving\n        // it to the front.\n        this.restorePreviousSeriesOrder = function () {\n            var i, j, serelem, shadelem, temp, move, keep;\n            // if no change, return.\n            if (this.seriesStack == this.previousSeriesStack) {\n                return;\n            }\n            for (i=1; i<this.previousSeriesStack.length; i++) {\n                move = this.previousSeriesStack[i];\n                keep = this.previousSeriesStack[i-1];\n                serelem = this.series[move].canvas._elem.detach();\n                shadelem = this.series[move].shadowCanvas._elem.detach();\n                this.series[keep].shadowCanvas._elem.after(shadelem);\n                this.series[keep].canvas._elem.after(serelem);\n            }\n            temp = this.seriesStack.slice(0);\n            this.seriesStack = this.previousSeriesStack.slice(0);\n            this.previousSeriesStack = temp;\n        };\n        \n        // method: restoreOriginalSeriesOrder\n        // This method requires jQuery 1.4+\n        // Restore the series canvas order to its original order\n        // when the plot was created.\n        this.restoreOriginalSeriesOrder = function () {\n            var i, j, arr=[], serelem, shadelem;\n            for (i=0; i<this.series.length; i++) {\n                arr.push(i);\n            }\n            if (this.seriesStack == arr) {\n                return;\n            }\n            this.previousSeriesStack = this.seriesStack.slice(0);\n            this.seriesStack = arr;\n            for (i=1; i<this.seriesStack.length; i++) {\n                serelem = this.series[i].canvas._elem.detach();\n                shadelem = this.series[i].shadowCanvas._elem.detach();\n                this.series[i-1].shadowCanvas._elem.after(shadelem);\n                this.series[i-1].canvas._elem.after(serelem);\n            }\n        };\n        \n        this.activateTheme = function (name) {\n            this.themeEngine.activate(this, name);\n        };\n    }\n    \n    \n    // conpute a highlight color or array of highlight colors from given colors.\n    $.jqplot.computeHighlightColors  = function(colors) {\n        var ret;\n        if ($.isArray(colors)) {\n            ret = [];\n            for (var i=0; i<colors.length; i++){\n                var rgba = $.jqplot.getColorComponents(colors[i]);\n                var newrgb = [rgba[0], rgba[1], rgba[2]];\n                var sum = newrgb[0] + newrgb[1] + newrgb[2];\n                for (var j=0; j<3; j++) {\n                    // when darkening, lowest color component can be is 60.\n                    newrgb[j] = (sum > 660) ?  newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;\n                    newrgb[j] = parseInt(newrgb[j], 10);\n                    (newrgb[j] > 255) ? 255 : newrgb[j];\n                }\n                // newrgb[3] = (rgba[3] > 0.4) ? rgba[3] * 0.4 : rgba[3] * 1.5;\n                // newrgb[3] = (rgba[3] > 0.5) ? 0.8 * rgba[3] - .1 : rgba[3] + 0.2;\n                newrgb[3] = 0.3 + 0.35 * rgba[3];\n                ret.push('rgba('+newrgb[0]+','+newrgb[1]+','+newrgb[2]+','+newrgb[3]+')');\n            }\n        }\n        else {\n            var rgba = $.jqplot.getColorComponents(colors);\n            var newrgb = [rgba[0], rgba[1], rgba[2]];\n            var sum = newrgb[0] + newrgb[1] + newrgb[2];\n            for (var j=0; j<3; j++) {\n                // when darkening, lowest color component can be is 60.\n                // newrgb[j] = (sum > 570) ?  newrgb[j] * 0.8 : newrgb[j] + 0.3 * (255 - newrgb[j]);\n                // newrgb[j] = parseInt(newrgb[j], 10);\n                newrgb[j] = (sum > 660) ?  newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;\n                newrgb[j] = parseInt(newrgb[j], 10);\n                (newrgb[j] > 255) ? 255 : newrgb[j];\n            }\n            // newrgb[3] = (rgba[3] > 0.4) ? rgba[3] * 0.4 : rgba[3] * 1.5;\n            // newrgb[3] = (rgba[3] > 0.5) ? 0.8 * rgba[3] - .1 : rgba[3] + 0.2;\n            newrgb[3] = 0.3 + 0.35 * rgba[3];\n            ret = 'rgba('+newrgb[0]+','+newrgb[1]+','+newrgb[2]+','+newrgb[3]+')';\n        }\n        return ret;\n    };\n        \n   $.jqplot.ColorGenerator = function(colors) {\n        colors = colors || $.jqplot.config.defaultColors;\n        var idx = 0;\n        \n        this.next = function () { \n            if (idx < colors.length) {\n                return colors[idx++];\n            }\n            else {\n                idx = 0;\n                return colors[idx++];\n            }\n        };\n        \n        this.previous = function () { \n            if (idx > 0) {\n                return colors[idx--];\n            }\n            else {\n                idx = colors.length-1;\n                return colors[idx];\n            }\n        };\n        \n        // get a color by index without advancing pointer.\n        this.get = function(i) {\n            var idx = i - colors.length * Math.floor(i/colors.length);\n            return colors[idx];\n        };\n        \n        this.setColors = function(c) {\n            colors = c;\n        };\n        \n        this.reset = function() {\n            idx = 0;\n        };\n\n        this.getIndex = function() {\n            return idx;\n        };\n\n        this.setIndex = function(index) {\n            idx = index;\n        };\n    };\n\n    // convert a hex color string to rgb string.\n    // h - 3 or 6 character hex string, with or without leading #\n    // a - optional alpha\n    $.jqplot.hex2rgb = function(h, a) {\n        h = h.replace('#', '');\n        if (h.length == 3) {\n            h = h.charAt(0)+h.charAt(0)+h.charAt(1)+h.charAt(1)+h.charAt(2)+h.charAt(2);\n        }\n        var rgb;\n        rgb = 'rgba('+parseInt(h.slice(0,2), 16)+', '+parseInt(h.slice(2,4), 16)+', '+parseInt(h.slice(4,6), 16);\n        if (a) {\n            rgb += ', '+a;\n        }\n        rgb += ')';\n        return rgb;\n    };\n    \n    // convert an rgb color spec to a hex spec.  ignore any alpha specification.\n    $.jqplot.rgb2hex = function(s) {\n        var pat = /rgba?\\( *([0-9]{1,3}\\.?[0-9]*%?) *, *([0-9]{1,3}\\.?[0-9]*%?) *, *([0-9]{1,3}\\.?[0-9]*%?) *(?:, *[0-9.]*)?\\)/;\n        var m = s.match(pat);\n        var h = '#';\n        for (var i=1; i<4; i++) {\n            var temp;\n            if (m[i].search(/%/) != -1) {\n                temp = parseInt(255*m[i]/100, 10).toString(16);\n                if (temp.length == 1) {\n                    temp = '0'+temp;\n                }\n            }\n            else {\n                temp = parseInt(m[i], 10).toString(16);\n                if (temp.length == 1) {\n                    temp = '0'+temp;\n                }\n            }\n            h += temp;\n        }\n        return h;\n    };\n    \n    // given a css color spec, return an rgb css color spec\n    $.jqplot.normalize2rgb = function(s, a) {\n        if (s.search(/^ *rgba?\\(/) != -1) {\n            return s; \n        }\n        else if (s.search(/^ *#?[0-9a-fA-F]?[0-9a-fA-F]/) != -1) {\n            return $.jqplot.hex2rgb(s, a);\n        }\n        else {\n            throw new Error('Invalid color spec');\n        }\n    };\n    \n    // extract the r, g, b, a color components out of a css color spec.\n    $.jqplot.getColorComponents = function(s) {\n        // check to see if a color keyword.\n        s = $.jqplot.colorKeywordMap[s] || s;\n        var rgb = $.jqplot.normalize2rgb(s);\n        var pat = /rgba?\\( *([0-9]{1,3}\\.?[0-9]*%?) *, *([0-9]{1,3}\\.?[0-9]*%?) *, *([0-9]{1,3}\\.?[0-9]*%?) *,? *([0-9.]* *)?\\)/;\n        var m = rgb.match(pat);\n        var ret = [];\n        for (var i=1; i<4; i++) {\n            if (m[i].search(/%/) != -1) {\n                ret[i-1] = parseInt(255*m[i]/100, 10);\n            }\n            else {\n                ret[i-1] = parseInt(m[i], 10);\n            }\n        }\n        ret[3] = parseFloat(m[4]) ? parseFloat(m[4]) : 1.0;\n        return ret;\n    };\n    \n    $.jqplot.colorKeywordMap = {\n        aliceblue: 'rgb(240, 248, 255)',\n        antiquewhite: 'rgb(250, 235, 215)',\n        aqua: 'rgb( 0, 255, 255)',\n        aquamarine: 'rgb(127, 255, 212)',\n        azure: 'rgb(240, 255, 255)',\n        beige: 'rgb(245, 245, 220)',\n        bisque: 'rgb(255, 228, 196)',\n        black: 'rgb( 0, 0, 0)',\n        blanchedalmond: 'rgb(255, 235, 205)',\n        blue: 'rgb( 0, 0, 255)',\n        blueviolet: 'rgb(138, 43, 226)',\n        brown: 'rgb(165, 42, 42)',\n        burlywood: 'rgb(222, 184, 135)',\n        cadetblue: 'rgb( 95, 158, 160)',\n        chartreuse: 'rgb(127, 255, 0)',\n        chocolate: 'rgb(210, 105, 30)',\n        coral: 'rgb(255, 127, 80)',\n        cornflowerblue: 'rgb(100, 149, 237)',\n        cornsilk: 'rgb(255, 248, 220)',\n        crimson: 'rgb(220, 20, 60)',\n        cyan: 'rgb( 0, 255, 255)',\n        darkblue: 'rgb( 0, 0, 139)',\n        darkcyan: 'rgb( 0, 139, 139)',\n        darkgoldenrod: 'rgb(184, 134, 11)',\n        darkgray: 'rgb(169, 169, 169)',\n        darkgreen: 'rgb( 0, 100, 0)',\n        darkgrey: 'rgb(169, 169, 169)',\n        darkkhaki: 'rgb(189, 183, 107)',\n        darkmagenta: 'rgb(139, 0, 139)',\n        darkolivegreen: 'rgb( 85, 107, 47)',\n        darkorange: 'rgb(255, 140, 0)',\n        darkorchid: 'rgb(153, 50, 204)',\n        darkred: 'rgb(139, 0, 0)',\n        darksalmon: 'rgb(233, 150, 122)',\n        darkseagreen: 'rgb(143, 188, 143)',\n        darkslateblue: 'rgb( 72, 61, 139)',\n        darkslategray: 'rgb( 47, 79, 79)',\n        darkslategrey: 'rgb( 47, 79, 79)',\n        darkturquoise: 'rgb( 0, 206, 209)',\n        darkviolet: 'rgb(148, 0, 211)',\n        deeppink: 'rgb(255, 20, 147)',\n        deepskyblue: 'rgb( 0, 191, 255)',\n        dimgray: 'rgb(105, 105, 105)',\n        dimgrey: 'rgb(105, 105, 105)',\n        dodgerblue: 'rgb( 30, 144, 255)',\n        firebrick: 'rgb(178, 34, 34)',\n        floralwhite: 'rgb(255, 250, 240)',\n        forestgreen: 'rgb( 34, 139, 34)',\n        fuchsia: 'rgb(255, 0, 255)',\n        gainsboro: 'rgb(220, 220, 220)',\n        ghostwhite: 'rgb(248, 248, 255)',\n        gold: 'rgb(255, 215, 0)',\n        goldenrod: 'rgb(218, 165, 32)',\n        gray: 'rgb(128, 128, 128)',\n        grey: 'rgb(128, 128, 128)',\n        green: 'rgb( 0, 128, 0)',\n        greenyellow: 'rgb(173, 255, 47)',\n        honeydew: 'rgb(240, 255, 240)',\n        hotpink: 'rgb(255, 105, 180)',\n        indianred: 'rgb(205, 92, 92)',\n        indigo: 'rgb( 75, 0, 130)',\n        ivory: 'rgb(255, 255, 240)',\n        khaki: 'rgb(240, 230, 140)',\n        lavender: 'rgb(230, 230, 250)',\n        lavenderblush: 'rgb(255, 240, 245)',\n        lawngreen: 'rgb(124, 252, 0)',\n        lemonchiffon: 'rgb(255, 250, 205)',\n        lightblue: 'rgb(173, 216, 230)',\n        lightcoral: 'rgb(240, 128, 128)',\n        lightcyan: 'rgb(224, 255, 255)',\n        lightgoldenrodyellow: 'rgb(250, 250, 210)',\n        lightgray: 'rgb(211, 211, 211)',\n        lightgreen: 'rgb(144, 238, 144)',\n        lightgrey: 'rgb(211, 211, 211)',\n        lightpink: 'rgb(255, 182, 193)',\n        lightsalmon: 'rgb(255, 160, 122)',\n        lightseagreen: 'rgb( 32, 178, 170)',\n        lightskyblue: 'rgb(135, 206, 250)',\n        lightslategray: 'rgb(119, 136, 153)',\n        lightslategrey: 'rgb(119, 136, 153)',\n        lightsteelblue: 'rgb(176, 196, 222)',\n        lightyellow: 'rgb(255, 255, 224)',\n        lime: 'rgb( 0, 255, 0)',\n        limegreen: 'rgb( 50, 205, 50)',\n        linen: 'rgb(250, 240, 230)',\n        magenta: 'rgb(255, 0, 255)',\n        maroon: 'rgb(128, 0, 0)',\n        mediumaquamarine: 'rgb(102, 205, 170)',\n        mediumblue: 'rgb( 0, 0, 205)',\n        mediumorchid: 'rgb(186, 85, 211)',\n        mediumpurple: 'rgb(147, 112, 219)',\n        mediumseagreen: 'rgb( 60, 179, 113)',\n        mediumslateblue: 'rgb(123, 104, 238)',\n        mediumspringgreen: 'rgb( 0, 250, 154)',\n        mediumturquoise: 'rgb( 72, 209, 204)',\n        mediumvioletred: 'rgb(199, 21, 133)',\n        midnightblue: 'rgb( 25, 25, 112)',\n        mintcream: 'rgb(245, 255, 250)',\n        mistyrose: 'rgb(255, 228, 225)',\n        moccasin: 'rgb(255, 228, 181)',\n        navajowhite: 'rgb(255, 222, 173)',\n        navy: 'rgb( 0, 0, 128)',\n        oldlace: 'rgb(253, 245, 230)',\n        olive: 'rgb(128, 128, 0)',\n        olivedrab: 'rgb(107, 142, 35)',\n        orange: 'rgb(255, 165, 0)',\n        orangered: 'rgb(255, 69, 0)',\n        orchid: 'rgb(218, 112, 214)',\n        palegoldenrod: 'rgb(238, 232, 170)',\n        palegreen: 'rgb(152, 251, 152)',\n        paleturquoise: 'rgb(175, 238, 238)',\n        palevioletred: 'rgb(219, 112, 147)',\n        papayawhip: 'rgb(255, 239, 213)',\n        peachpuff: 'rgb(255, 218, 185)',\n        peru: 'rgb(205, 133, 63)',\n        pink: 'rgb(255, 192, 203)',\n        plum: 'rgb(221, 160, 221)',\n        powderblue: 'rgb(176, 224, 230)',\n        purple: 'rgb(128, 0, 128)',\n        red: 'rgb(255, 0, 0)',\n        rosybrown: 'rgb(188, 143, 143)',\n        royalblue: 'rgb( 65, 105, 225)',\n        saddlebrown: 'rgb(139, 69, 19)',\n        salmon: 'rgb(250, 128, 114)',\n        sandybrown: 'rgb(244, 164, 96)',\n        seagreen: 'rgb( 46, 139, 87)',\n        seashell: 'rgb(255, 245, 238)',\n        sienna: 'rgb(160, 82, 45)',\n        silver: 'rgb(192, 192, 192)',\n        skyblue: 'rgb(135, 206, 235)',\n        slateblue: 'rgb(106, 90, 205)',\n        slategray: 'rgb(112, 128, 144)',\n        slategrey: 'rgb(112, 128, 144)',\n        snow: 'rgb(255, 250, 250)',\n        springgreen: 'rgb( 0, 255, 127)',\n        steelblue: 'rgb( 70, 130, 180)',\n        tan: 'rgb(210, 180, 140)',\n        teal: 'rgb( 0, 128, 128)',\n        thistle: 'rgb(216, 191, 216)',\n        tomato: 'rgb(255, 99, 71)',\n        turquoise: 'rgb( 64, 224, 208)',\n        violet: 'rgb(238, 130, 238)',\n        wheat: 'rgb(245, 222, 179)',\n        white: 'rgb(255, 255, 255)',\n        whitesmoke: 'rgb(245, 245, 245)',\n        yellow: 'rgb(255, 255, 0)',\n        yellowgreen: 'rgb(154, 205, 50)'\n    };\n\n    \n\n\n    // class: $.jqplot.AxisLabelRenderer\n    // Renderer to place labels on the axes.\n    $.jqplot.AxisLabelRenderer = function(options) {\n        // Group: Properties\n        $.jqplot.ElemContainer.call(this);\n        // name of the axis associated with this tick\n        this.axis;\n        // prop: show\n        // whether or not to show the tick (mark and label).\n        this.show = true;\n        // prop: label\n        // The text or html for the label.\n        this.label = '';\n        this.fontFamily = null;\n        this.fontSize = null;\n        this.textColor = null;\n        this._elem;\n        // prop: escapeHTML\n        // true to escape HTML entities in the label.\n        this.escapeHTML = false;\n        \n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.AxisLabelRenderer.prototype = new $.jqplot.ElemContainer();\n    $.jqplot.AxisLabelRenderer.prototype.constructor = $.jqplot.AxisLabelRenderer;\n    \n    $.jqplot.AxisLabelRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.AxisLabelRenderer.prototype.draw = function(ctx, plot) {\n        // Memory Leaks patch\n        if (this._elem) {\n            this._elem.emptyForce();\n            this._elem = null;\n        }\n\n        this._elem = $('<div style=\"position:absolute;\" class=\"jqplot-'+this.axis+'-label\"></div>');\n        \n        if (Number(this.label)) {\n            this._elem.css('white-space', 'nowrap');\n        }\n        \n        if (!this.escapeHTML) {\n            this._elem.html(this.label);\n        }\n        else {\n            this._elem.text(this.label);\n        }\n        if (this.fontFamily) {\n            this._elem.css('font-family', this.fontFamily);\n        }\n        if (this.fontSize) {\n            this._elem.css('font-size', this.fontSize);\n        }\n        if (this.textColor) {\n            this._elem.css('color', this.textColor);\n        }\n        \n        return this._elem;\n    };\n    \n    $.jqplot.AxisLabelRenderer.prototype.pack = function() {\n    };\n\n    // class: $.jqplot.AxisTickRenderer\n    // A \"tick\" object showing the value of a tick/gridline on the plot.\n    $.jqplot.AxisTickRenderer = function(options) {\n        // Group: Properties\n        $.jqplot.ElemContainer.call(this);\n        // prop: mark\n        // tick mark on the axis.  One of 'inside', 'outside', 'cross', '' or null.\n        this.mark = 'outside';\n        // name of the axis associated with this tick\n        this.axis;\n        // prop: showMark\n        // whether or not to show the mark on the axis.\n        this.showMark = true;\n        // prop: showGridline\n        // whether or not to draw the gridline on the grid at this tick.\n        this.showGridline = true;\n        // prop: isMinorTick\n        // if this is a minor tick.\n        this.isMinorTick = false;\n        // prop: size\n        // Length of the tick beyond the grid in pixels.\n        // DEPRECATED: This has been superceeded by markSize\n        this.size = 4;\n        // prop:  markSize\n        // Length of the tick marks in pixels.  For 'cross' style, length\n        // will be stoked above and below axis, so total length will be twice this.\n        this.markSize = 6;\n        // prop: show\n        // whether or not to show the tick (mark and label).\n        // Setting this to false requires more testing.  It is recommended\n        // to set showLabel and showMark to false instead.\n        this.show = true;\n        // prop: showLabel\n        // whether or not to show the label.\n        this.showLabel = true;\n        this.label = null;\n        this.value = null;\n        this._styles = {};\n        // prop: formatter\n        // A class of a formatter for the tick text.  sprintf by default.\n        this.formatter = $.jqplot.DefaultTickFormatter;\n        // prop: prefix\n        // String to prepend to the tick label.\n        // Prefix is prepended to the formatted tick label.\n        this.prefix = '';\n        // prop: suffix\n        // String to append to the tick label.\n        // Suffix is appended to the formatted tick label.\n        this.suffix = '';\n        // prop: formatString\n        // string passed to the formatter.\n        this.formatString = '';\n        // prop: fontFamily\n        // css spec for the font-family css attribute.\n        this.fontFamily;\n        // prop: fontSize\n        // css spec for the font-size css attribute.\n        this.fontSize;\n        // prop: textColor\n        // css spec for the color attribute.\n        this.textColor;\n        // prop: escapeHTML\n        // true to escape HTML entities in the label.\n        this.escapeHTML = false;\n        this._elem;\n        this._breakTick = false;\n        \n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.AxisTickRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.AxisTickRenderer.prototype = new $.jqplot.ElemContainer();\n    $.jqplot.AxisTickRenderer.prototype.constructor = $.jqplot.AxisTickRenderer;\n    \n    $.jqplot.AxisTickRenderer.prototype.setTick = function(value, axisName, isMinor) {\n        this.value = value;\n        this.axis = axisName;\n        if (isMinor) {\n            this.isMinorTick = true;\n        }\n        return this;\n    };\n    \n    $.jqplot.AxisTickRenderer.prototype.draw = function() {\n        if (this.label === null) {\n            this.label = this.prefix + this.formatter(this.formatString, this.value) + this.suffix;\n        }\n        var style = {position: 'absolute'};\n        if (Number(this.label)) {\n            style['whitSpace'] = 'nowrap';\n        }\n        \n        // Memory Leaks patch\n        if (this._elem) {\n            this._elem.emptyForce();\n            this._elem = null;\n        }\n\n        this._elem = $(document.createElement('div'));\n        this._elem.addClass(\"jqplot-\"+this.axis+\"-tick\");\n        \n        if (!this.escapeHTML) {\n            this._elem.html(this.label);\n        }\n        else {\n            this._elem.text(this.label);\n        }\n        \n        this._elem.css(style);\n\n        for (var s in this._styles) {\n            this._elem.css(s, this._styles[s]);\n        }\n        if (this.fontFamily) {\n            this._elem.css('font-family', this.fontFamily);\n        }\n        if (this.fontSize) {\n            this._elem.css('font-size', this.fontSize);\n        }\n        if (this.textColor) {\n            this._elem.css('color', this.textColor);\n        }\n        if (this._breakTick) {\n          this._elem.addClass('jqplot-breakTick');\n        }\n        \n        return this._elem;\n    };\n        \n    $.jqplot.DefaultTickFormatter = function (format, val) {\n        if (typeof val == 'number') {\n            if (!format) {\n                format = $.jqplot.config.defaultTickFormatString;\n            }\n            return $.jqplot.sprintf(format, val);\n        }\n        else {\n            return String(val);\n        }\n    };\n        \n    $.jqplot.PercentTickFormatter = function (format, val) {\n        if (typeof val == 'number') {\n            val = 100 * val;\n            if (!format) {\n                format = $.jqplot.config.defaultTickFormatString;\n            }\n            return $.jqplot.sprintf(format, val);\n        }\n        else {\n            return String(val);\n        }\n    };\n    \n    $.jqplot.AxisTickRenderer.prototype.pack = function() {\n    };\n     \n    // Class: $.jqplot.CanvasGridRenderer\n    // The default jqPlot grid renderer, creating a grid on a canvas element.\n    // The renderer has no additional options beyond the <Grid> class.\n    $.jqplot.CanvasGridRenderer = function(){\n        this.shadowRenderer = new $.jqplot.ShadowRenderer();\n    };\n    \n    // called with context of Grid object\n    $.jqplot.CanvasGridRenderer.prototype.init = function(options) {\n        this._ctx;\n        $.extend(true, this, options);\n        // set the shadow renderer options\n        var sopts = {lineJoin:'miter', lineCap:'round', fill:false, isarc:false, angle:this.shadowAngle, offset:this.shadowOffset, alpha:this.shadowAlpha, depth:this.shadowDepth, lineWidth:this.shadowWidth, closePath:false, strokeStyle:this.shadowColor};\n        this.renderer.shadowRenderer.init(sopts);\n    };\n    \n    // called with context of Grid.\n    $.jqplot.CanvasGridRenderer.prototype.createElement = function(plot) {\n        var elem;\n        // Memory Leaks patch\n        if (this._elem) {\n          if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {\n            elem = this._elem.get(0);\n            window.G_vmlCanvasManager.uninitElement(elem);\n            elem = null;\n          }\n          \n          this._elem.emptyForce();\n          this._elem = null;\n        }\n      \n        elem = plot.canvasManager.getCanvas();\n\n        var w = this._plotDimensions.width;\n        var h = this._plotDimensions.height;\n        elem.width = w;\n        elem.height = h;\n        this._elem = $(elem);\n        this._elem.addClass('jqplot-grid-canvas');\n        this._elem.css({ position: 'absolute', left: 0, top: 0 });\n        \n        elem = plot.canvasManager.initCanvas(elem);\n\n        this._top = this._offsets.top;\n        this._bottom = h - this._offsets.bottom;\n        this._left = this._offsets.left;\n        this._right = w - this._offsets.right;\n        this._width = this._right - this._left;\n        this._height = this._bottom - this._top;\n        // avoid memory leak\n        elem = null;\n        return this._elem;\n    };\n    \n    $.jqplot.CanvasGridRenderer.prototype.draw = function() {\n        this._ctx = this._elem.get(0).getContext(\"2d\");\n        var ctx = this._ctx;\n        var axes = this._axes;\n        // Add the grid onto the grid canvas.  This is the bottom most layer.\n        ctx.save();\n        ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height);\n        ctx.fillStyle = this.backgroundColor || this.background;\n        ctx.fillRect(this._left, this._top, this._width, this._height);\n        \n        ctx.save();\n        ctx.lineJoin = 'miter';\n        ctx.lineCap = 'butt';\n        ctx.lineWidth = this.gridLineWidth;\n        ctx.strokeStyle = this.gridLineColor;\n        var b, e, s, m;\n        var ax = ['xaxis', 'yaxis', 'x2axis', 'y2axis'];\n        for (var i=4; i>0; i--) {\n            var name = ax[i-1];\n            var axis = axes[name];\n            var ticks = axis._ticks;\n            var numticks = ticks.length;\n            if (axis.show) {\n                if (axis.drawBaseline) {\n                    var bopts = {};\n                    if (axis.baselineWidth !== null) {\n                        bopts.lineWidth = axis.baselineWidth;\n                    }\n                    if (axis.baselineColor !== null) {\n                        bopts.strokeStyle = axis.baselineColor;\n                    }\n                    switch (name) {\n                        case 'xaxis':\n                            drawLine (this._left, this._bottom, this._right, this._bottom, bopts);\n                            break;\n                        case 'yaxis':\n                            drawLine (this._left, this._bottom, this._left, this._top, bopts);\n                            break;\n                        case 'x2axis':\n                            drawLine (this._left, this._bottom, this._right, this._bottom, bopts);\n                            break;\n                        case 'y2axis':\n                            drawLine (this._right, this._bottom, this._right, this._top, bopts);\n                            break;\n                    }\n                }\n                for (var j=numticks; j>0; j--) {\n                    var t = ticks[j-1];\n                    if (t.show) {\n                        var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                        switch (name) {\n                            case 'xaxis':\n                                // draw the grid line if we should\n                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {\n                                    drawLine(pos, this._top, pos, this._bottom);\n                                }\n                                // draw the mark\n                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {\n                                    s = t.markSize;\n                                    m = t.mark;\n                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                                    switch (m) {\n                                        case 'outside':\n                                            b = this._bottom;\n                                            e = this._bottom+s;\n                                            break;\n                                        case 'inside':\n                                            b = this._bottom-s;\n                                            e = this._bottom;\n                                            break;\n                                        case 'cross':\n                                            b = this._bottom-s;\n                                            e = this._bottom+s;\n                                            break;\n                                        default:\n                                            b = this._bottom;\n                                            e = this._bottom+s;\n                                            break;\n                                    }\n                                    // draw the shadow\n                                    if (this.shadow) {\n                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});\n                                    }\n                                    // draw the line\n                                    drawLine(pos, b, pos, e);\n                                }\n                                break;\n                            case 'yaxis':\n                                // draw the grid line\n                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {\n                                    drawLine(this._right, pos, this._left, pos);\n                                }\n                                // draw the mark\n                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {\n                                    s = t.markSize;\n                                    m = t.mark;\n                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                                    switch (m) {\n                                        case 'outside':\n                                            b = this._left-s;\n                                            e = this._left;\n                                            break;\n                                        case 'inside':\n                                            b = this._left;\n                                            e = this._left+s;\n                                            break;\n                                        case 'cross':\n                                            b = this._left-s;\n                                            e = this._left+s;\n                                            break;\n                                        default:\n                                            b = this._left-s;\n                                            e = this._left;\n                                            break;\n                                            }\n                                    // draw the shadow\n                                    if (this.shadow) {\n                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});\n                                    }\n                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});\n                                }\n                                break;\n                            case 'x2axis':\n                                // draw the grid line\n                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {\n                                    drawLine(pos, this._bottom, pos, this._top);\n                                }\n                                // draw the mark\n                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {\n                                    s = t.markSize;\n                                    m = t.mark;\n                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                                    switch (m) {\n                                        case 'outside':\n                                            b = this._top-s;\n                                            e = this._top;\n                                            break;\n                                        case 'inside':\n                                            b = this._top;\n                                            e = this._top+s;\n                                            break;\n                                        case 'cross':\n                                            b = this._top-s;\n                                            e = this._top+s;\n                                            break;\n                                        default:\n                                            b = this._top-s;\n                                            e = this._top;\n                                            break;\n                                            }\n                                    // draw the shadow\n                                    if (this.shadow) {\n                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});\n                                    }\n                                    drawLine(pos, b, pos, e);\n                                }\n                                break;\n                            case 'y2axis':\n                                // draw the grid line\n                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {\n                                    drawLine(this._left, pos, this._right, pos);\n                                }\n                                // draw the mark\n                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {\n                                    s = t.markSize;\n                                    m = t.mark;\n                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                                    switch (m) {\n                                        case 'outside':\n                                            b = this._right;\n                                            e = this._right+s;\n                                            break;\n                                        case 'inside':\n                                            b = this._right-s;\n                                            e = this._right;\n                                            break;\n                                        case 'cross':\n                                            b = this._right-s;\n                                            e = this._right+s;\n                                            break;\n                                        default:\n                                            b = this._right;\n                                            e = this._right+s;\n                                            break;\n                                            }\n                                    // draw the shadow\n                                    if (this.shadow) {\n                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});\n                                    }\n                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});\n                                }\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                }\n                t = null;\n            }\n            axis = null;\n            ticks = null;\n        }\n        // Now draw grid lines for additional y axes\n        //////\n        // TO DO: handle yMidAxis\n        //////\n        ax = ['y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];\n        for (var i=7; i>0; i--) {\n            var axis = axes[ax[i-1]];\n            var ticks = axis._ticks;\n            if (axis.show) {\n                var tn = ticks[axis.numberTicks-1];\n                var t0 = ticks[0];\n                var left = axis.getLeft();\n                var points = [[left, tn.getTop() + tn.getHeight()/2], [left, t0.getTop() + t0.getHeight()/2 + 1.0]];\n                // draw the shadow\n                if (this.shadow) {\n                    this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', fill:false, closePath:false});\n                }\n                // draw the line\n                drawLine(points[0][0], points[0][1], points[1][0], points[1][1], {lineCap:'butt', strokeStyle:axis.borderColor, lineWidth:axis.borderWidth});\n                // draw the tick marks\n                for (var j=ticks.length; j>0; j--) {\n                    var t = ticks[j-1];\n                    s = t.markSize;\n                    m = t.mark;\n                    var pos = Math.round(axis.u2p(t.value)) + 0.5;\n                    if (t.showMark && t.mark) {\n                        switch (m) {\n                            case 'outside':\n                                b = left;\n                                e = left+s;\n                                break;\n                            case 'inside':\n                                b = left-s;\n                                e = left;\n                                break;\n                            case 'cross':\n                                b = left-s;\n                                e = left+s;\n                                break;\n                            default:\n                                b = left;\n                                e = left+s;\n                                break;\n                        }\n                        points = [[b,pos], [e,pos]];\n                        // draw the shadow\n                        if (this.shadow) {\n                            this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});\n                        }\n                        // draw the line\n                        drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});\n                    }\n                    t = null;\n                }\n                t0 = null;\n            }\n            axis = null;\n            ticks =  null;\n        }\n        \n        ctx.restore();\n        \n        function drawLine(bx, by, ex, ey, opts) {\n            ctx.save();\n            opts = opts || {};\n            if (opts.lineWidth == null || opts.lineWidth != 0){\n                $.extend(true, ctx, opts);\n                ctx.beginPath();\n                ctx.moveTo(bx, by);\n                ctx.lineTo(ex, ey);\n                ctx.stroke();\n                ctx.restore();\n            }\n        }\n        \n        if (this.shadow) {\n            var points = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]];\n            this.renderer.shadowRenderer.draw(ctx, points);\n        }\n        // Now draw border around grid.  Use axis border definitions. start at\n        // upper left and go clockwise.\n        if (this.borderWidth != 0 && this.drawBorder) {\n            drawLine (this._left, this._top, this._right, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});\n            drawLine (this._right, this._top, this._right, this._bottom, {lineCap:'round', strokeStyle:axes.y2axis.borderColor, lineWidth:axes.y2axis.borderWidth});\n            drawLine (this._right, this._bottom, this._left, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});\n            drawLine (this._left, this._bottom, this._left, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});\n        }\n        // ctx.lineWidth = this.borderWidth;\n        // ctx.strokeStyle = this.borderColor;\n        // ctx.strokeRect(this._left, this._top, this._width, this._height);\n        \n        ctx.restore();\n        ctx =  null;\n        axes = null;\n    };\n \n    // Class: $.jqplot.DivTitleRenderer\n    // The default title renderer for jqPlot.  This class has no options beyond the <Title> class. \n    $.jqplot.DivTitleRenderer = function() {\n    };\n    \n    $.jqplot.DivTitleRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.DivTitleRenderer.prototype.draw = function() {\n        // Memory Leaks patch\n        if (this._elem) {\n            this._elem.emptyForce();\n            this._elem = null;\n        }\n\n        var r = this.renderer;\n        var elem = document.createElement('div');\n        this._elem = $(elem);\n        this._elem.addClass('jqplot-title');\n\n        if (!this.text) {\n            this.show = false;\n            this._elem.height(0);\n            this._elem.width(0);\n        }\n        else if (this.text) {\n            var color;\n            if (this.color) {\n                color = this.color;\n            }\n            else if (this.textColor) {\n                color = this.textColor;\n            }\n\n            // don't trust that a stylesheet is present, set the position.\n            var styles = {position:'absolute', top:'0px', left:'0px'};\n\n            if (this._plotWidth) {\n                styles['width'] = this._plotWidth+'px';\n            }\n            if (this.fontSize) {\n                styles['fontSize'] = this.fontSize;\n            }\n            if (typeof this.textAlign === 'string') {\n                styles['textAlign'] = this.textAlign;\n            }\n            else {\n                styles['textAlign'] = 'center';\n            }\n            if (color) {\n                styles['color'] = color;\n            }\n            if (this.paddingBottom) {\n                styles['paddingBottom'] = this.paddingBottom;\n            }\n            if (this.fontFamily) {\n                styles['fontFamily'] = this.fontFamily;\n            }\n\n            this._elem.css(styles);\n            if (this.escapeHtml) {\n                this._elem.text(this.text);\n            }\n            else {\n                this._elem.html(this.text);\n            }\n\n\n            // styletext += (this._plotWidth) ? 'width:'+this._plotWidth+'px;' : '';\n            // styletext += (this.fontSize) ? 'font-size:'+this.fontSize+';' : '';\n            // styletext += (this.textAlign) ? 'text-align:'+this.textAlign+';' : 'text-align:center;';\n            // styletext += (color) ? 'color:'+color+';' : '';\n            // styletext += (this.paddingBottom) ? 'padding-bottom:'+this.paddingBottom+';' : '';\n            // this._elem = $('<div class=\"jqplot-title\" style=\"'+styletext+'\">'+this.text+'</div>');\n            // if (this.fontFamily) {\n            //     this._elem.css('font-family', this.fontFamily);\n            // }\n        }\n\n        elem = null;\n        \n        return this._elem;\n    };\n    \n    $.jqplot.DivTitleRenderer.prototype.pack = function() {\n        // nothing to do here\n    };\n  \n\n    var dotlen = 0.1;\n\n    $.jqplot.LinePattern = function (ctx, pattern) {\n\n        var defaultLinePatterns = {\n            dotted: [ dotlen, $.jqplot.config.dotGapLength ],\n            dashed: [ $.jqplot.config.dashLength, $.jqplot.config.gapLength ],\n            solid: null\n        };\n\n        if (typeof pattern === 'string') {\n            if (pattern[0] === '.' || pattern[0] === '-') {\n                var s = pattern;\n                pattern = [];\n                for (var i=0, imax=s.length; i<imax; i++) {\n                    if (s[i] === '.') {\n                        pattern.push( dotlen );\n                    }\n                    else if (s[i] === '-') {\n                        pattern.push( $.jqplot.config.dashLength );\n                    }\n                    else {\n                        continue;\n                    }\n                    pattern.push( $.jqplot.config.gapLength );\n                }\n            }\n            else {\n                pattern = defaultLinePatterns[pattern];\n            }\n        }\n\n        if (!(pattern && pattern.length)) {\n            return ctx;\n        }\n\n        var patternIndex = 0;\n        var patternDistance = pattern[0];\n        var px = 0;\n        var py = 0;\n        var pathx0 = 0;\n        var pathy0 = 0;\n\n        var moveTo = function (x, y) {\n            ctx.moveTo( x, y );\n            px = x;\n            py = y;\n            pathx0 = x;\n            pathy0 = y;\n        };\n\n        var lineTo = function (x, y) {\n            var scale = ctx.lineWidth;\n            var dx = x - px;\n            var dy = y - py;\n            var dist = Math.sqrt(dx*dx+dy*dy);\n            if ((dist > 0) && (scale > 0)) {\n                dx /= dist;\n                dy /= dist;\n                while (true) {\n                    var dp = scale * patternDistance;\n                    if (dp < dist) {\n                        px += dp * dx;\n                        py += dp * dy;\n                        if ((patternIndex & 1) == 0) {\n                            ctx.lineTo( px, py );\n                        }\n                        else {\n                            ctx.moveTo( px, py );\n                        }\n                        dist -= dp;\n                        patternIndex++;\n                        if (patternIndex >= pattern.length) {\n                            patternIndex = 0;\n                        }\n                        patternDistance = pattern[patternIndex];\n                    }\n                    else {\n                        px = x;\n                        py = y;\n                        if ((patternIndex & 1) == 0) {\n                            ctx.lineTo( px, py );\n                        }\n                        else {\n                            ctx.moveTo( px, py );\n                        }\n                        patternDistance -= dist / scale;\n                        break;\n                    }\n                }\n            }\n        };\n\n        var beginPath = function () {\n            ctx.beginPath();\n        };\n\n        var closePath = function () {\n            lineTo( pathx0, pathy0 );\n        };\n\n        return {\n            moveTo: moveTo,\n            lineTo: lineTo,\n            beginPath: beginPath,\n            closePath: closePath\n        };\n    };\n\n    // Class: $.jqplot.LineRenderer\n    // The default line renderer for jqPlot, this class has no options beyond the <Series> class.\n    // Draws series as a line.\n    $.jqplot.LineRenderer = function(){\n        this.shapeRenderer = new $.jqplot.ShapeRenderer();\n        this.shadowRenderer = new $.jqplot.ShadowRenderer();\n    };\n    \n    // called with scope of series.\n    $.jqplot.LineRenderer.prototype.init = function(options, plot) {\n        // Group: Properties\n        //\n        options = options || {};\n        this._type='line';\n        this.renderer.animation = {\n            show: false,\n            direction: 'left',\n            speed: 2500,\n            _supported: true\n        };\n        // prop: smooth\n        // True to draw a smoothed (interpolated) line through the data points\n        // with automatically computed number of smoothing points.\n        // Set to an integer number > 2 to specify number of smoothing points\n        // to use between each data point.\n        this.renderer.smooth = false;  // true or a number > 2 for smoothing.\n        this.renderer.tension = null; // null to auto compute or a number typically > 6.  Fewer points requires higher tension.\n        // prop: constrainSmoothing\n        // True to use a more accurate smoothing algorithm that will\n        // not overshoot any data points.  False to allow overshoot but\n        // produce a smoother looking line.\n        this.renderer.constrainSmoothing = true;\n        // this is smoothed data in grid coordinates, like gridData\n        this.renderer._smoothedData = [];\n        // this is smoothed data in plot units (plot coordinates), like plotData.\n        this.renderer._smoothedPlotData = [];\n        this.renderer._hiBandGridData = [];\n        this.renderer._lowBandGridData = [];\n        this.renderer._hiBandSmoothedData = [];\n        this.renderer._lowBandSmoothedData = [];\n\n        // prop: bandData\n        // Data used to draw error bands or confidence intervals above/below a line.\n        //\n        // bandData can be input in 3 forms.  jqPlot will figure out which is the\n        // low band line and which is the high band line for all forms:\n        // \n        // A 2 dimensional array like [[yl1, yl2, ...], [yu1, yu2, ...]] where\n        // [yl1, yl2, ...] are y values of the lower line and\n        // [yu1, yu2, ...] are y values of the upper line.\n        // In this case there must be the same number of y data points as data points\n        // in the series and the bands will inherit the x values of the series.\n        //\n        // A 2 dimensional array like [[[xl1, yl1], [xl2, yl2], ...], [[xh1, yh1], [xh2, yh2], ...]]\n        // where [xl1, yl1] are x,y data points for the lower line and\n        // [xh1, yh1] are x,y data points for the high line.\n        // x values do not have to correspond to the x values of the series and can\n        // be of any arbitrary length.\n        //\n        // Can be of form [[yl1, yu1], [yl2, yu2], [yl3, yu3], ...] where\n        // there must be 3 or more arrays and there must be the same number of arrays\n        // as there are data points in the series.  In this case, \n        // [yl1, yu1] specifies the lower and upper y values for the 1st\n        // data point and so on.  The bands will inherit the x\n        // values from the series.\n        this.renderer.bandData = [];\n\n        // Group: bands\n        // Banding around line, e.g error bands or confidence intervals.\n        this.renderer.bands = {\n            // prop: show\n            // true to show the bands.  If bandData or interval is\n            // supplied, show will be set to true by default.\n            show: false,\n            hiData: [],\n            lowData: [],\n            // prop: color\n            // color of lines at top and bottom of bands [default: series color].\n            color: this.color,\n            // prop: showLines\n            // True to show lines at top and bottom of bands [default: false].\n            showLines: false,\n            // prop: fill\n            // True to fill area between bands [default: true].\n            fill: true,\n            // prop: fillColor\n            // css color spec for filled area.  [default: series color].\n            fillColor: null,\n            _min: null,\n            _max: null,\n            // prop: interval\n            // User specified interval above and below line for bands [default: '3%''].\n            // Can be a value like 3 or a string like '3%' \n            // or an upper/lower array like [1, -2] or ['2%', '-1.5%']\n            interval: '3%'\n        };\n\n\n        var lopts = {highlightMouseOver: options.highlightMouseOver, highlightMouseDown: options.highlightMouseDown, highlightColor: options.highlightColor};\n        \n        delete (options.highlightMouseOver);\n        delete (options.highlightMouseDown);\n        delete (options.highlightColor);\n        \n        $.extend(true, this.renderer, options);\n\n        this.renderer.options = options;\n\n        // if we are given some band data, and bands aren't explicity set to false in options, turn them on.\n        if (this.renderer.bandData.length > 1 && (!options.bands || options.bands.show == null)) {\n            this.renderer.bands.show = true;\n        }\n\n        // if we are given an interval, and bands aren't explicity set to false in options, turn them on.\n        else if (options.bands && options.bands.show == null && options.bands.interval != null) {\n            this.renderer.bands.show = true;\n        }\n\n        // if plot is filled, turn off bands.\n        if (this.fill) {\n            this.renderer.bands.show = false;\n        }\n\n        if (this.renderer.bands.show) {\n            this.renderer.initBands.call(this, this.renderer.options, plot);\n        }\n\n\n        // smoothing is not compatible with stacked lines, disable\n        if (this._stack) {\n            this.renderer.smooth = false;\n        }\n\n        // set the shape renderer options\n        var opts = {lineJoin:this.lineJoin, lineCap:this.lineCap, fill:this.fill, isarc:false, strokeStyle:this.color, fillStyle:this.fillColor, lineWidth:this.lineWidth, linePattern:this.linePattern, closePath:this.fill};\n        this.renderer.shapeRenderer.init(opts);\n\n        var shadow_offset = options.shadowOffset;\n        // set the shadow renderer options\n        if (shadow_offset == null) {\n            // scale the shadowOffset to the width of the line.\n            if (this.lineWidth > 2.5) {\n                shadow_offset = 1.25 * (1 + (Math.atan((this.lineWidth/2.5))/0.785398163 - 1)*0.6);\n                // var shadow_offset = this.shadowOffset;\n            }\n            // for skinny lines, don't make such a big shadow.\n            else {\n                shadow_offset = 1.25 * Math.atan((this.lineWidth/2.5))/0.785398163;\n            }\n        }\n        \n        var sopts = {lineJoin:this.lineJoin, lineCap:this.lineCap, fill:this.fill, isarc:false, angle:this.shadowAngle, offset:shadow_offset, alpha:this.shadowAlpha, depth:this.shadowDepth, lineWidth:this.lineWidth, linePattern:this.linePattern, closePath:this.fill};\n        this.renderer.shadowRenderer.init(sopts);\n        this._areaPoints = [];\n        this._boundingBox = [[],[]];\n        \n        if (!this.isTrendline && this.fill || this.renderer.bands.show) {\n            // Group: Properties\n            //        \n            // prop: highlightMouseOver\n            // True to highlight area on a filled plot when moused over.\n            // This must be false to enable highlightMouseDown to highlight when clicking on an area on a filled plot.\n            this.highlightMouseOver = true;\n            // prop: highlightMouseDown\n            // True to highlight when a mouse button is pressed over an area on a filled plot.\n            // This will be disabled if highlightMouseOver is true.\n            this.highlightMouseDown = false;\n            // prop: highlightColor\n            // color to use when highlighting an area on a filled plot.\n            this.highlightColor = null;\n            // if user has passed in highlightMouseDown option and not set highlightMouseOver, disable highlightMouseOver\n            if (lopts.highlightMouseDown && lopts.highlightMouseOver == null) {\n                lopts.highlightMouseOver = false;\n            }\n        \n            $.extend(true, this, {highlightMouseOver: lopts.highlightMouseOver, highlightMouseDown: lopts.highlightMouseDown, highlightColor: lopts.highlightColor});\n            \n            if (!this.highlightColor) {\n                var fc = (this.renderer.bands.show) ? this.renderer.bands.fillColor : this.fillColor;\n                this.highlightColor = $.jqplot.computeHighlightColors(fc);\n            }\n            // turn off (disable) the highlighter plugin\n            if (this.highlighter) {\n                this.highlighter.show = false;\n            }\n        }\n        \n        if (!this.isTrendline && plot) {\n            plot.plugins.lineRenderer = {};\n            plot.postInitHooks.addOnce(postInit);\n            plot.postDrawHooks.addOnce(postPlotDraw);\n            plot.eventListenerHooks.addOnce('jqplotMouseMove', handleMove);\n            plot.eventListenerHooks.addOnce('jqplotMouseDown', handleMouseDown);\n            plot.eventListenerHooks.addOnce('jqplotMouseUp', handleMouseUp);\n            plot.eventListenerHooks.addOnce('jqplotClick', handleClick);\n            plot.eventListenerHooks.addOnce('jqplotRightClick', handleRightClick);\n        }\n\n    };\n\n    $.jqplot.LineRenderer.prototype.initBands = function(options, plot) {\n        // use bandData if no data specified in bands option\n        //var bd = this.renderer.bandData;\n        var bd = options.bandData || [];\n        var bands = this.renderer.bands;\n        bands.hiData = [];\n        bands.lowData = [];\n        var data = this.data;\n        bands._max = null;\n        bands._min = null;\n        // If 2 arrays, and each array greater than 2 elements, assume it is hi and low data bands of y values.\n        if (bd.length == 2) {\n            // Do we have an array of x,y values?\n            // like [[[1,1], [2,4], [3,3]], [[1,3], [2,6], [3,5]]]\n            if ($.isArray(bd[0][0])) {\n                // since an arbitrary array of points, spin through all of them to determine max and min lines.\n\n                var p;\n                var bdminidx = 0, bdmaxidx = 0;\n                for (var i = 0, l = bd[0].length; i<l; i++) {\n                    p = bd[0][i];\n                    if ((p[1] != null && p[1] > bands._max) || bands._max == null) {\n                        bands._max = p[1];\n                    }\n                    if ((p[1] != null && p[1] < bands._min) || bands._min == null) {\n                        bands._min = p[1];\n                    }\n                }\n                for (var i = 0, l = bd[1].length; i<l; i++) {\n                    p = bd[1][i];\n                    if ((p[1] != null && p[1] > bands._max) || bands._max == null) {\n                        bands._max = p[1];\n                        bdmaxidx = 1;\n                    }\n                    if ((p[1] != null && p[1] < bands._min) || bands._min == null) {\n                        bands._min = p[1];\n                        bdminidx = 1;\n                    }\n                }\n\n                if (bdmaxidx === bdminidx) {\n                    bands.show = false;\n                }\n\n                bands.hiData = bd[bdmaxidx];\n                bands.lowData = bd[bdminidx];\n            }\n            // else data is arrays of y values\n            // like [[1,4,3], [3,6,5]]\n            // must have same number of band data points as points in series\n            else if (bd[0].length === data.length && bd[1].length === data.length) {\n                var hi = (bd[0][0] > bd[1][0]) ? 0 : 1;\n                var low = (hi) ? 0 : 1;\n                for (var i=0, l=data.length; i < l; i++) {\n                    bands.hiData.push([data[i][0], bd[hi][i]]);\n                    bands.lowData.push([data[i][0], bd[low][i]]);\n                }\n            }\n\n            // we don't have proper data array, don't show bands.\n            else {\n                bands.show = false;\n            }\n        }\n\n        // if more than 2 arrays, have arrays of [ylow, yhi] values.\n        // note, can't distinguish case of [[ylow, yhi], [ylow, yhi]] from [[ylow, ylow], [yhi, yhi]]\n        // this is assumed to be of the latter form.\n        else if (bd.length > 2 && !$.isArray(bd[0][0])) {\n            var hi = (bd[0][0] > bd[0][1]) ? 0 : 1;\n            var low = (hi) ? 0 : 1;\n            for (var i=0, l=bd.length; i<l; i++) {\n                bands.hiData.push([data[i][0], bd[i][hi]]);\n                bands.lowData.push([data[i][0], bd[i][low]]);\n            }\n        }\n\n        // don't have proper data, auto calculate\n        else {\n            var intrv = bands.interval;\n            var a = null;\n            var b = null;\n            var afunc = null;\n            var bfunc = null;\n\n            if ($.isArray(intrv)) {\n                a = intrv[0];\n                b = intrv[1];\n            }\n            else {\n                a = intrv;\n            }\n\n            if (isNaN(a)) {\n                // we have a string\n                if (a.charAt(a.length - 1) === '%') {\n                    afunc = 'multiply';\n                    a = parseFloat(a)/100 + 1;\n                }\n            }\n\n            else {\n                a = parseFloat(a);\n                afunc = 'add';\n            }\n\n            if (b !== null && isNaN(b)) {\n                // we have a string\n                if (b.charAt(b.length - 1) === '%') {\n                    bfunc = 'multiply';\n                    b = parseFloat(b)/100 + 1;\n                }\n            }\n\n            else if (b !== null) {\n                b = parseFloat(b);\n                bfunc = 'add';\n            }\n\n            if (a !== null) {\n                if (b === null) {\n                    b = -a;\n                    bfunc = afunc;\n                    if (bfunc === 'multiply') {\n                        b += 2;\n                    }\n                }\n\n                // make sure a always applies to hi band.\n                if (a < b) {\n                    var temp = a;\n                    a = b;\n                    b = temp;\n                    temp = afunc;\n                    afunc = bfunc;\n                    bfunc = temp;\n                }\n\n                for (var i=0, l = data.length; i < l; i++) {\n                    switch (afunc) {\n                        case 'add':\n                            bands.hiData.push([data[i][0], data[i][1] + a]);\n                            break;\n                        case 'multiply':\n                            bands.hiData.push([data[i][0], data[i][1] * a]);\n                            break;\n                    }\n                    switch (bfunc) {\n                        case 'add':\n                            bands.lowData.push([data[i][0], data[i][1] + b]);\n                            break;\n                        case 'multiply':\n                            bands.lowData.push([data[i][0], data[i][1] * b]);\n                            break;\n                    }\n                }\n            }\n\n            else {\n                bands.show = false;\n            }\n        }\n\n        var hd = bands.hiData;\n        var ld = bands.lowData;\n        for (var i = 0, l = hd.length; i<l; i++) {\n            if ((hd[i][1] != null && hd[i][1] > bands._max) || bands._max == null) {\n                bands._max = hd[i][1];\n            }\n        }\n        for (var i = 0, l = ld.length; i<l; i++) {\n            if ((ld[i][1] != null && ld[i][1] < bands._min) || bands._min == null) {\n                bands._min = ld[i][1];\n            }\n        }\n\n        // one last check for proper data\n        // these don't apply any more since allowing arbitrary x,y values\n        // if (bands.hiData.length != bands.lowData.length) {\n        //     bands.show = false;\n        // }\n\n        // if (bands.hiData.length != this.data.length) {\n        //     bands.show = false;\n        // }\n\n        if (bands.fillColor === null) {\n            var c = $.jqplot.getColorComponents(bands.color);\n            // now adjust alpha to differentiate fill\n            c[3] = c[3] * 0.5;\n            bands.fillColor = 'rgba(' + c[0] +', '+ c[1] +', '+ c[2] +', '+ c[3] + ')';\n        }\n    };\n\n    function getSteps (d, f) {\n        return (3.4182054+f) * Math.pow(d, -0.3534992);\n    }\n\n    function computeSteps (d1, d2) {\n        var s = Math.sqrt(Math.pow((d2[0]- d1[0]), 2) + Math.pow ((d2[1] - d1[1]), 2));\n        return 5.7648 * Math.log(s) + 7.4456;\n    }\n\n    function tanh (x) {\n        var a = (Math.exp(2*x) - 1) / (Math.exp(2*x) + 1);\n        return a;\n    }\n\n    //////////\n    // computeConstrainedSmoothedData\n    // An implementation of the constrained cubic spline interpolation\n    // method as presented in:\n    //\n    // Kruger, CJC, Constrained Cubic Spine Interpolation for Chemical Engineering Applications\n    // http://www.korf.co.uk/spline.pdf\n    //\n    // The implementation below borrows heavily from the sample Visual Basic\n    // implementation by CJC Kruger found in http://www.korf.co.uk/spline.xls\n    //\n    /////////\n\n    // called with scope of series\n    function computeConstrainedSmoothedData (gd) {\n        var smooth = this.renderer.smooth;\n        var dim = this.canvas.getWidth();\n        var xp = this._xaxis.series_p2u;\n        var yp = this._yaxis.series_p2u; \n        var steps =null;\n        var _steps = null;\n        var dist = gd.length/dim;\n        var _smoothedData = [];\n        var _smoothedPlotData = [];\n\n        if (!isNaN(parseFloat(smooth))) {\n            steps = parseFloat(smooth);\n        }\n        else {\n            steps = getSteps(dist, 0.5);\n        }\n\n        var yy = [];\n        var xx = [];\n\n        for (var i=0, l = gd.length; i<l; i++) {\n            yy.push(gd[i][1]);\n            xx.push(gd[i][0]);\n        }\n\n        function dxx(x1, x0) {\n            if (x1 - x0 == 0) {\n                return Math.pow(10,10);\n            }\n            else {\n                return x1 - x0;\n            }\n        }\n\n        var A, B, C, D;\n        // loop through each line segment.  Have # points - 1 line segments.  Nmber segments starting at 1.\n        var nmax = gd.length - 1;\n        for (var num = 1, gdl = gd.length; num<gdl; num++) {\n            var gxx = [];\n            var ggxx = [];\n            // point at each end of segment.\n            for (var j = 0; j < 2; j++) {\n                var i = num - 1 + j; // point number, 0 to # points.\n\n                if (i == 0 || i == nmax) {\n                    gxx[j] = Math.pow(10, 10);\n                }\n                else if (yy[i+1] - yy[i] == 0 || yy[i] - yy[i-1] == 0) {\n                    gxx[j] = 0;\n                }\n                else if (((xx[i+1] - xx[i]) / (yy[i+1] - yy[i]) + (xx[i] - xx[i-1]) / (yy[i] - yy[i-1])) == 0 ) {\n                    gxx[j] = 0;\n                }\n                else if ( (yy[i+1] - yy[i]) * (yy[i] - yy[i-1]) < 0 ) {\n                    gxx[j] = 0;\n                }\n\n                else {\n                    gxx[j] = 2 / (dxx(xx[i + 1], xx[i]) / (yy[i + 1] - yy[i]) + dxx(xx[i], xx[i - 1]) / (yy[i] - yy[i - 1]));\n                }\n            }\n\n            // Reset first derivative (slope) at first and last point\n            if (num == 1) {\n                // First point has 0 2nd derivative\n                gxx[0] = 3 / 2 * (yy[1] - yy[0]) / dxx(xx[1], xx[0]) - gxx[1] / 2;\n            }\n            else if (num == nmax) {\n                // Last point has 0 2nd derivative\n                gxx[1] = 3 / 2 * (yy[nmax] - yy[nmax - 1]) / dxx(xx[nmax], xx[nmax - 1]) - gxx[0] / 2;\n            }   \n\n            // Calc second derivative at points\n            ggxx[0] = -2 * (gxx[1] + 2 * gxx[0]) / dxx(xx[num], xx[num - 1]) + 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);\n            ggxx[1] = 2 * (2 * gxx[1] + gxx[0]) / dxx(xx[num], xx[num - 1]) - 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);\n\n            // Calc constants for cubic interpolation\n            D = 1 / 6 * (ggxx[1] - ggxx[0]) / dxx(xx[num], xx[num - 1]);\n            C = 1 / 2 * (xx[num] * ggxx[0] - xx[num - 1] * ggxx[1]) / dxx(xx[num], xx[num - 1]);\n            B = (yy[num] - yy[num - 1] - C * (Math.pow(xx[num], 2) - Math.pow(xx[num - 1], 2)) - D * (Math.pow(xx[num], 3) - Math.pow(xx[num - 1], 3))) / dxx(xx[num], xx[num - 1]);\n            A = yy[num - 1] - B * xx[num - 1] - C * Math.pow(xx[num - 1], 2) - D * Math.pow(xx[num - 1], 3);\n\n            var increment = (xx[num] - xx[num - 1]) / steps;\n            var temp, tempx;\n\n            for (var j = 0, l = steps; j < l; j++) {\n                temp = [];\n                tempx = xx[num - 1] + j * increment;\n                temp.push(tempx);\n                temp.push(A + B * tempx + C * Math.pow(tempx, 2) + D * Math.pow(tempx, 3));\n                _smoothedData.push(temp);\n                _smoothedPlotData.push([xp(temp[0]), yp(temp[1])]);\n            }\n        }\n\n        _smoothedData.push(gd[i]);\n        _smoothedPlotData.push([xp(gd[i][0]), yp(gd[i][1])]);\n\n        return [_smoothedData, _smoothedPlotData];\n    }\n\n    ///////\n    // computeHermiteSmoothedData\n    // A hermite spline smoothing of the plot data.\n    // This implementation is derived from the one posted\n    // by krypin on the jqplot-users mailing list:\n    //\n    // http://groups.google.com/group/jqplot-users/browse_thread/thread/748be6a445723cea?pli=1\n    //\n    // with a blog post:\n    //\n    // http://blog.statscollector.com/a-plugin-renderer-for-jqplot-to-draw-a-hermite-spline/\n    //\n    // and download of the original plugin:\n    //\n    // http://blog.statscollector.com/wp-content/uploads/2010/02/jqplot.hermiteSplineRenderer.js\n    //////////\n\n    // called with scope of series\n    function computeHermiteSmoothedData (gd) {\n        var smooth = this.renderer.smooth;\n        var tension = this.renderer.tension;\n        var dim = this.canvas.getWidth();\n        var xp = this._xaxis.series_p2u;\n        var yp = this._yaxis.series_p2u; \n        var steps =null;\n        var _steps = null;\n        var a = null;\n        var a1 = null;\n        var a2 = null;\n        var slope = null;\n        var slope2 = null;\n        var temp = null;\n        var t, s, h1, h2, h3, h4;\n        var TiX, TiY, Ti1X, Ti1Y;\n        var pX, pY, p;\n        var sd = [];\n        var spd = [];\n        var dist = gd.length/dim;\n        var min, max, stretch, scale, shift;\n        var _smoothedData = [];\n        var _smoothedPlotData = [];\n        if (!isNaN(parseFloat(smooth))) {\n            steps = parseFloat(smooth);\n        }\n        else {\n            steps = getSteps(dist, 0.5);\n        }\n        if (!isNaN(parseFloat(tension))) {\n            tension = parseFloat(tension);\n        }\n\n        for (var i=0, l = gd.length-1; i < l; i++) {\n\n            if (tension === null) {\n                slope = Math.abs((gd[i+1][1] - gd[i][1]) / (gd[i+1][0] - gd[i][0]));\n\n                min = 0.3;\n                max = 0.6;\n                stretch = (max - min)/2.0;\n                scale = 2.5;\n                shift = -1.4;\n\n                temp = slope/scale + shift;\n\n                a1 = stretch * tanh(temp) - stretch * tanh(shift) + min;\n\n                // if have both left and right line segments, will use  minimum tension. \n                if (i > 0) {\n                    slope2 = Math.abs((gd[i][1] - gd[i-1][1]) / (gd[i][0] - gd[i-1][0]));\n                }\n                temp = slope2/scale + shift;\n\n                a2 = stretch * tanh(temp) - stretch * tanh(shift) + min;\n\n                a = (a1 + a2)/2.0;\n\n            }\n            else {\n                a = tension;\n            }\n            for (t=0; t < steps; t++) {\n                s = t / steps;\n                h1 = (1 + 2*s)*Math.pow((1-s),2);\n                h2 = s*Math.pow((1-s),2);\n                h3 = Math.pow(s,2)*(3-2*s);\n                h4 = Math.pow(s,2)*(s-1);     \n                \n                if (gd[i-1]) {  \n                    TiX = a * (gd[i+1][0] - gd[i-1][0]); \n                    TiY = a * (gd[i+1][1] - gd[i-1][1]);\n                } else {\n                    TiX = a * (gd[i+1][0] - gd[i][0]); \n                    TiY = a * (gd[i+1][1] - gd[i][1]);                                  \n                }\n                if (gd[i+2]) {  \n                    Ti1X = a * (gd[i+2][0] - gd[i][0]); \n                    Ti1Y = a * (gd[i+2][1] - gd[i][1]);\n                } else {\n                    Ti1X = a * (gd[i+1][0] - gd[i][0]); \n                    Ti1Y = a * (gd[i+1][1] - gd[i][1]);                                 \n                }\n                \n                pX = h1*gd[i][0] + h3*gd[i+1][0] + h2*TiX + h4*Ti1X;\n                pY = h1*gd[i][1] + h3*gd[i+1][1] + h2*TiY + h4*Ti1Y;\n                p = [pX, pY];\n\n                _smoothedData.push(p);\n                _smoothedPlotData.push([xp(pX), yp(pY)]);\n            }\n        }\n        _smoothedData.push(gd[l]);\n        _smoothedPlotData.push([xp(gd[l][0]), yp(gd[l][1])]);\n\n        return [_smoothedData, _smoothedPlotData];\n    }\n    \n    // setGridData\n    // converts the user data values to grid coordinates and stores them\n    // in the gridData array.\n    // Called with scope of a series.\n    $.jqplot.LineRenderer.prototype.setGridData = function(plot) {\n        // recalculate the grid data\n        var xp = this._xaxis.series_u2p;\n        var yp = this._yaxis.series_u2p;\n        var data = this._plotData;\n        var pdata = this._prevPlotData;\n        this.gridData = [];\n        this._prevGridData = [];\n        this.renderer._smoothedData = [];\n        this.renderer._smoothedPlotData = [];\n        this.renderer._hiBandGridData = [];\n        this.renderer._lowBandGridData = [];\n        this.renderer._hiBandSmoothedData = [];\n        this.renderer._lowBandSmoothedData = [];\n        var bands = this.renderer.bands;\n        var hasNull = false;\n        for (var i=0, l=data.length; i < l; i++) {\n            // if not a line series or if no nulls in data, push the converted point onto the array.\n            if (data[i][0] != null && data[i][1] != null) {\n                this.gridData.push([xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1])]);\n            }\n            // else if there is a null, preserve it.\n            else if (data[i][0] == null) {\n                hasNull = true;\n                this.gridData.push([null, yp.call(this._yaxis, data[i][1])]);\n            }\n            else if (data[i][1] == null) {\n                hasNull = true;\n                this.gridData.push([xp.call(this._xaxis, data[i][0]), null]);\n            }\n            // if not a line series or if no nulls in data, push the converted point onto the array.\n            if (pdata[i] != null && pdata[i][0] != null && pdata[i][1] != null) {\n                this._prevGridData.push([xp.call(this._xaxis, pdata[i][0]), yp.call(this._yaxis, pdata[i][1])]);\n            }\n            // else if there is a null, preserve it.\n            else if (pdata[i] != null && pdata[i][0] == null) {\n                this._prevGridData.push([null, yp.call(this._yaxis, pdata[i][1])]);\n            }  \n            else if (pdata[i] != null && pdata[i][0] != null && pdata[i][1] == null) {\n                this._prevGridData.push([xp.call(this._xaxis, pdata[i][0]), null]);\n            }\n        }\n\n        // don't do smoothing or bands on broken lines.\n        if (hasNull) {\n            this.renderer.smooth = false;\n            if (this._type === 'line') {\n                bands.show = false;\n            }\n        }\n\n        if (this._type === 'line' && bands.show) {\n            for (var i=0, l=bands.hiData.length; i<l; i++) {\n                this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1])]);\n            }\n            for (var i=0, l=bands.lowData.length; i<l; i++) {\n                this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1])]);\n            }\n        }\n\n        // calculate smoothed data if enough points and no nulls\n        if (this._type === 'line' && this.renderer.smooth && this.gridData.length > 2) {\n            var ret;\n            if (this.renderer.constrainSmoothing) {\n                ret = computeConstrainedSmoothedData.call(this, this.gridData);\n                this.renderer._smoothedData = ret[0];\n                this.renderer._smoothedPlotData = ret[1];\n\n                if (bands.show) {\n                    ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);\n                    this.renderer._hiBandSmoothedData = ret[0];\n                    ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);\n                    this.renderer._lowBandSmoothedData = ret[0];\n                }\n\n                ret = null;\n            }\n            else {\n                ret = computeHermiteSmoothedData.call(this, this.gridData);\n                this.renderer._smoothedData = ret[0];\n                this.renderer._smoothedPlotData = ret[1];\n\n                if (bands.show) {\n                    ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);\n                    this.renderer._hiBandSmoothedData = ret[0];\n                    ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);\n                    this.renderer._lowBandSmoothedData = ret[0];\n                }\n\n                ret = null;\n            }\n        }\n    };\n    \n    // makeGridData\n    // converts any arbitrary data values to grid coordinates and\n    // returns them.  This method exists so that plugins can use a series'\n    // linerenderer to generate grid data points without overwriting the\n    // grid data associated with that series.\n    // Called with scope of a series.\n    $.jqplot.LineRenderer.prototype.makeGridData = function(data, plot) {\n        // recalculate the grid data\n        var xp = this._xaxis.series_u2p;\n        var yp = this._yaxis.series_u2p;\n        var gd = [];\n        var pgd = [];\n        this.renderer._smoothedData = [];\n        this.renderer._smoothedPlotData = [];\n        this.renderer._hiBandGridData = [];\n        this.renderer._lowBandGridData = [];\n        this.renderer._hiBandSmoothedData = [];\n        this.renderer._lowBandSmoothedData = [];\n        var bands = this.renderer.bands;\n        var hasNull = false;\n        for (var i=0; i<data.length; i++) {\n            // if not a line series or if no nulls in data, push the converted point onto the array.\n            if (data[i][0] != null && data[i][1] != null) {\n                if (this.step && i>0) {\n                    gd.push([xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i-1][1])]);\n                }\n                gd.push([xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1])]);\n            }\n            // else if there is a null, preserve it.\n            else if (data[i][0] == null) {\n                hasNull = true;\n                gd.push([null, yp.call(this._yaxis, data[i][1])]);\n            }\n            else if (data[i][1] == null) {\n                hasNull = true;\n                gd.push([xp.call(this._xaxis, data[i][0]), null]);\n            }\n        }\n\n        // don't do smoothing or bands on broken lines.\n        if (hasNull) {\n            this.renderer.smooth = false;\n            if (this._type === 'line') {\n                bands.show = false;\n            }\n        }\n\n        if (this._type === 'line' && bands.show) {\n            for (var i=0, l=bands.hiData.length; i<l; i++) {\n                this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1])]);\n            }\n            for (var i=0, l=bands.lowData.length; i<l; i++) {\n                this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1])]);\n            }\n        }\n\n        if (this._type === 'line' && this.renderer.smooth && gd.length > 2) {\n            var ret;\n            if (this.renderer.constrainSmoothing) {\n                ret = computeConstrainedSmoothedData.call(this, gd);\n                this.renderer._smoothedData = ret[0];\n                this.renderer._smoothedPlotData = ret[1];\n\n                if (bands.show) {\n                    ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);\n                    this.renderer._hiBandSmoothedData = ret[0];\n                    ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);\n                    this.renderer._lowBandSmoothedData = ret[0];\n                }\n\n                ret = null;\n            }\n            else {\n                ret = computeHermiteSmoothedData.call(this, gd);\n                this.renderer._smoothedData = ret[0];\n                this.renderer._smoothedPlotData = ret[1];\n\n                if (bands.show) {\n                    ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);\n                    this.renderer._hiBandSmoothedData = ret[0];\n                    ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);\n                    this.renderer._lowBandSmoothedData = ret[0];\n                }\n\n                ret = null;\n            }\n        }\n        return gd;\n    };\n    \n\n    // called within scope of series.\n    $.jqplot.LineRenderer.prototype.draw = function(ctx, gd, options, plot) {\n        var i;\n        // get a copy of the options, so we don't modify the original object.\n        var opts = $.extend(true, {}, options);\n        var shadow = (opts.shadow != undefined) ? opts.shadow : this.shadow;\n        var showLine = (opts.showLine != undefined) ? opts.showLine : this.showLine;\n        var fill = (opts.fill != undefined) ? opts.fill : this.fill;\n        var fillAndStroke = (opts.fillAndStroke != undefined) ? opts.fillAndStroke : this.fillAndStroke;\n        var xmin, ymin, xmax, ymax;\n        ctx.save();\n        if (gd.length) {\n            if (showLine) {\n                // if we fill, we'll have to add points to close the curve.\n                if (fill) {\n                    if (this.fillToZero) { \n                        // have to break line up into shapes at axis crossings\n                        var negativeColor = this.negativeColor;\n                        if (! this.useNegativeColors) {\n                            negativeColor = opts.fillStyle;\n                        }\n                        var isnegative = false;\n                        var posfs = opts.fillStyle;\n                    \n                        // if stoking line as well as filling, get a copy of line data.\n                        if (fillAndStroke) {\n                            var fasgd = gd.slice(0);\n                        }\n                        // if not stacked, fill down to axis\n                        if (this.index == 0 || !this._stack) {\n                        \n                            var tempgd = [];\n                            var pd = (this.renderer.smooth) ? this.renderer._smoothedPlotData : this._plotData;\n                            this._areaPoints = [];\n                            var pyzero = this._yaxis.series_u2p(this.fillToValue);\n                            var pxzero = this._xaxis.series_u2p(this.fillToValue);\n\n                            opts.closePath = true;\n                            \n                            if (this.fillAxis == 'y') {\n                                tempgd.push([gd[0][0], pyzero]);\n                                this._areaPoints.push([gd[0][0], pyzero]);\n                                \n                                for (var i=0; i<gd.length-1; i++) {\n                                    tempgd.push(gd[i]);\n                                    this._areaPoints.push(gd[i]);\n                                    // do we have an axis crossing?\n                                    if (pd[i][1] * pd[i+1][1] <= 0) {\n                                        if (pd[i][1] < 0) {\n                                            isnegative = true;\n                                            opts.fillStyle = negativeColor;\n                                        }\n                                        else {\n                                            isnegative = false;\n                                            opts.fillStyle = posfs;\n                                        }\n                                        \n                                        var xintercept = gd[i][0] + (gd[i+1][0] - gd[i][0]) * (pyzero-gd[i][1])/(gd[i+1][1] - gd[i][1]);\n                                        tempgd.push([xintercept, pyzero]);\n                                        this._areaPoints.push([xintercept, pyzero]);\n                                        // now draw this shape and shadow.\n                                        if (shadow) {\n                                            this.renderer.shadowRenderer.draw(ctx, tempgd, opts);\n                                        }\n                                        this.renderer.shapeRenderer.draw(ctx, tempgd, opts);\n                                        // now empty temp array and continue\n                                        tempgd = [[xintercept, pyzero]];\n                                        // this._areaPoints = [[xintercept, pyzero]];\n                                    }   \n                                }\n                                if (pd[gd.length-1][1] < 0) {\n                                    isnegative = true;\n                                    opts.fillStyle = negativeColor;\n                                }\n                                else {\n                                    isnegative = false;\n                                    opts.fillStyle = posfs;\n                                }\n                                tempgd.push(gd[gd.length-1]);\n                                this._areaPoints.push(gd[gd.length-1]);\n                                tempgd.push([gd[gd.length-1][0], pyzero]); \n                                this._areaPoints.push([gd[gd.length-1][0], pyzero]); \n                            }\n                            // now draw the last area.\n                            if (shadow) {\n                                this.renderer.shadowRenderer.draw(ctx, tempgd, opts);\n                            }\n                            this.renderer.shapeRenderer.draw(ctx, tempgd, opts);\n                            \n                            \n                            // var gridymin = this._yaxis.series_u2p(0);\n                            // // IE doesn't return new length on unshift\n                            // gd.unshift([gd[0][0], gridymin]);\n                            // len = gd.length;\n                            // gd.push([gd[len - 1][0], gridymin]);                   \n                        }\n                        // if stacked, fill to line below \n                        else {\n                            var prev = this._prevGridData;\n                            for (var i=prev.length; i>0; i--) {\n                                gd.push(prev[i-1]);\n                                // this._areaPoints.push(prev[i-1]);\n                            }\n                            if (shadow) {\n                                this.renderer.shadowRenderer.draw(ctx, gd, opts);\n                            }\n                            this._areaPoints = gd;\n                            this.renderer.shapeRenderer.draw(ctx, gd, opts);\n                        }\n                    }\n                    /////////////////////////\n                    // Not filled to zero\n                    ////////////////////////\n                    else {                    \n                        // if stoking line as well as filling, get a copy of line data.\n                        if (fillAndStroke) {\n                            var fasgd = gd.slice(0);\n                        }\n                        // if not stacked, fill down to axis\n                        if (this.index == 0 || !this._stack) {\n                            // var gridymin = this._yaxis.series_u2p(this._yaxis.min) - this.gridBorderWidth / 2;\n                            var gridymin = ctx.canvas.height;\n                            // IE doesn't return new length on unshift\n                            gd.unshift([gd[0][0], gridymin]);\n                            var len = gd.length;\n                            gd.push([gd[len - 1][0], gridymin]);                   \n                        }\n                        // if stacked, fill to line below \n                        else {\n                            var prev = this._prevGridData;\n                            for (var i=prev.length; i>0; i--) {\n                                gd.push(prev[i-1]);\n                            }\n                        }\n                        this._areaPoints = gd;\n                        \n                        if (shadow) {\n                            this.renderer.shadowRenderer.draw(ctx, gd, opts);\n                        }\n            \n                        this.renderer.shapeRenderer.draw(ctx, gd, opts);                        \n                    }\n                    if (fillAndStroke) {\n                        var fasopts = $.extend(true, {}, opts, {fill:false, closePath:false});\n                        this.renderer.shapeRenderer.draw(ctx, fasgd, fasopts);\n                        //////////\n                        // TODO: figure out some way to do shadows nicely\n                        // if (shadow) {\n                        //     this.renderer.shadowRenderer.draw(ctx, fasgd, fasopts);\n                        // }\n                        // now draw the markers\n                        if (this.markerRenderer.show) {\n                            if (this.renderer.smooth) {\n                                fasgd = this.gridData;\n                            }\n                            for (i=0; i<fasgd.length; i++) {\n                                var markerOptions = opts.markerOptions || {};\n                                if (this.markerOptionsCallback) {\n                                    markerOptions = $.extend(true, markerOptions, this.markerOptionsCallback(plot, this, i, this.data[i], gd[i]) || {});\n                                }\n                                this.markerRenderer.draw(fasgd[i][0], fasgd[i][1], ctx, markerOptions);\n                            }\n                        }\n                    }\n                }\n                else {\n\n                    if (this.renderer.bands.show) {\n                        var bdat;\n                        var bopts = $.extend(true, {}, opts);\n                        if (this.renderer.bands.showLines) {\n                            bdat = (this.renderer.smooth) ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData;\n                            this.renderer.shapeRenderer.draw(ctx, bdat, opts);\n                            bdat = (this.renderer.smooth) ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData;\n                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);\n                        }\n\n                        if (this.renderer.bands.fill) {\n                            if (this.renderer.smooth) {\n                                bdat = this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse());\n                            }\n                            else {\n                                bdat = this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse());\n                            }\n                            this._areaPoints = bdat;\n                            bopts.closePath = true;\n                            bopts.fill = true;\n                            bopts.fillStyle = this.renderer.bands.fillColor;\n                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);\n                        }\n                    }\n\n                    if (shadow) {\n                        this.renderer.shadowRenderer.draw(ctx, gd, opts);\n                    }\n    \n                    this.renderer.shapeRenderer.draw(ctx, gd, opts);\n                }\n            }\n            // calculate the bounding box\n            var xmin = xmax = ymin = ymax = null;\n            for (i=0; i<this._areaPoints.length; i++) {\n                var p = this._areaPoints[i];\n                if (xmin > p[0] || xmin == null) {\n                    xmin = p[0];\n                }\n                if (ymax < p[1] || ymax == null) {\n                    ymax = p[1];\n                }\n                if (xmax < p[0] || xmax == null) {\n                    xmax = p[0];\n                }\n                if (ymin > p[1] || ymin == null) {\n                    ymin = p[1];\n                }\n            }\n\n            if (this.type === 'line' && this.renderer.bands.show) {\n                ymax = this._yaxis.series_u2p(this.renderer.bands._min);\n                ymin = this._yaxis.series_u2p(this.renderer.bands._max);\n            }\n\n            this._boundingBox = [[xmin, ymax], [xmax, ymin]];\n        \n            // now draw the markers\n            if (this.markerRenderer.show && !fill) {\n                if (this.renderer.smooth) {\n                    gd = this.gridData;\n                }\n                for (i=0; i<gd.length; i++) {\n                    var markerOptions = opts.markerOptions || {};\n                    if (this.markerOptionsCallback) {\n                        markerOptions = $.extend(true, markerOptions, this.markerOptionsCallback(plot, this, i, this.data[i], gd[i]) || {});\n                    }\n                    if (gd[i][0] != null && gd[i][1] != null) {\n                        this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, markerOptions);\n                    }\n                }\n            }\n        }\n        \n        ctx.restore();\n    };  \n    \n    $.jqplot.LineRenderer.prototype.drawShadow = function(ctx, gd, options) {\n        // This is a no-op, shadows drawn with lines.\n    };\n    \n    // called with scope of plot.\n    // make sure to not leave anything highlighted.\n    function postInit(target, data, options) {\n        for (var i=0; i<this.series.length; i++) {\n            if (this.series[i].renderer.constructor == $.jqplot.LineRenderer) {\n                // don't allow mouseover and mousedown at same time.\n                if (this.series[i].highlightMouseOver) {\n                    this.series[i].highlightMouseDown = false;\n                }\n            }\n        }\n    }  \n    \n    // called within context of plot\n    // create a canvas which we can draw on.\n    // insert it before the eventCanvas, so eventCanvas will still capture events.\n    function postPlotDraw() {\n        // Memory Leaks patch    \n        if (this.plugins.lineRenderer && this.plugins.lineRenderer.highlightCanvas) {\n          this.plugins.lineRenderer.highlightCanvas.resetCanvas();\n          this.plugins.lineRenderer.highlightCanvas = null;\n        }\n        \n        this.plugins.lineRenderer.highlightedSeriesIndex = null;\n        this.plugins.lineRenderer.highlightCanvas = new $.jqplot.GenericCanvas();\n        \n        this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, 'jqplot-lineRenderer-highlight-canvas', this._plotDimensions, this));\n        this.plugins.lineRenderer.highlightCanvas.setContext();\n        this.eventCanvas._elem.bind('mouseleave', {plot:this}, function (ev) { unhighlight(ev.data.plot); });\n    } \n    \n    function highlight (plot, sidx, pidx, points) {\n        var s = plot.series[sidx];\n        var canvas = plot.plugins.lineRenderer.highlightCanvas;\n        canvas._ctx.clearRect(0,0,canvas._ctx.canvas.width, canvas._ctx.canvas.height);\n        s._highlightedPoint = pidx;\n        plot.plugins.lineRenderer.highlightedSeriesIndex = sidx;\n        var opts = {fillStyle: s.highlightColor};\n        if (s.type === 'line' && s.renderer.bands.show) {\n            opts.fill = true;\n            opts.closePath = true;\n        }\n        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts);\n        canvas = null;\n    }\n    \n    function unhighlight (plot) {\n        var canvas = plot.plugins.lineRenderer.highlightCanvas;\n        canvas._ctx.clearRect(0,0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);\n        for (var i=0; i<plot.series.length; i++) {\n            plot.series[i]._highlightedPoint = null;\n        }\n        plot.plugins.lineRenderer.highlightedSeriesIndex = null;\n        plot.target.trigger('jqplotDataUnhighlight');\n        canvas = null;\n    }\n    \n    \n    function handleMove(ev, gridpos, datapos, neighbor, plot) {\n        if (neighbor) {\n            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];\n            var evt1 = jQuery.Event('jqplotDataMouseOver');\n            evt1.pageX = ev.pageX;\n            evt1.pageY = ev.pageY;\n            plot.target.trigger(evt1, ins);\n            if (plot.series[ins[0]].highlightMouseOver && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {\n                var evt = jQuery.Event('jqplotDataHighlight');\n                evt.which = ev.which;\n                evt.pageX = ev.pageX;\n                evt.pageY = ev.pageY;\n                plot.target.trigger(evt, ins);\n                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);\n            }\n        }\n        else if (neighbor == null) {\n            unhighlight (plot);\n        }\n    }\n    \n    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {\n        if (neighbor) {\n            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];\n            if (plot.series[ins[0]].highlightMouseDown && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {\n                var evt = jQuery.Event('jqplotDataHighlight');\n                evt.which = ev.which;\n                evt.pageX = ev.pageX;\n                evt.pageY = ev.pageY;\n                plot.target.trigger(evt, ins);\n                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);\n            }\n        }\n        else if (neighbor == null) {\n            unhighlight (plot);\n        }\n    }\n    \n    function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {\n        var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;\n        if (idx != null && plot.series[idx].highlightMouseDown) {\n            unhighlight(plot);\n        }\n    }\n    \n    function handleClick(ev, gridpos, datapos, neighbor, plot) {\n        if (neighbor) {\n            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];\n            var evt = jQuery.Event('jqplotDataClick');\n            evt.which = ev.which;\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            plot.target.trigger(evt, ins);\n        }\n    }\n    \n    function handleRightClick(ev, gridpos, datapos, neighbor, plot) {\n        if (neighbor) {\n            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];\n            var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;\n            if (idx != null && plot.series[idx].highlightMouseDown) {\n                unhighlight(plot);\n            }\n            var evt = jQuery.Event('jqplotDataRightClick');\n            evt.which = ev.which;\n            evt.pageX = ev.pageX;\n            evt.pageY = ev.pageY;\n            plot.target.trigger(evt, ins);\n        }\n    }\n    \n    \n\n    // class: $.jqplot.LinearAxisRenderer\n    // The default jqPlot axis renderer, creating a numeric axis.\n    $.jqplot.LinearAxisRenderer = function() {\n    };\n    \n    // called with scope of axis object.\n    $.jqplot.LinearAxisRenderer.prototype.init = function(options){\n        // prop: breakPoints\n        // EXPERIMENTAL!! Use at your own risk!\n        // Works only with linear axes and the default tick renderer.\n        // Array of [start, stop] points to create a broken axis.\n        // Broken axes have a \"jump\" in them, which is an immediate \n        // transition from a smaller value to a larger value.\n        // Currently, axis ticks MUST be manually assigned if using breakPoints\n        // by using the axis ticks array option.\n        this.breakPoints = null;\n        // prop: breakTickLabel\n        // Label to use at the axis break if breakPoints are specified.\n        this.breakTickLabel = \"&asymp;\";\n        // prop: drawBaseline\n        // True to draw the axis baseline.\n        this.drawBaseline = true;\n        // prop: baselineWidth\n        // width of the baseline in pixels.\n        this.baselineWidth = null;\n        // prop: baselineColor\n        // CSS color spec for the baseline.\n        this.baselineColor = null;\n        // prop: forceTickAt0\n        // This will ensure that there is always a tick mark at 0.\n        // If data range is strictly positive or negative,\n        // this will force 0 to be inside the axis bounds unless\n        // the appropriate axis pad (pad, padMin or padMax) is set\n        // to 0, then this will force an axis min or max value at 0.\n        // This has know effect when any of the following options\n        // are set:  autoscale, min, max, numberTicks or tickInterval.\n        this.forceTickAt0 = false;\n        // prop: forceTickAt100\n        // This will ensure that there is always a tick mark at 100.\n        // If data range is strictly above or below 100,\n        // this will force 100 to be inside the axis bounds unless\n        // the appropriate axis pad (pad, padMin or padMax) is set\n        // to 0, then this will force an axis min or max value at 100.\n        // This has know effect when any of the following options\n        // are set:  autoscale, min, max, numberTicks or tickInterval.\n        this.forceTickAt100 = false;\n        // prop: tickInset\n        // Controls the amount to inset the first and last ticks from \n        // the edges of the grid, in multiples of the tick interval.\n        // 0 is no inset, 0.5 is one half a tick interval, 1 is a full\n        // tick interval, etc.\n        this.tickInset = 0;\n        // prop: minorTicks\n        // Number of ticks to add between \"major\" ticks.\n        // Major ticks are ticks supplied by user or auto computed.\n        // Minor ticks cannot be created by user.\n        this.minorTicks = 0;\n        // prop: alignTicks\n        // true to align tick marks across opposed axes\n        // such as from the y2axis to yaxis.\n        this.alignTicks = false;\n        this._autoFormatString = '';\n        this._overrideFormatString = false;\n        this._scalefact = 1.0;\n        $.extend(true, this, options);\n        if (this.breakPoints) {\n            if (!$.isArray(this.breakPoints)) {\n                this.breakPoints = null;\n            }\n            else if (this.breakPoints.length < 2 || this.breakPoints[1] <= this.breakPoints[0]) {\n                this.breakPoints = null;\n            }\n        }\n        if (this.numberTicks != null && this.numberTicks < 2) {\n            this.numberTicks = 2;\n        }\n        this.resetDataBounds();\n    };\n    \n    // called with scope of axis\n    $.jqplot.LinearAxisRenderer.prototype.draw = function(ctx, plot) {\n        if (this.show) {\n            // populate the axis label and value properties.\n            // createTicks is a method on the renderer, but\n            // call it within the scope of the axis.\n            this.renderer.createTicks.call(this, plot);\n            // fill a div with axes labels in the right direction.\n            // Need to pregenerate each axis to get its bounds and\n            // position it and the labels correctly on the plot.\n            var dim=0;\n            var temp;\n            // Added for theming.\n            if (this._elem) {\n                // Memory Leaks patch\n                //this._elem.empty();\n                this._elem.emptyForce();\n                this._elem = null;\n            }\n            \n            this._elem = $(document.createElement('div'));\n            this._elem.addClass('jqplot-axis jqplot-'+this.name);\n            this._elem.css('position', 'absolute');\n\n            \n            if (this.name == 'xaxis' || this.name == 'x2axis') {\n                this._elem.width(this._plotDimensions.width);\n            }\n            else {\n                this._elem.height(this._plotDimensions.height);\n            }\n            \n            // create a _label object.\n            this.labelOptions.axis = this.name;\n            this._label = new this.labelRenderer(this.labelOptions);\n            if (this._label.show) {\n                var elem = this._label.draw(ctx, plot);\n                elem.appendTo(this._elem);\n                elem = null;\n            }\n    \n            var t = this._ticks;\n            var tick;\n            for (var i=0; i<t.length; i++) {\n                tick = t[i];\n                if (tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {\n                    this._elem.append(tick.draw(ctx, plot));\n                }\n            }\n            tick = null;\n            t = null;\n        }\n        return this._elem;\n    };\n    \n    // called with scope of an axis\n    $.jqplot.LinearAxisRenderer.prototype.reset = function() {\n        this.min = this._options.min;\n        this.max = this._options.max;\n        this.tickInterval = this._options.tickInterval;\n        this.numberTicks = this._options.numberTicks;\n        this._autoFormatString = '';\n        if (this._overrideFormatString && this.tickOptions && this.tickOptions.formatString) {\n            this.tickOptions.formatString = '';\n        }\n\n        // this._ticks = this.__ticks;\n    };\n    \n    // called with scope of axis\n    $.jqplot.LinearAxisRenderer.prototype.set = function() { \n        var dim = 0;\n        var temp;\n        var w = 0;\n        var h = 0;\n        var lshow = (this._label == null) ? false : this._label.show;\n        if (this.show) {\n            var t = this._ticks;\n            var tick;\n            for (var i=0; i<t.length; i++) {\n                tick = t[i];\n                if (!tick._breakTick && tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {\n                    if (this.name == 'xaxis' || this.name == 'x2axis') {\n                        temp = tick._elem.outerHeight(true);\n                    }\n                    else {\n                        temp = tick._elem.outerWidth(true);\n                    }\n                    if (temp > dim) {\n                        dim = temp;\n                    }\n                }\n            }\n            tick = null;\n            t = null;\n            \n            if (lshow) {\n                w = this._label._elem.outerWidth(true);\n                h = this._label._elem.outerHeight(true); \n            }\n            if (this.name == 'xaxis') {\n                dim = dim + h;\n                this._elem.css({'height':dim+'px', left:'0px', bottom:'0px'});\n            }\n            else if (this.name == 'x2axis') {\n                dim = dim + h;\n                this._elem.css({'height':dim+'px', left:'0px', top:'0px'});\n            }\n            else if (this.name == 'yaxis') {\n                dim = dim + w;\n                this._elem.css({'width':dim+'px', left:'0px', top:'0px'});\n                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {\n                    this._label._elem.css('width', w+'px');\n                }\n            }\n            else {\n                dim = dim + w;\n                this._elem.css({'width':dim+'px', right:'0px', top:'0px'});\n                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {\n                    this._label._elem.css('width', w+'px');\n                }\n            }\n        }  \n    };    \n    \n    // called with scope of axis\n    $.jqplot.LinearAxisRenderer.prototype.createTicks = function(plot) {\n        // we're are operating on an axis here\n        var ticks = this._ticks;\n        var userTicks = this.ticks;\n        var name = this.name;\n        // databounds were set on axis initialization.\n        var db = this._dataBounds;\n        var dim = (this.name.charAt(0) === 'x') ? this._plotDimensions.width : this._plotDimensions.height;\n        var interval;\n        var min, max;\n        var pos1, pos2;\n        var tt, i;\n        // get a copy of user's settings for min/max.\n        var userMin = this.min;\n        var userMax = this.max;\n        var userNT = this.numberTicks;\n        var userTI = this.tickInterval;\n\n        var threshold = 30;\n        this._scalefact =  (Math.max(dim, threshold+1) - threshold)/300.0;\n        \n        // if we already have ticks, use them.\n        // ticks must be in order of increasing value.\n        \n        if (userTicks.length) {\n            // ticks could be 1D or 2D array of [val, val, ,,,] or [[val, label], [val, label], ...] or mixed\n            for (i=0; i<userTicks.length; i++){\n                var ut = userTicks[i];\n                var t = new this.tickRenderer(this.tickOptions);\n                if ($.isArray(ut)) {\n                    t.value = ut[0];\n                    if (this.breakPoints) {\n                        if (ut[0] == this.breakPoints[0]) {\n                            t.label = this.breakTickLabel;\n                            t._breakTick = true;\n                            t.showGridline = false;\n                            t.showMark = false;\n                        }\n                        else if (ut[0] > this.breakPoints[0] && ut[0] <= this.breakPoints[1]) {\n                            t.show = false;\n                            t.showGridline = false;\n                            t.label = ut[1];\n                        }\n                        else {\n                            t.label = ut[1];\n                        }\n                    }\n                    else {\n                        t.label = ut[1];\n                    }\n                    t.setTick(ut[0], this.name);\n                    this._ticks.push(t);\n                }\n\n                else if ($.isPlainObject(ut)) {\n                    $.extend(true, t, ut);\n                    t.axis = this.name;\n                    this._ticks.push(t);\n                }\n                \n                else {\n                    t.value = ut;\n                    if (this.breakPoints) {\n                        if (ut == this.breakPoints[0]) {\n                            t.label = this.breakTickLabel;\n                            t._breakTick = true;\n                            t.showGridline = false;\n                            t.showMark = false;\n                        }\n                        else if (ut > this.breakPoints[0] && ut <= this.breakPoints[1]) {\n                            t.show = false;\n                            t.showGridline = false;\n                        }\n                    }\n                    t.setTick(ut, this.name);\n                    this._ticks.push(t);\n                }\n            }\n            this.numberTicks = userTicks.length;\n            this.min = this._ticks[0].value;\n            this.max = this._ticks[this.numberTicks-1].value;\n            this.tickInterval = (this.max - this.min) / (this.numberTicks - 1);\n        }\n        \n        // we don't have any ticks yet, let's make some!\n        else {\n            if (name == 'xaxis' || name == 'x2axis') {\n                dim = this._plotDimensions.width;\n            }\n            else {\n                dim = this._plotDimensions.height;\n            }\n\n            var _numberTicks = this.numberTicks;\n\n            // if aligning this axis, use number of ticks from previous axis.\n            // Do I need to reset somehow if alignTicks is changed and then graph is replotted??\n            if (this.alignTicks) {\n                if (this.name === 'x2axis' && plot.axes.xaxis.show) {\n                    _numberTicks = plot.axes.xaxis.numberTicks;\n                }\n                else if (this.name.charAt(0) === 'y' && this.name !== 'yaxis' && this.name !== 'yMidAxis' && plot.axes.yaxis.show) {\n                    _numberTicks = plot.axes.yaxis.numberTicks;\n                }\n            }\n        \n            min = ((this.min != null) ? this.min : db.min);\n            max = ((this.max != null) ? this.max : db.max);\n\n            var range = max - min;\n            var rmin, rmax;\n            var temp;\n\n            if (this.tickOptions == null || !this.tickOptions.formatString) {\n                this._overrideFormatString = true;\n            }\n\n            // Doing complete autoscaling\n            if (this.min == null || this.max == null && this.tickInterval == null && !this.autoscale) {\n                // Check if user must have tick at 0 or 100 and ensure they are in range.\n                // The autoscaling algorithm will always place ticks at 0 and 100 if they are in range.\n                if (this.forceTickAt0) {\n                    if (min > 0) {\n                        min = 0;\n                    }\n                    if (max < 0) {\n                        max = 0;\n                    }\n                }\n\n                if (this.forceTickAt100) {\n                    if (min > 100) {\n                        min = 100;\n                    }\n                    if (max < 100) {\n                        max = 100;\n                    }\n                }\n\n                var keepMin = false,\n                    keepMax = false;\n\n                if (this.min != null) {\n                    keepMin = true;\n                }\n\n                else if (this.max != null) {\n                    keepMax = true;\n                }\n\n                // var threshold = 30;\n                // var tdim = Math.max(dim, threshold+1);\n                // this._scalefact =  (tdim-threshold)/300.0;\n                var ret = $.jqplot.LinearTickGenerator(min, max, this._scalefact, _numberTicks, keepMin, keepMax); \n                // calculate a padded max and min, points should be less than these\n                // so that they aren't too close to the edges of the plot.\n                // User can adjust how much padding is allowed with pad, padMin and PadMax options. \n                // If min or max is set, don't pad that end of axis.\n                var tumin = (this.min != null) ? min : min + range*(this.padMin - 1);\n                var tumax = (this.max != null) ? max : max - range*(this.padMax - 1);\n\n                // if they're equal, we shouldn't have to do anything, right?\n                // if (min <=tumin || max >= tumax) {\n                if (min <tumin || max > tumax) {\n                    tumin = (this.min != null) ? min : min - range*(this.padMin - 1);\n                    tumax = (this.max != null) ? max : max + range*(this.padMax - 1);\n                    ret = $.jqplot.LinearTickGenerator(tumin, tumax, this._scalefact, _numberTicks, keepMin, keepMax);\n                }\n\n                this.min = ret[0];\n                this.max = ret[1];\n                // if numberTicks specified, it should return the same.\n                this.numberTicks = ret[2];\n                this._autoFormatString = ret[3];\n                this.tickInterval = ret[4];\n            }\n\n            // User has specified some axis scale related option, can use auto algorithm\n            else {\n                \n                // if min and max are same, space them out a bit\n                if (min == max) {\n                    var adj = 0.05;\n                    if (min > 0) {\n                        adj = Math.max(Math.log(min)/Math.LN10, 0.05);\n                    }\n                    min -= adj;\n                    max += adj;\n                }\n                \n                // autoscale.  Can't autoscale if min or max is supplied.\n                // Will use numberTicks and tickInterval if supplied.  Ticks\n                // across multiple axes may not line up depending on how\n                // bars are to be plotted.\n                if (this.autoscale && this.min == null && this.max == null) {\n                    var rrange, ti, margin;\n                    var forceMinZero = false;\n                    var forceZeroLine = false;\n                    var intervals = {min:null, max:null, average:null, stddev:null};\n                    // if any series are bars, or if any are fill to zero, and if this\n                    // is the axis to fill toward, check to see if we can start axis at zero.\n                    for (var i=0; i<this._series.length; i++) {\n                        var s = this._series[i];\n                        var faname = (s.fillAxis == 'x') ? s._xaxis.name : s._yaxis.name;\n                        // check to see if this is the fill axis\n                        if (this.name == faname) {\n                            var vals = s._plotValues[s.fillAxis];\n                            var vmin = vals[0];\n                            var vmax = vals[0];\n                            for (var j=1; j<vals.length; j++) {\n                                if (vals[j] < vmin) {\n                                    vmin = vals[j];\n                                }\n                                else if (vals[j] > vmax) {\n                                    vmax = vals[j];\n                                }\n                            }\n                            var dp = (vmax - vmin) / vmax;\n                            // is this sries a bar?\n                            if (s.renderer.constructor == $.jqplot.BarRenderer) {\n                                // if no negative values and could also check range.\n                                if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {\n                                    forceMinZero = true;\n                                }\n                                else {\n                                    forceMinZero = false;\n                                    if (s.fill && s.fillToZero && vmin < 0 && vmax > 0) {\n                                        forceZeroLine = true;\n                                    }\n                                    else {\n                                        forceZeroLine = false;\n                                    }\n                                }\n                            }\n                            \n                            // if not a bar and filling, use appropriate method.\n                            else if (s.fill) {\n                                if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {\n                                    forceMinZero = true;\n                                }\n                                else if (vmin < 0 && vmax > 0 && s.fillToZero) {\n                                    forceMinZero = false;\n                                    forceZeroLine = true;\n                                }\n                                else {\n                                    forceMinZero = false;\n                                    forceZeroLine = false;\n                                }\n                            }\n                            \n                            // if not a bar and not filling, only change existing state\n                            // if it doesn't make sense\n                            else if (vmin < 0) {\n                                forceMinZero = false;\n                            }\n                        }\n                    }\n                    \n                    // check if we need make axis min at 0.\n                    if (forceMinZero) {\n                        // compute number of ticks\n                        this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);\n                        this.min = 0;\n                        userMin = 0;\n                        // what order is this range?\n                        // what tick interval does that give us?\n                        ti = max/(this.numberTicks-1);\n                        temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));\n                        if (ti/temp == parseInt(ti/temp, 10)) {\n                            ti += temp;\n                        }\n                        this.tickInterval = Math.ceil(ti/temp) * temp;\n                        this.max = this.tickInterval * (this.numberTicks - 1);\n                    }\n                    \n                    // check if we need to make sure there is a tick at 0.\n                    else if (forceZeroLine) {\n                        // compute number of ticks\n                        this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);\n                        var ntmin = Math.ceil(Math.abs(min)/range*(this.numberTicks-1));\n                        var ntmax = this.numberTicks - 1  - ntmin;\n                        ti = Math.max(Math.abs(min/ntmin), Math.abs(max/ntmax));\n                        temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));\n                        this.tickInterval = Math.ceil(ti/temp) * temp;\n                        this.max = this.tickInterval * ntmax;\n                        this.min = -this.tickInterval * ntmin;\n                    }\n                    \n                    // if nothing else, do autoscaling which will try to line up ticks across axes.\n                    else {  \n                        if (this.numberTicks == null){\n                            if (this.tickInterval) {\n                                this.numberTicks = 3 + Math.ceil(range / this.tickInterval);\n                            }\n                            else {\n                                this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);\n                            }\n                        }\n                \n                        if (this.tickInterval == null) {\n                            // get a tick interval\n                            ti = range/(this.numberTicks - 1);\n\n                            if (ti < 1) {\n                                temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));\n                            }\n                            else {\n                                temp = 1;\n                            }\n                            this.tickInterval = Math.ceil(ti*temp*this.pad)/temp;\n                        }\n                        else {\n                            temp = 1 / this.tickInterval;\n                        }\n                        \n                        // try to compute a nicer, more even tick interval\n                        // temp = Math.pow(10, Math.floor(Math.log(ti)/Math.LN10));\n                        // this.tickInterval = Math.ceil(ti/temp) * temp;\n                        rrange = this.tickInterval * (this.numberTicks - 1);\n                        margin = (rrange - range)/2;\n           \n                        if (this.min == null) {\n                            this.min = Math.floor(temp*(min-margin))/temp;\n                        }\n                        if (this.max == null) {\n                            this.max = this.min + rrange;\n                        }\n                    }\n\n                    // Compute a somewhat decent format string if it is needed.\n                    // get precision of interval and determine a format string.\n                    var sf = $.jqplot.getSignificantFigures(this.tickInterval);\n\n                    var fstr;\n\n                    // if we have only a whole number, use integer formatting\n                    if (sf.digitsLeft >= sf.significantDigits) {\n                        fstr = '%d';\n                    }\n\n                    else {\n                        var temp = Math.max(0, 5 - sf.digitsLeft);\n                        temp = Math.min(temp, sf.digitsRight);\n                        fstr = '%.'+ temp + 'f';\n                    }\n\n                    this._autoFormatString = fstr;\n                }\n                \n                // Use the default algorithm which pads each axis to make the chart\n                // centered nicely on the grid.\n                else {\n\n                    rmin = (this.min != null) ? this.min : min - range*(this.padMin - 1);\n                    rmax = (this.max != null) ? this.max : max + range*(this.padMax - 1);\n                    range = rmax - rmin;\n        \n                    if (this.numberTicks == null){\n                        // if tickInterval is specified by user, we will ignore computed maximum.\n                        // max will be equal or greater to fit even # of ticks.\n                        if (this.tickInterval != null) {\n                            this.numberTicks = Math.ceil((rmax - rmin)/this.tickInterval)+1;\n                        }\n                        else if (dim > 100) {\n                            this.numberTicks = parseInt(3+(dim-100)/75, 10);\n                        }\n                        else {\n                            this.numberTicks = 2;\n                        }\n                    }\n                \n                    if (this.tickInterval == null) {\n                        this.tickInterval = range / (this.numberTicks-1);\n                    }\n                    \n                    if (this.max == null) {\n                        rmax = rmin + this.tickInterval*(this.numberTicks - 1);\n                    }        \n                    if (this.min == null) {\n                        rmin = rmax - this.tickInterval*(this.numberTicks - 1);\n                    }\n\n                    // get precision of interval and determine a format string.\n                    var sf = $.jqplot.getSignificantFigures(this.tickInterval);\n\n                    var fstr;\n\n                    // if we have only a whole number, use integer formatting\n                    if (sf.digitsLeft >= sf.significantDigits) {\n                        fstr = '%d';\n                    }\n\n                    else {\n                        var temp = Math.max(0, 5 - sf.digitsLeft);\n                        temp = Math.min(temp, sf.digitsRight);\n                        fstr = '%.'+ temp + 'f';\n                    }\n\n\n                    this._autoFormatString = fstr;\n\n                    this.min = rmin;\n                    this.max = rmax;\n                }\n                \n                if (this.renderer.constructor == $.jqplot.LinearAxisRenderer && this._autoFormatString == '') {\n                    // fix for misleading tick display with small range and low precision.\n                    range = this.max - this.min;\n                    // figure out precision\n                    var temptick = new this.tickRenderer(this.tickOptions);\n                    // use the tick formatString or, the default.\n                    var fs = temptick.formatString || $.jqplot.config.defaultTickFormatString; \n                    var fs = fs.match($.jqplot.sprintf.regex)[0];\n                    var precision = 0;\n                    if (fs) {\n                        if (fs.search(/[fFeEgGpP]/) > -1) {\n                            var m = fs.match(/\\%\\.(\\d{0,})?[eEfFgGpP]/);\n                            if (m) {\n                                precision = parseInt(m[1], 10);\n                            }\n                            else {\n                                precision = 6;\n                            }\n                        }\n                        else if (fs.search(/[di]/) > -1) {\n                            precision = 0;\n                        }\n                        // fact will be <= 1;\n                        var fact = Math.pow(10, -precision);\n                        if (this.tickInterval < fact) {\n                            // need to correct underrange\n                            if (userNT == null && userTI == null) {\n                                this.tickInterval = fact;\n                                if (userMax == null && userMin == null) {\n                                    // this.min = Math.floor((this._dataBounds.min - this.tickInterval)/fact) * fact;\n                                    this.min = Math.floor(this._dataBounds.min/fact) * fact;\n                                    if (this.min == this._dataBounds.min) {\n                                        this.min = this._dataBounds.min - this.tickInterval;\n                                    }\n                                    // this.max = Math.ceil((this._dataBounds.max + this.tickInterval)/fact) * fact;\n                                    this.max = Math.ceil(this._dataBounds.max/fact) * fact;\n                                    if (this.max == this._dataBounds.max) {\n                                        this.max = this._dataBounds.max + this.tickInterval;\n                                    }\n                                    var n = (this.max - this.min)/this.tickInterval;\n                                    n = n.toFixed(11);\n                                    n = Math.ceil(n);\n                                    this.numberTicks = n + 1;\n                                }\n                                else if (userMax == null) {\n                                    // add one tick for top of range.\n                                    var n = (this._dataBounds.max - this.min) / this.tickInterval;\n                                    n = n.toFixed(11);\n                                    this.numberTicks = Math.ceil(n) + 2;\n                                    this.max = this.min + this.tickInterval * (this.numberTicks-1);\n                                }\n                                else if (userMin == null) {\n                                    // add one tick for bottom of range.\n                                    var n = (this.max - this._dataBounds.min) / this.tickInterval;\n                                    n = n.toFixed(11);\n                                    this.numberTicks = Math.ceil(n) + 2;\n                                    this.min = this.max - this.tickInterval * (this.numberTicks-1);\n                                }\n                                else {\n                                    // calculate a number of ticks so max is within axis scale\n                                    this.numberTicks = Math.ceil((userMax - userMin)/this.tickInterval) + 1;\n                                    // if user's min and max don't fit evenly in ticks, adjust.\n                                    // This takes care of cases such as user min set to 0, max set to 3.5 but tick\n                                    // format string set to %d (integer ticks)\n                                    this.min =  Math.floor(userMin*Math.pow(10, precision))/Math.pow(10, precision);\n                                    this.max =  Math.ceil(userMax*Math.pow(10, precision))/Math.pow(10, precision);\n                                    // this.max = this.min + this.tickInterval*(this.numberTicks-1);\n                                    this.numberTicks = Math.ceil((this.max - this.min)/this.tickInterval) + 1;\n                                }\n                            }\n                        }\n                    }\n                }\n                \n            }\n            \n            if (this._overrideFormatString && this._autoFormatString != '') {\n                this.tickOptions = this.tickOptions || {};\n                this.tickOptions.formatString = this._autoFormatString;\n            }\n\n            var t, to;\n            for (var i=0; i<this.numberTicks; i++){\n                tt = this.min + i * this.tickInterval;\n                t = new this.tickRenderer(this.tickOptions);\n                // var t = new $.jqplot.AxisTickRenderer(this.tickOptions);\n\n                t.setTick(tt, this.name);\n                this._ticks.push(t);\n\n                if (i < this.numberTicks - 1) {\n                    for (var j=0; j<this.minorTicks; j++) {\n                        tt += this.tickInterval/(this.minorTicks+1);\n                        to = $.extend(true, {}, this.tickOptions, {name:this.name, value:tt, label:'', isMinorTick:true});\n                        t = new this.tickRenderer(to);\n                        this._ticks.push(t);\n                    }\n                }\n                t = null;\n            }\n        }\n\n        if (this.tickInset) {\n            this.min = this.min - this.tickInset * this.tickInterval;\n            this.max = this.max + this.tickInset * this.tickInterval;\n        }\n\n        ticks = null;\n    };\n    \n    // Used to reset just the values of the ticks and then repack, which will\n    // recalculate the positioning functions.  It is assuemd that the \n    // number of ticks is the same and the values of the new array are at the\n    // proper interval.\n    // This method needs to be called with the scope of an axis object, like:\n    //\n    // > plot.axes.yaxis.renderer.resetTickValues.call(plot.axes.yaxis, yarr);\n    //\n    $.jqplot.LinearAxisRenderer.prototype.resetTickValues = function(opts) {\n        if ($.isArray(opts) && opts.length == this._ticks.length) {\n            var t;\n            for (var i=0; i<opts.length; i++) {\n                t = this._ticks[i];\n                t.value = opts[i];\n                t.label = t.formatter(t.formatString, opts[i]);\n                t.label = t.prefix + t.label;\n                t._elem.html(t.label);\n            }\n            t = null;\n            this.min = $.jqplot.arrayMin(opts);\n            this.max = $.jqplot.arrayMax(opts);\n            this.pack();\n        }\n        // Not implemented yet.\n        // else if ($.isPlainObject(opts)) {\n        // \n        // }\n    };\n    \n    // called with scope of axis\n    $.jqplot.LinearAxisRenderer.prototype.pack = function(pos, offsets) {\n        // Add defaults for repacking from resetTickValues function.\n        pos = pos || {};\n        offsets = offsets || this._offsets;\n        \n        var ticks = this._ticks;\n        var max = this.max;\n        var min = this.min;\n        var offmax = offsets.max;\n        var offmin = offsets.min;\n        var lshow = (this._label == null) ? false : this._label.show;\n        \n        for (var p in pos) {\n            this._elem.css(p, pos[p]);\n        }\n        \n        this._offsets = offsets;\n        // pixellength will be + for x axes and - for y axes becasue pixels always measured from top left.\n        var pixellength = offmax - offmin;\n        var unitlength = max - min;\n        \n        // point to unit and unit to point conversions references to Plot DOM element top left corner.\n        if (this.breakPoints) {\n            unitlength = unitlength - this.breakPoints[1] + this.breakPoints[0];\n            \n            this.p2u = function(p){\n                return (p - offmin) * unitlength / pixellength + min;\n            };\n        \n            this.u2p = function(u){\n                if (u > this.breakPoints[0] && u < this.breakPoints[1]){\n                    u = this.breakPoints[0];\n                }\n                if (u <= this.breakPoints[0]) {\n                    return (u - min) * pixellength / unitlength + offmin;\n                }\n                else {\n                    return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength + offmin;\n                }\n            };\n                \n            if (this.name.charAt(0) == 'x'){\n                this.series_u2p = function(u){\n                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){\n                        u = this.breakPoints[0];\n                    }\n                    if (u <= this.breakPoints[0]) {\n                        return (u - min) * pixellength / unitlength;\n                    }\n                    else {\n                        return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength;\n                    }\n                };\n                this.series_p2u = function(p){\n                    return p * unitlength / pixellength + min;\n                };\n            }\n        \n            else {\n                this.series_u2p = function(u){\n                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){\n                        u = this.breakPoints[0];\n                    }\n                    if (u >= this.breakPoints[1]) {\n                        return (u - max) * pixellength / unitlength;\n                    }\n                    else {\n                        return (u + this.breakPoints[1] - this.breakPoints[0] - max) * pixellength / unitlength;\n                    }\n                };\n                this.series_p2u = function(p){\n                    return p * unitlength / pixellength + max;\n                };\n            }\n        }\n        else {\n            this.p2u = function(p){\n                return (p - offmin) * unitlength / pixellength + min;\n            };\n        \n            this.u2p = function(u){\n                return (u - min) * pixellength / unitlength + offmin;\n            };\n                \n            if (this.name == 'xaxis' || this.name == 'x2axis'){\n                this.series_u2p = function(u){\n                    return (u - min) * pixellength / unitlength;\n                };\n                this.series_p2u = function(p){\n                    return p * unitlength / pixellength + min;\n                };\n            }\n        \n            else {\n                this.series_u2p = function(u){\n                    return (u - max) * pixellength / unitlength;\n                };\n                this.series_p2u = function(p){\n                    return p * unitlength / pixellength + max;\n                };\n            }\n        }\n        \n        if (this.show) {\n            if (this.name == 'xaxis' || this.name == 'x2axis') {\n                for (var i=0; i<ticks.length; i++) {\n                    var t = ticks[i];\n                    if (t.show && t.showLabel) {\n                        var shim;\n                        \n                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {\n                            // will need to adjust auto positioning based on which axis this is.\n                            var temp = (this.name == 'xaxis') ? 1 : -1;\n                            switch (t.labelPosition) {\n                                case 'auto':\n                                    // position at end\n                                    if (temp * t.angle < 0) {\n                                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;\n                                    }\n                                    // position at start\n                                    else {\n                                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;\n                                    }\n                                    break;\n                                case 'end':\n                                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;\n                                    break;\n                                case 'start':\n                                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;\n                                    break;\n                                case 'middle':\n                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;\n                                    break;\n                                default:\n                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;\n                                    break;\n                            }\n                        }\n                        else {\n                            shim = -t.getWidth()/2;\n                        }\n                        var val = this.u2p(t.value) + shim + 'px';\n                        t._elem.css('left', val);\n                        t.pack();\n                    }\n                }\n                if (lshow) {\n                    var w = this._label._elem.outerWidth(true);\n                    this._label._elem.css('left', offmin + pixellength/2 - w/2 + 'px');\n                    if (this.name == 'xaxis') {\n                        this._label._elem.css('bottom', '0px');\n                    }\n                    else {\n                        this._label._elem.css('top', '0px');\n                    }\n                    this._label.pack();\n                }\n            }\n            else {\n                for (var i=0; i<ticks.length; i++) {\n                    var t = ticks[i];\n                    if (t.show && t.showLabel) {                        \n                        var shim;\n                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {\n                            // will need to adjust auto positioning based on which axis this is.\n                            var temp = (this.name == 'yaxis') ? 1 : -1;\n                            switch (t.labelPosition) {\n                                case 'auto':\n                                    // position at end\n                                case 'end':\n                                    if (temp * t.angle < 0) {\n                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;\n                                    }\n                                    else {\n                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;\n                                    }\n                                    break;\n                                case 'start':\n                                    if (t.angle > 0) {\n                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;\n                                    }\n                                    else {\n                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;\n                                    }\n                                    break;\n                                case 'middle':\n                                    // if (t.angle > 0) {\n                                    //     shim = -t.getHeight()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;\n                                    // }\n                                    // else {\n                                    //     shim = -t.getHeight()/2 - t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;\n                                    // }\n                                    shim = -t.getHeight()/2;\n                                    break;\n                                default:\n                                    shim = -t.getHeight()/2;\n                                    break;\n                            }\n                        }\n                        else {\n                            shim = -t.getHeight()/2;\n                        }\n                        \n                        var val = this.u2p(t.value) + shim + 'px';\n                        t._elem.css('top', val);\n                        t.pack();\n                    }\n                }\n                if (lshow) {\n                    var h = this._label._elem.outerHeight(true);\n                    this._label._elem.css('top', offmax - pixellength/2 - h/2 + 'px');\n                    if (this.name == 'yaxis') {\n                        this._label._elem.css('left', '0px');\n                    }\n                    else {\n                        this._label._elem.css('right', '0px');\n                    }   \n                    this._label.pack();\n                }\n            }\n        }\n\n        ticks = null;\n    };\n\n\n    /**\n    * The following code was generaously given to me a while back by Scott Prahl.\n    * He did a good job at computing axes min, max and number of ticks for the \n    * case where the user has not set any scale related parameters (tickInterval,\n    * numberTicks, min or max).  I had ignored this use case for a long time,\n    * focusing on the more difficult case where user has set some option controlling\n    * tick generation.  Anyway, about time I got this into jqPlot.\n    * Thanks Scott!!\n    */\n    \n    /**\n    * Copyright (c) 2010 Scott Prahl\n    * The next three routines are currently available for use in all personal \n    * or commercial projects under both the MIT and GPL version 2.0 licenses. \n    * This means that you can choose the license that best suits your project \n    * and use it accordingly. \n    */\n\n    // A good format string depends on the interval. If the interval is greater \n    // than 1 then there is no need to show any decimal digits. If it is < 1.0, then\n    // use the magnitude of the interval to determine the number of digits to show.\n    function bestFormatString (interval)\n    {\n        var fstr;\n        interval = Math.abs(interval);\n        if (interval >= 10) {\n            fstr = '%d';\n        }\n\n        else if (interval > 1) {\n            if (interval === parseInt(interval, 10)) {\n                fstr = '%d';\n            }\n            else {\n                fstr = '%.1f';\n            }\n        }\n\n        else {\n            var expv = -Math.floor(Math.log(interval)/Math.LN10);\n            fstr = '%.' + expv + 'f';\n        }\n        \n        return fstr; \n    }\n\n    var _factors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.8, 1, 2, 3, 4, 5];\n\n    var _getLowerFactor = function(f) {\n        var i = _factors.indexOf(f);\n        if (i > 0) {\n            return _factors[i-1];\n        }\n        else {\n            return _factors[_factors.length - 1] / 100;\n        }\n    };\n\n    var _getHigherFactor = function(f) {\n        var i = _factors.indexOf(f);\n        if (i < _factors.length-1) {\n            return _factors[i+1];\n        }\n        else {\n            return _factors[0] * 100;\n        }\n    };\n\n    // Given a fixed minimum and maximum and a target number ot ticks\n    // figure out the best interval and \n    // return min, max, number ticks, format string and tick interval\n    function bestConstrainedInterval(min, max, nttarget) {\n        // run through possible number to ticks and see which interval is best\n        var low = Math.floor(nttarget/2);\n        var hi = Math.ceil(nttarget*1.5);\n        var badness = Number.MAX_VALUE;\n        var r = (max - min);\n        var temp;\n        var sd;\n        var bestNT;\n        var gsf = $.jqplot.getSignificantFigures;\n        var fsd;\n        var fs;\n        var currentNT;\n        var bestPrec;\n\n        for (var i=0, l=hi-low+1; i<l; i++) {\n            currentNT = low + i;\n            temp = r/(currentNT-1);\n            sd = gsf(temp);\n\n            temp = Math.abs(nttarget - currentNT) + sd.digitsRight;\n            if (temp < badness) {\n                badness = temp;\n                bestNT = currentNT;\n                bestPrec = sd.digitsRight;\n            }\n            else if (temp === badness) {\n                // let nicer ticks trump number ot ticks\n                if (sd.digitsRight < bestPrec) {\n                    bestNT = currentNT;\n                    bestPrec = sd.digitsRight;\n                }\n            }\n\n        }\n\n        fsd = Math.max(bestPrec, Math.max(gsf(min).digitsRight, gsf(max).digitsRight));\n        if (fsd === 0) {\n            fs = '%d';\n        }\n        else {\n            fs = '%.' + fsd + 'f';\n        }\n        temp = r / (bestNT - 1);\n        // min, max, number ticks, format string, tick interval\n        return [min, max, bestNT, fs, temp];\n    }\n\n    // This will return an interval of form 2 * 10^n, 5 * 10^n or 10 * 10^n\n    // it is based soley on the range and number of ticks.  So if user specifies\n    // number of ticks, use this.\n    function bestInterval(range, numberTicks) {\n        numberTicks = numberTicks || 7;\n        var minimum = range / (numberTicks - 1);\n        var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.LN10));\n        var residual = minimum / magnitude;\n        var interval;\n        // \"nicest\" ranges are 1, 2, 5 or powers of these.\n        // for magnitudes below 1, only allow these. \n        if (magnitude < 1) {\n            if (residual > 5) {\n                interval = 10 * magnitude;\n            }\n            else if (residual > 2) {\n                interval = 5 * magnitude;\n            }\n            else if (residual > 1) {\n                interval = 2 * magnitude;\n            }\n            else {\n                interval = magnitude;\n            }\n        }\n        // for large ranges (whole integers), allow intervals like 3, 4 or powers of these.\n        // this helps a lot with poor choices for number of ticks. \n        else {\n            if (residual > 5) {\n                interval = 10 * magnitude;\n            }\n            else if (residual > 4) {\n                interval = 5 * magnitude;\n            }\n            else if (residual > 3) {\n                interval = 4 * magnitude;\n            }\n            else if (residual > 2) {\n                interval = 3 * magnitude;\n            }\n            else if (residual > 1) {\n                interval = 2 * magnitude;\n            }\n            else {\n                interval = magnitude;\n            }\n        }\n\n        return interval;\n    }\n\n    // This will return an interval of form 2 * 10^n, 5 * 10^n or 10 * 10^n\n    // it is based soley on the range of data, number of ticks must be computed later.\n    function bestLinearInterval(range, scalefact) {\n        scalefact = scalefact || 1;\n        var expv = Math.floor(Math.log(range)/Math.LN10);\n        var magnitude = Math.pow(10, expv);\n        // 0 < f < 10\n        var f = range / magnitude;\n        var fact;\n        // for large plots, scalefact will decrease f and increase number of ticks.\n        // for small plots, scalefact will increase f and decrease number of ticks.\n        f = f/scalefact;\n\n        // for large plots, smaller interval, more ticks.\n        if (f<=0.38) {\n            fact = 0.1;\n        }\n        else if (f<=1.6) {\n            fact = 0.2;\n        }\n        else if (f<=4.0) {\n            fact = 0.5;\n        }\n        else if (f<=8.0) {\n            fact = 1.0;\n        }\n        // for very small plots, larger interval, less ticks in number ticks\n        else if (f<=16.0) {\n            fact = 2;\n        }\n        else {\n            fact = 5;\n        } \n\n        return fact*magnitude; \n    }\n\n    function bestLinearComponents(range, scalefact) {\n        var expv = Math.floor(Math.log(range)/Math.LN10);\n        var magnitude = Math.pow(10, expv);\n        // 0 < f < 10\n        var f = range / magnitude;\n        var interval;\n        var fact;\n        // for large plots, scalefact will decrease f and increase number of ticks.\n        // for small plots, scalefact will increase f and decrease number of ticks.\n        f = f/scalefact;\n\n        // for large plots, smaller interval, more ticks.\n        if (f<=0.38) {\n            fact = 0.1;\n        }\n        else if (f<=1.6) {\n            fact = 0.2;\n        }\n        else if (f<=4.0) {\n            fact = 0.5;\n        }\n        else if (f<=8.0) {\n            fact = 1.0;\n        }\n        // for very small plots, larger interval, less ticks in number ticks\n        else if (f<=16.0) {\n            fact = 2;\n        }\n        // else if (f<=20.0) {\n        //     fact = 3;\n        // }\n        // else if (f<=24.0) {\n        //     fact = 4;\n        // }\n        else {\n            fact = 5;\n        } \n\n        interval = fact * magnitude;\n\n        return [interval, fact, magnitude];\n    }\n\n    // Given the min and max for a dataset, return suitable endpoints\n    // for the graphing, a good number for the number of ticks, and a\n    // format string so that extraneous digits are not displayed.\n    // returned is an array containing [min, max, nTicks, format]\n    $.jqplot.LinearTickGenerator = function(axis_min, axis_max, scalefact, numberTicks, keepMin, keepMax) {\n        // Set to preserve EITHER min OR max.\n        // If min is preserved, max must be free.\n        keepMin = (keepMin === null) ? false : keepMin;\n        keepMax = (keepMax === null || keepMin) ? false : keepMax;\n        // if endpoints are equal try to include zero otherwise include one\n        if (axis_min === axis_max) {\n            axis_max = (axis_max) ? 0 : 1;\n        }\n\n        scalefact = scalefact || 1.0;\n\n        // make sure range is positive\n        if (axis_max < axis_min) {\n            var a = axis_max;\n            axis_max = axis_min;\n            axis_min = a;\n        }\n\n        var r = [];\n        var ss = bestLinearInterval(axis_max - axis_min, scalefact);\n\n        var gsf = $.jqplot.getSignificantFigures;\n        \n        if (numberTicks == null) {\n\n            // Figure out the axis min, max and number of ticks\n            // the min and max will be some multiple of the tick interval,\n            // 1*10^n, 2*10^n or 5*10^n.  This gaurantees that, if the\n            // axis min is negative, 0 will be a tick.\n            if (!keepMin && !keepMax) {\n                r[0] = Math.floor(axis_min / ss) * ss;  // min\n                r[1] = Math.ceil(axis_max / ss) * ss;   // max\n                r[2] = Math.round((r[1]-r[0])/ss+1.0);  // number of ticks\n                r[3] = bestFormatString(ss);            // format string\n                r[4] = ss;                              // tick Interval\n            }\n\n            else if (keepMin) {\n                r[0] = axis_min;                                        // min\n                r[2] = Math.ceil((axis_max - axis_min) / ss + 1.0);     // number of ticks\n                r[1] = axis_min + (r[2] - 1) * ss;                      // max\n                var digitsMin = gsf(axis_min).digitsRight;\n                var digitsSS = gsf(ss).digitsRight;\n                if (digitsMin < digitsSS) {\n                    r[3] = bestFormatString(ss);                        // format string\n                }\n                else {\n                    r[3] = '%.' + digitsMin + 'f';\n                }\n                r[4] = ss;                                              // tick Interval\n            }\n\n            else if (keepMax) {\n                r[1] = axis_max;                                        // max\n                r[2] = Math.ceil((axis_max - axis_min) / ss + 1.0);     // number of ticks\n                r[0] = axis_max - (r[2] - 1) * ss;                      // min\n                var digitsMax = gsf(axis_max).digitsRight;\n                var digitsSS = gsf(ss).digitsRight;\n                if (digitsMax < digitsSS) {\n                    r[3] = bestFormatString(ss);                        // format string\n                }\n                else {\n                    r[3] = '%.' + digitsMax + 'f';\n                }\n                r[4] = ss;                                              // tick Interval\n            }\n        }\n\n        else {\n            var tempr = [];\n\n            // Figure out the axis min, max and number of ticks\n            // the min and max will be some multiple of the tick interval,\n            // 1*10^n, 2*10^n or 5*10^n.  This gaurantees that, if the\n            // axis min is negative, 0 will be a tick.\n            tempr[0] = Math.floor(axis_min / ss) * ss;  // min\n            tempr[1] = Math.ceil(axis_max / ss) * ss;   // max\n            tempr[2] = Math.round((tempr[1]-tempr[0])/ss+1.0);    // number of ticks\n            tempr[3] = bestFormatString(ss);            // format string\n            tempr[4] = ss;                              // tick Interval\n\n            // first, see if we happen to get the right number of ticks\n            if (tempr[2] === numberTicks) {\n                r = tempr;\n            }\n\n            else {\n\n                var newti = bestInterval(tempr[1] - tempr[0], numberTicks);\n\n                r[0] = tempr[0];                        // min\n                r[2] = numberTicks;                     // number of ticks\n                r[4] = newti;                           // tick interval\n                r[3] = bestFormatString(newti);         // format string\n                r[1] = r[0] + (r[2] - 1) * r[4];        // max\n            }\n        }\n\n        return r;\n    };\n\n    $.jqplot.LinearTickGenerator.bestLinearInterval = bestLinearInterval;\n    $.jqplot.LinearTickGenerator.bestInterval = bestInterval;\n    $.jqplot.LinearTickGenerator.bestLinearComponents = bestLinearComponents;\n    $.jqplot.LinearTickGenerator.bestConstrainedInterval = bestConstrainedInterval;\n\n\n    // class: $.jqplot.MarkerRenderer\n    // The default jqPlot marker renderer, rendering the points on the line.\n    $.jqplot.MarkerRenderer = function(options){\n        // Group: Properties\n        \n        // prop: show\n        // whether or not to show the marker.\n        this.show = true;\n        // prop: style\n        // One of diamond, circle, square, x, plus, dash, filledDiamond, filledCircle, filledSquare\n        this.style = 'filledCircle';\n        // prop: lineWidth\n        // size of the line for non-filled markers.\n        this.lineWidth = 2;\n        // prop: size\n        // Size of the marker (diameter or circle, length of edge of square, etc.)\n        this.size = 9.0;\n        // prop: color\n        // color of marker.  Will be set to color of series by default on init.\n        this.color = '#666666';\n        // prop: shadow\n        // whether or not to draw a shadow on the line\n        this.shadow = true;\n        // prop: shadowAngle\n        // Shadow angle in degrees\n        this.shadowAngle = 45;\n        // prop: shadowOffset\n        // Shadow offset from line in pixels\n        this.shadowOffset = 1;\n        // prop: shadowDepth\n        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.\n        this.shadowDepth = 3;\n        // prop: shadowAlpha\n        // Alpha channel transparency of shadow.  0 = transparent.\n        this.shadowAlpha = '0.07';\n        // prop: shadowRenderer\n        // Renderer that will draws the shadows on the marker.\n        this.shadowRenderer = new $.jqplot.ShadowRenderer();\n        // prop: shapeRenderer\n        // Renderer that will draw the marker.\n        this.shapeRenderer = new $.jqplot.ShapeRenderer();\n        \n        $.extend(true, this, options);\n    };\n    \n    function getShadowRendererOptions(opts) {\n        var sdopt = {angle:opts.shadowAngle, offset:opts.shadowOffset, alpha:opts.shadowAlpha, lineWidth:opts.lineWidth, depth:opts.shadowDepth, closePath:true};\n        if (opts.style.indexOf('filled') != -1) {\n            sdopt.fill = true;\n        }\n        if (opts.style.indexOf('ircle') != -1) {\n            sdopt.isarc = true;\n            sdopt.closePath = false;\n        }\n        return $.extend(true, {}, sdopt);\n    }\n    \n    function getShapeRendererOptions(opts) {\n        var shopt = {fill:false, isarc:false, strokeStyle:opts.color, fillStyle:opts.color, lineWidth:opts.lineWidth, closePath:true};\n        if (opts.style.indexOf('filled') != -1) {\n            shopt.fill = true;\n        }\n        if (opts.style.indexOf('ircle') != -1) {\n            shopt.isarc = true;\n            shopt.closePath = false;\n        }\n        return $.extend(true, {}, shopt);\n    }\n    \n    $.jqplot.MarkerRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawDiamond = function(x, y, ctx, fill, options) {\n        var opts;\n        if (options == null || $.isEmptyObject(options)) {\n            opts = this;\n        } else {\n            opts = $.extend(true, {}, this, options);\n        }\n        var stretch = 1.2;\n        var dx = this.size/2/stretch;\n        var dy = this.size/2*stretch;\n        var points = [[x-dx, y], [x, y+dy], [x+dx, y], [x, y-dy]];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawPlus = function(x, y, ctx, fill, options) {\n        var opts = $.extend(true, {}, this, options, {closePath:false});\n        var stretch = 1.0;\n        var dx = opts.size/2*stretch;\n        var dy = opts.size/2*stretch;\n        var points1 = [[x, y-dy], [x, y+dy]];\n        var points2 = [[x+dx, y], [x-dx, y]];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points1, getShadowRendererOptions(opts));\n            this.shadowRenderer.draw(ctx, points2, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points1, opts);\n        this.shapeRenderer.draw(ctx, points2, opts);\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawX = function(x, y, ctx, fill, options) {\n        var opts = $.extend(true, {}, this, options, {closePath:false});\n        var stretch = 1.0;\n        var dx = opts.size/2*stretch;\n        var dy = opts.size/2*stretch;\n        var points1 = [[x-dx, y-dy], [x+dx, y+dy]];\n        var points2 = [[x-dx, y+dy], [x+dx, y-dy]];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points1, getShadowRendererOptions(opts));\n            this.shadowRenderer.draw(ctx, points2, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points1, getShapeRendererOptions(opts));\n        this.shapeRenderer.draw(ctx, points2, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawDash = function(x, y, ctx, fill, options) {\n        var opts;\n        if (options == null || $.isEmptyObject(options)) {\n            opts = this;\n        } else {\n            opts = $.extend(true, {}, this, options);\n        }\n        var stretch = 1.0;\n        var dx = this.size/2*stretch;\n        var dy = this.size/2*stretch;\n        var points = [[x-dx, y], [x+dx, y]];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points);\n        }\n        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawLine = function(p1, p2, ctx, fill, options) {\n        var opts;\n        if (options == null || $.isEmptyObject(options)) {\n            opts = this;\n        } else {\n            opts = $.extend(true, {}, this, options);\n        }\n        var points = [p1, p2];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawSquare = function(x, y, ctx, fill, options) {\n        var opts;\n        if (options == null || $.isEmptyObject(options)) {\n            opts = this;\n        } else {\n            opts = $.extend(true, {}, this, options);\n        }\n        var stretch = 1.0;\n        var dx = this.size/2/stretch;\n        var dy = this.size/2*stretch;\n        var points = [[x-dx, y-dy], [x-dx, y+dy], [x+dx, y+dy], [x+dx, y-dy]];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.drawCircle = function(x, y, ctx, fill, options) {\n        var opts;\n        if (options == null || $.isEmptyObject(options)) {\n            opts = this;\n        } else {\n            opts = $.extend(true, {}, this, options);\n        }\n        var radius = this.size/2;\n        var end = 2*Math.PI;\n        var points = [x, y, radius, 0, end, true];\n        if (opts.shadow) {\n            this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));\n        }\n        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));\n    };\n    \n    $.jqplot.MarkerRenderer.prototype.draw = function(x, y, ctx, options) {\n        options = options || {};\n        // hack here b/c shape renderer uses canvas based color style options\n        // and marker uses css style names.\n        if (options.show == null || options.show != false) {\n            if (options.color && !options.fillStyle) {\n                options.fillStyle = options.color;\n            }\n            if (options.color && !options.strokeStyle) {\n                options.strokeStyle = options.color;\n            }\n            var style = options.style || this.style;\n            switch (style) {\n                case 'diamond':\n                    this.drawDiamond(x,y,ctx, false, options);\n                    break;\n                case 'filledDiamond':\n                    this.drawDiamond(x,y,ctx, true, options);\n                    break;\n                case 'circle':\n                    this.drawCircle(x,y,ctx, false, options);\n                    break;\n                case 'filledCircle':\n                    this.drawCircle(x,y,ctx, true, options);\n                    break;\n                case 'square':\n                    this.drawSquare(x,y,ctx, false, options);\n                    break;\n                case 'filledSquare':\n                    this.drawSquare(x,y,ctx, true, options);\n                    break;\n                case 'x':\n                    this.drawX(x,y,ctx, true, options);\n                    break;\n                case 'plus':\n                    this.drawPlus(x,y,ctx, true, options);\n                    break;\n                case 'dash':\n                    this.drawDash(x,y,ctx, true, options);\n                    break;\n                case 'line':\n                    this.drawLine(x, y, ctx, false, options);\n                    break;\n                default:\n                    this.drawDiamond(x,y,ctx, false, options);\n                    break;\n            }\n        }\n    };\n    \n\n    // class: $.jqplot.shadowRenderer\n    // The default jqPlot shadow renderer, rendering shadows behind shapes.\n    $.jqplot.ShadowRenderer = function(options){ \n        // Group: Properties\n        \n        // prop: angle\n        // Angle of the shadow in degrees.  Measured counter-clockwise from the x axis.\n        this.angle = 45;\n        // prop: offset\n        // Pixel offset at the given shadow angle of each shadow stroke from the last stroke.\n        this.offset = 1;\n        // prop: alpha\n        // alpha transparency of shadow stroke.\n        this.alpha = 0.07;\n        // prop: lineWidth\n        // width of the shadow line stroke.\n        this.lineWidth = 1.5;\n        // prop: lineJoin\n        // How line segments of the shadow are joined.\n        this.lineJoin = 'miter';\n        // prop: lineCap\n        // how ends of the shadow line are rendered.\n        this.lineCap = 'round';\n        // prop; closePath\n        // whether line path segment is closed upon itself.\n        this.closePath = false;\n        // prop: fill\n        // whether to fill the shape.\n        this.fill = false;\n        // prop: depth\n        // how many times the shadow is stroked.  Each stroke will be offset by offset at angle degrees.\n        this.depth = 3;\n        this.strokeStyle = 'rgba(0,0,0,0.1)';\n        // prop: isarc\n        // whether the shadow is an arc or not.\n        this.isarc = false;\n        \n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.ShadowRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    // function: draw\n    // draws an transparent black (i.e. gray) shadow.\n    //\n    // ctx - canvas drawing context\n    // points - array of points or [x, y, radius, start angle (rad), end angle (rad)]\n    $.jqplot.ShadowRenderer.prototype.draw = function(ctx, points, options) {\n        ctx.save();\n        var opts = (options != null) ? options : {};\n        var fill = (opts.fill != null) ? opts.fill : this.fill;\n        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;\n        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;\n        var offset = (opts.offset != null) ? opts.offset : this.offset;\n        var alpha = (opts.alpha != null) ? opts.alpha : this.alpha;\n        var depth = (opts.depth != null) ? opts.depth : this.depth;\n        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;\n        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;\n        ctx.lineWidth = (opts.lineWidth != null) ? opts.lineWidth : this.lineWidth;\n        ctx.lineJoin = (opts.lineJoin != null) ? opts.lineJoin : this.lineJoin;\n        ctx.lineCap = (opts.lineCap != null) ? opts.lineCap : this.lineCap;\n        ctx.strokeStyle = opts.strokeStyle || this.strokeStyle || 'rgba(0,0,0,'+alpha+')';\n        ctx.fillStyle = opts.fillStyle || this.fillStyle || 'rgba(0,0,0,'+alpha+')';\n        for (var j=0; j<depth; j++) {\n            var ctxPattern = $.jqplot.LinePattern(ctx, linePattern);\n            ctx.translate(Math.cos(this.angle*Math.PI/180)*offset, Math.sin(this.angle*Math.PI/180)*offset);\n            ctxPattern.beginPath();\n            if (isarc) {\n                ctx.arc(points[0], points[1], points[2], points[3], points[4], true);                \n            }\n            else if (fillRect) {\n                if (fillRect) {\n                    ctx.fillRect(points[0], points[1], points[2], points[3]);\n                }\n            }\n            else if (points && points.length){\n                var move = true;\n                for (var i=0; i<points.length; i++) {\n                    // skip to the first non-null point and move to it.\n                    if (points[i][0] != null && points[i][1] != null) {\n                        if (move) {\n                            ctxPattern.moveTo(points[i][0], points[i][1]);\n                            move = false;\n                        }\n                        else {\n                            ctxPattern.lineTo(points[i][0], points[i][1]);\n                        }\n                    }\n                    else {\n                        move = true;\n                    }\n                }\n                \n            }\n            if (closePath) {\n                ctxPattern.closePath();\n            }\n            if (fill) {\n                ctx.fill();\n            }\n            else {\n                ctx.stroke();\n            }\n        }\n        ctx.restore();\n    };\n    \n    // class: $.jqplot.shapeRenderer\n    // The default jqPlot shape renderer.  Given a set of points will\n    // plot them and either stroke a line (fill = false) or fill them (fill = true).\n    // If a filled shape is desired, closePath = true must also be set to close\n    // the shape.\n    $.jqplot.ShapeRenderer = function(options){\n        \n        this.lineWidth = 1.5;\n        // prop: linePattern\n        // line pattern 'dashed', 'dotted', 'solid', some combination\n        // of '-' and '.' characters such as '.-.' or a numerical array like \n        // [draw, skip, draw, skip, ...] such as [1, 10] to draw a dotted line, \n        // [1, 10, 20, 10] to draw a dot-dash line, and so on.\n        this.linePattern = 'solid';\n        // prop: lineJoin\n        // How line segments of the shadow are joined.\n        this.lineJoin = 'miter';\n        // prop: lineCap\n        // how ends of the shadow line are rendered.\n        this.lineCap = 'round';\n        // prop; closePath\n        // whether line path segment is closed upon itself.\n        this.closePath = false;\n        // prop: fill\n        // whether to fill the shape.\n        this.fill = false;\n        // prop: isarc\n        // whether the shadow is an arc or not.\n        this.isarc = false;\n        // prop: fillRect\n        // true to draw shape as a filled rectangle.\n        this.fillRect = false;\n        // prop: strokeRect\n        // true to draw shape as a stroked rectangle.\n        this.strokeRect = false;\n        // prop: clearRect\n        // true to cear a rectangle.\n        this.clearRect = false;\n        // prop: strokeStyle\n        // css color spec for the stoke style\n        this.strokeStyle = '#999999';\n        // prop: fillStyle\n        // css color spec for the fill style.\n        this.fillStyle = '#999999'; \n        \n        $.extend(true, this, options);\n    };\n    \n    $.jqplot.ShapeRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n    \n    // function: draw\n    // draws the shape.\n    //\n    // ctx - canvas drawing context\n    // points - array of points for shapes or \n    // [x, y, width, height] for rectangles or\n    // [x, y, radius, start angle (rad), end angle (rad)] for circles and arcs.\n    $.jqplot.ShapeRenderer.prototype.draw = function(ctx, points, options) {\n        ctx.save();\n        var opts = (options != null) ? options : {};\n        var fill = (opts.fill != null) ? opts.fill : this.fill;\n        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;\n        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;\n        var strokeRect = (opts.strokeRect != null) ? opts.strokeRect : this.strokeRect;\n        var clearRect = (opts.clearRect != null) ? opts.clearRect : this.clearRect;\n        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;\n        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;\n        var ctxPattern = $.jqplot.LinePattern(ctx, linePattern);\n        ctx.lineWidth = opts.lineWidth || this.lineWidth;\n        ctx.lineJoin = opts.lineJoin || this.lineJoin;\n        ctx.lineCap = opts.lineCap || this.lineCap;\n        ctx.strokeStyle = (opts.strokeStyle || opts.color) || this.strokeStyle;\n        ctx.fillStyle = opts.fillStyle || this.fillStyle;\n        ctx.beginPath();\n        if (isarc) {\n            ctx.arc(points[0], points[1], points[2], points[3], points[4], true);   \n            if (closePath) {\n                ctx.closePath();\n            }\n            if (fill) {\n                ctx.fill();\n            }\n            else {\n                ctx.stroke();\n            }\n            ctx.restore();\n            return;\n        }\n        else if (clearRect) {\n            ctx.clearRect(points[0], points[1], points[2], points[3]);\n            ctx.restore();\n            return;\n        }\n        else if (fillRect || strokeRect) {\n            if (fillRect) {\n                ctx.fillRect(points[0], points[1], points[2], points[3]);\n            }\n            if (strokeRect) {\n                ctx.strokeRect(points[0], points[1], points[2], points[3]);\n                ctx.restore();\n                return;\n            }\n        }\n        else if (points && points.length){\n            var move = true;\n            for (var i=0; i<points.length; i++) {\n                // skip to the first non-null point and move to it.\n                if (points[i][0] != null && points[i][1] != null) {\n                    if (move) {\n                        ctxPattern.moveTo(points[i][0], points[i][1]);\n                        move = false;\n                    }\n                    else {\n                        ctxPattern.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n                else {\n                    move = true;\n                }\n            }\n            if (closePath) {\n                ctxPattern.closePath();\n            }\n            if (fill) {\n                ctx.fill();\n            }\n            else {\n                ctx.stroke();\n            }\n        }\n        ctx.restore();\n    };\n    \n    // class $.jqplot.TableLegendRenderer\n    // The default legend renderer for jqPlot.\n    $.jqplot.TableLegendRenderer = function(){\n        //\n    };\n    \n    $.jqplot.TableLegendRenderer.prototype.init = function(options) {\n        $.extend(true, this, options);\n    };\n        \n    $.jqplot.TableLegendRenderer.prototype.addrow = function (label, color, pad, reverse) {\n        var rs = (pad) ? this.rowSpacing+'px' : '0px';\n        var tr;\n        var td;\n        var elem;\n        var div0;\n        var div1;\n        elem = document.createElement('tr');\n        tr = $(elem);\n        tr.addClass('jqplot-table-legend');\n        elem = null;\n\n        if (reverse){\n            tr.prependTo(this._elem);\n        }\n\n        else{\n            tr.appendTo(this._elem);\n        }\n\n        if (this.showSwatches) {\n            td = $(document.createElement('td'));\n            td.addClass('jqplot-table-legend jqplot-table-legend-swatch');\n            td.css({textAlign: 'center', paddingTop: rs});\n\n            div0 = $(document.createElement('div'));\n            div0.addClass('jqplot-table-legend-swatch-outline');\n            div1 = $(document.createElement('div'));\n            div1.addClass('jqplot-table-legend-swatch');\n            div1.css({backgroundColor: color, borderColor: color});\n\n            tr.append(td.append(div0.append(div1)));\n\n            // $('<td class=\"jqplot-table-legend\" style=\"text-align:center;padding-top:'+rs+';\">'+\n            // '<div><div class=\"jqplot-table-legend-swatch\" style=\"background-color:'+color+';border-color:'+color+';\"></div>'+\n            // '</div></td>').appendTo(tr);\n        }\n        if (this.showLabels) {\n            td = $(document.createElement('td'));\n            td.addClass('jqplot-table-legend jqplot-table-legend-label');\n            td.css('paddingTop', rs);\n            tr.append(td);\n\n            // elem = $('<td class=\"jqplot-table-legend\" style=\"padding-top:'+rs+';\"></td>');\n            // elem.appendTo(tr);\n            if (this.escapeHtml) {\n                td.text(label);\n            }\n            else {\n                td.html(label);\n            }\n        }\n        td = null;\n        div0 = null;\n        div1 = null;\n        tr = null;\n        elem = null;\n    };\n    \n    // called with scope of legend\n    $.jqplot.TableLegendRenderer.prototype.draw = function() {\n        if (this._elem) {\n            this._elem.emptyForce();\n            this._elem = null;\n        }\n\n        if (this.show) {\n            var series = this._series;\n            // make a table.  one line label per row.\n            var elem = document.createElement('table');\n            this._elem = $(elem);\n            this._elem.addClass('jqplot-table-legend');\n\n            var ss = {position:'absolute'};\n            if (this.background) {\n                ss['background'] = this.background;\n            }\n            if (this.border) {\n                ss['border'] = this.border;\n            }\n            if (this.fontSize) {\n                ss['fontSize'] = this.fontSize;\n            }\n            if (this.fontFamily) {\n                ss['fontFamily'] = this.fontFamily;\n            }\n            if (this.textColor) {\n                ss['textColor'] = this.textColor;\n            }\n            if (this.marginTop != null) {\n                ss['marginTop'] = this.marginTop;\n            }\n            if (this.marginBottom != null) {\n                ss['marginBottom'] = this.marginBottom;\n            }\n            if (this.marginLeft != null) {\n                ss['marginLeft'] = this.marginLeft;\n            }\n            if (this.marginRight != null) {\n                ss['marginRight'] = this.marginRight;\n            }\n            \n        \n            var pad = false, \n                reverse = false,\n                s;\n            for (var i = 0; i< series.length; i++) {\n                s = series[i];\n                if (s._stack || s.renderer.constructor == $.jqplot.BezierCurveRenderer){\n                    reverse = true;\n                }\n                if (s.show && s.showLabel) {\n                    var lt = this.labels[i] || s.label.toString();\n                    if (lt) {\n                        var color = s.color;\n                        if (reverse && i < series.length - 1){\n                            pad = true;\n                        }\n                        else if (reverse && i == series.length - 1){\n                            pad = false;\n                        }\n                        this.renderer.addrow.call(this, lt, color, pad, reverse);\n                        pad = true;\n                    }\n                    // let plugins add more rows to legend.  Used by trend line plugin.\n                    for (var j=0; j<$.jqplot.addLegendRowHooks.length; j++) {\n                        var item = $.jqplot.addLegendRowHooks[j].call(this, s);\n                        if (item) {\n                            this.renderer.addrow.call(this, item.label, item.color, pad);\n                            pad = true;\n                        } \n                    }\n                    lt = null;\n                }\n            }\n        }\n        return this._elem;\n    };\n    \n    $.jqplot.TableLegendRenderer.prototype.pack = function(offsets) {\n        if (this.show) {       \n            if (this.placement == 'insideGrid') {\n                switch (this.location) {\n                    case 'nw':\n                        var a = offsets.left;\n                        var b = offsets.top;\n                        this._elem.css('left', a);\n                        this._elem.css('top', b);\n                        break;\n                    case 'n':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        var b = offsets.top;\n                        this._elem.css('left', a);\n                        this._elem.css('top', b);\n                        break;\n                    case 'ne':\n                        var a = offsets.right;\n                        var b = offsets.top;\n                        this._elem.css({right:a, top:b});\n                        break;\n                    case 'e':\n                        var a = offsets.right;\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({right:a, top:b});\n                        break;\n                    case 'se':\n                        var a = offsets.right;\n                        var b = offsets.bottom;\n                        this._elem.css({right:a, bottom:b});\n                        break;\n                    case 's':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        var b = offsets.bottom;\n                        this._elem.css({left:a, bottom:b});\n                        break;\n                    case 'sw':\n                        var a = offsets.left;\n                        var b = offsets.bottom;\n                        this._elem.css({left:a, bottom:b});\n                        break;\n                    case 'w':\n                        var a = offsets.left;\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({left:a, top:b});\n                        break;\n                    default:  // same as 'se'\n                        var a = offsets.right;\n                        var b = offsets.bottom;\n                        this._elem.css({right:a, bottom:b});\n                        break;\n                }\n                \n            }\n            else if (this.placement == 'outside'){\n                switch (this.location) {\n                    case 'nw':\n                        var a = this._plotDimensions.width - offsets.left;\n                        var b = offsets.top;\n                        this._elem.css('right', a);\n                        this._elem.css('top', b);\n                        break;\n                    case 'n':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        var b = this._plotDimensions.height - offsets.top;\n                        this._elem.css('left', a);\n                        this._elem.css('bottom', b);\n                        break;\n                    case 'ne':\n                        var a = this._plotDimensions.width - offsets.right;\n                        var b = offsets.top;\n                        this._elem.css({left:a, top:b});\n                        break;\n                    case 'e':\n                        var a = this._plotDimensions.width - offsets.right;\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({left:a, top:b});\n                        break;\n                    case 'se':\n                        var a = this._plotDimensions.width - offsets.right;\n                        var b = offsets.bottom;\n                        this._elem.css({left:a, bottom:b});\n                        break;\n                    case 's':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        var b = this._plotDimensions.height - offsets.bottom;\n                        this._elem.css({left:a, top:b});\n                        break;\n                    case 'sw':\n                        var a = this._plotDimensions.width - offsets.left;\n                        var b = offsets.bottom;\n                        this._elem.css({right:a, bottom:b});\n                        break;\n                    case 'w':\n                        var a = this._plotDimensions.width - offsets.left;\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({right:a, top:b});\n                        break;\n                    default:  // same as 'se'\n                        var a = offsets.right;\n                        var b = offsets.bottom;\n                        this._elem.css({right:a, bottom:b});\n                        break;\n                }\n            }\n            else {\n                switch (this.location) {\n                    case 'nw':\n                        this._elem.css({left:0, top:offsets.top});\n                        break;\n                    case 'n':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        this._elem.css({left: a, top:offsets.top});\n                        break;\n                    case 'ne':\n                        this._elem.css({right:0, top:offsets.top});\n                        break;\n                    case 'e':\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({right:offsets.right, top:b});\n                        break;\n                    case 'se':\n                        this._elem.css({right:offsets.right, bottom:offsets.bottom});\n                        break;\n                    case 's':\n                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;\n                        this._elem.css({left: a, bottom:offsets.bottom});\n                        break;\n                    case 'sw':\n                        this._elem.css({left:offsets.left, bottom:offsets.bottom});\n                        break;\n                    case 'w':\n                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;\n                        this._elem.css({left:offsets.left, top:b});\n                        break;\n                    default:  // same as 'se'\n                        this._elem.css({right:offsets.right, bottom:offsets.bottom});\n                        break;\n                }\n            }\n        } \n    };\n\n    /**\n     * Class: $.jqplot.ThemeEngine\n     * Theme Engine provides a programatic way to change some of the  more\n     * common jqplot styling options such as fonts, colors and grid options.\n     * A theme engine instance is created with each plot.  The theme engine\n     * manages a collection of themes which can be modified, added to, or \n     * applied to the plot.\n     * \n     * The themeEngine class is not instantiated directly.\n     * When a plot is initialized, the current plot options are scanned\n     * an a default theme named \"Default\" is created.  This theme is\n     * used as the basis for other themes added to the theme engine and\n     * is always available.\n     * \n     * A theme is a simple javascript object with styling parameters for\n     * various entities of the plot.  A theme has the form:\n     * \n     * \n     * > {\n     * >     _name:f \"Default\",\n     * >     target: {\n     * >         backgroundColor: \"transparent\"\n     * >     },\n     * >     legend: {\n     * >         textColor: null,\n     * >         fontFamily: null,\n     * >         fontSize: null,\n     * >         border: null,\n     * >         background: null\n     * >     },\n     * >     title: {\n     * >         textColor: \"rgb(102, 102, 102)\",\n     * >         fontFamily: \"'Trebuchet MS',Arial,Helvetica,sans-serif\",\n     * >         fontSize: \"19.2px\",\n     * >         textAlign: \"center\"\n     * >     },\n     * >     seriesStyles: {},\n     * >     series: [{\n     * >         color: \"#4bb2c5\",\n     * >         lineWidth: 2.5,\n     * >         linePattern: \"solid\",\n     * >         shadow: true,\n     * >         fillColor: \"#4bb2c5\",\n     * >         showMarker: true,\n     * >         markerOptions: {\n     * >             color: \"#4bb2c5\",\n     * >             show: true,\n     * >             style: 'filledCircle',\n     * >             lineWidth: 1.5,\n     * >             size: 4,\n     * >             shadow: true\n     * >         }\n     * >     }],\n     * >     grid: {\n     * >         drawGridlines: true,\n     * >         gridLineColor: \"#cccccc\",\n     * >         gridLineWidth: 1,\n     * >         backgroundColor: \"#fffdf6\",\n     * >         borderColor: \"#999999\",\n     * >         borderWidth: 2,\n     * >         shadow: true\n     * >     },\n     * >     axesStyles: {\n     * >         label: {},\n     * >         ticks: {}\n     * >     },\n     * >     axes: {\n     * >         xaxis: {\n     * >             borderColor: \"#999999\",\n     * >             borderWidth: 2,\n     * >             ticks: {\n     * >                 show: true,\n     * >                 showGridline: true,\n     * >                 showLabel: true,\n     * >                 showMark: true,\n     * >                 size: 4,\n     * >                 textColor: \"\",\n     * >                 whiteSpace: \"nowrap\",\n     * >                 fontSize: \"12px\",\n     * >                 fontFamily: \"'Trebuchet MS',Arial,Helvetica,sans-serif\"\n     * >             },\n     * >             label: {\n     * >                 textColor: \"rgb(102, 102, 102)\",\n     * >                 whiteSpace: \"normal\",\n     * >                 fontSize: \"14.6667px\",\n     * >                 fontFamily: \"'Trebuchet MS',Arial,Helvetica,sans-serif\",\n     * >                 fontWeight: \"400\"\n     * >             }\n     * >         },\n     * >         yaxis: {\n     * >             borderColor: \"#999999\",\n     * >             borderWidth: 2,\n     * >             ticks: {\n     * >                 show: true,\n     * >                 showGridline: true,\n     * >                 showLabel: true,\n     * >                 showMark: true,\n     * >                 size: 4,\n     * >                 textColor: \"\",\n     * >                 whiteSpace: \"nowrap\",\n     * >                 fontSize: \"12px\",\n     * >                 fontFamily: \"'Trebuchet MS',Arial,Helvetica,sans-serif\"\n     * >             },\n     * >             label: {\n     * >                 textColor: null,\n     * >                 whiteSpace: null,\n     * >                 fontSize: null,\n     * >                 fontFamily: null,\n     * >                 fontWeight: null\n     * >             }\n     * >         },\n     * >         x2axis: {...\n     * >         },\n     * >         ...\n     * >         y9axis: {...\n     * >         }\n     * >     }\n     * > }\n     * \n     * \"seriesStyles\" is a style object that will be applied to all series in the plot.\n     * It will forcibly override any styles applied on the individual series.  \"axesStyles\" is\n     * a style object that will be applied to all axes in the plot.  It will also forcibly\n     * override any styles on the individual axes.\n     * \n     * The example shown above has series options for a line series.  Options for other\n     * series types are shown below:\n     * \n     * Bar Series:\n     * \n     * > {\n     * >     color: \"#4bb2c5\",\n     * >     seriesColors: [\"#4bb2c5\", \"#EAA228\", \"#c5b47f\", \"#579575\", \"#839557\", \"#958c12\", \"#953579\", \"#4b5de4\", \"#d8b83f\", \"#ff5800\", \"#0085cc\", \"#c747a3\", \"#cddf54\", \"#FBD178\", \"#26B4E3\", \"#bd70c7\"],\n     * >     lineWidth: 2.5,\n     * >     shadow: true,\n     * >     barPadding: 2,\n     * >     barMargin: 10,\n     * >     barWidth: 15.09375,\n     * >     highlightColors: [\"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\", \"rgb(129,201,214)\"]\n     * > }\n     * \n     * Pie Series:\n     * \n     * > {\n     * >     seriesColors: [\"#4bb2c5\", \"#EAA228\", \"#c5b47f\", \"#579575\", \"#839557\", \"#958c12\", \"#953579\", \"#4b5de4\", \"#d8b83f\", \"#ff5800\", \"#0085cc\", \"#c747a3\", \"#cddf54\", \"#FBD178\", \"#26B4E3\", \"#bd70c7\"],\n     * >     padding: 20,\n     * >     sliceMargin: 0,\n     * >     fill: true,\n     * >     shadow: true,\n     * >     startAngle: 0,\n     * >     lineWidth: 2.5,\n     * >     highlightColors: [\"rgb(129,201,214)\", \"rgb(240,189,104)\", \"rgb(214,202,165)\", \"rgb(137,180,158)\", \"rgb(168,180,137)\", \"rgb(180,174,89)\", \"rgb(180,113,161)\", \"rgb(129,141,236)\", \"rgb(227,205,120)\", \"rgb(255,138,76)\", \"rgb(76,169,219)\", \"rgb(215,126,190)\", \"rgb(220,232,135)\", \"rgb(200,167,96)\", \"rgb(103,202,235)\", \"rgb(208,154,215)\"]\n     * > }\n     * \n     * Funnel Series:\n     * \n     * > {\n     * >     color: \"#4bb2c5\",\n     * >     lineWidth: 2,\n     * >     shadow: true,\n     * >     padding: {\n     * >         top: 20,\n     * >         right: 20,\n     * >         bottom: 20,\n     * >         left: 20\n     * >     },\n     * >     sectionMargin: 6,\n     * >     seriesColors: [\"#4bb2c5\", \"#EAA228\", \"#c5b47f\", \"#579575\", \"#839557\", \"#958c12\", \"#953579\", \"#4b5de4\", \"#d8b83f\", \"#ff5800\", \"#0085cc\", \"#c747a3\", \"#cddf54\", \"#FBD178\", \"#26B4E3\", \"#bd70c7\"],\n     * >     highlightColors: [\"rgb(147,208,220)\", \"rgb(242,199,126)\", \"rgb(220,210,178)\", \"rgb(154,191,172)\", \"rgb(180,191,154)\", \"rgb(191,186,112)\", \"rgb(191,133,174)\", \"rgb(147,157,238)\", \"rgb(231,212,139)\", \"rgb(255,154,102)\", \"rgb(102,181,224)\", \"rgb(221,144,199)\", \"rgb(225,235,152)\", \"rgb(200,167,96)\", \"rgb(124,210,238)\", \"rgb(215,169,221)\"]\n     * > }\n     * \n     */\n    $.jqplot.ThemeEngine = function(){\n        // Group: Properties\n        //\n        // prop: themes\n        // hash of themes managed by the theme engine.  \n        // Indexed by theme name.\n        this.themes = {};\n        // prop: activeTheme\n        // Pointer to currently active theme\n        this.activeTheme=null;\n        \n    };\n    \n    // called with scope of plot\n    $.jqplot.ThemeEngine.prototype.init = function() {\n        // get the Default theme from the current plot settings.\n        var th = new $.jqplot.Theme({_name:'Default'});\n        var n, i, nn;\n        \n        for (n in th.target) {\n            if (n == \"textColor\") {\n                th.target[n] = this.target.css('color');\n            }\n            else {\n                th.target[n] = this.target.css(n);\n            }\n        }\n        \n        if (this.title.show && this.title._elem) {\n            for (n in th.title) {\n                if (n == \"textColor\") {\n                    th.title[n] = this.title._elem.css('color');\n                }\n                else {\n                    th.title[n] = this.title._elem.css(n);\n                }\n            }\n        }\n        \n        for (n in th.grid) {\n            th.grid[n] = this.grid[n];\n        }\n        if (th.grid.backgroundColor == null && this.grid.background != null) {\n            th.grid.backgroundColor = this.grid.background;\n        }\n        if (this.legend.show && this.legend._elem) {\n            for (n in th.legend) {\n                if (n == 'textColor') {\n                    th.legend[n] = this.legend._elem.css('color');\n                }\n                else {\n                    th.legend[n] = this.legend._elem.css(n);\n                }\n            }\n        }\n        var s;\n        \n        for (i=0; i<this.series.length; i++) {\n            s = this.series[i];\n            if (s.renderer.constructor == $.jqplot.LineRenderer) {\n                th.series.push(new LineSeriesProperties());\n            }\n            else if (s.renderer.constructor == $.jqplot.BarRenderer) {\n                th.series.push(new BarSeriesProperties());\n            }\n            else if (s.renderer.constructor == $.jqplot.PieRenderer) {\n                th.series.push(new PieSeriesProperties());\n            }\n            else if (s.renderer.constructor == $.jqplot.DonutRenderer) {\n                th.series.push(new DonutSeriesProperties());\n            }\n            else if (s.renderer.constructor == $.jqplot.FunnelRenderer) {\n                th.series.push(new FunnelSeriesProperties());\n            }\n            else if (s.renderer.constructor == $.jqplot.MeterGaugeRenderer) {\n                th.series.push(new MeterSeriesProperties());\n            }\n            else {\n                th.series.push({});\n            }\n            for (n in th.series[i]) {\n                th.series[i][n] = s[n];\n            }\n        }\n        var a, ax;\n        for (n in this.axes) {\n            ax = this.axes[n];\n            a = th.axes[n] = new AxisProperties();\n            a.borderColor = ax.borderColor;\n            a.borderWidth = ax.borderWidth;\n            if (ax._ticks && ax._ticks[0]) {\n                for (nn in a.ticks) {\n                    if (ax._ticks[0].hasOwnProperty(nn)) {\n                        a.ticks[nn] = ax._ticks[0][nn];\n                    }\n                    else if (ax._ticks[0]._elem){\n                        a.ticks[nn] = ax._ticks[0]._elem.css(nn);\n                    }\n                }\n            }\n            if (ax._label && ax._label.show) {\n                for (nn in a.label) {\n                    // a.label[nn] = ax._label._elem.css(nn);\n                    if (ax._label[nn]) {\n                        a.label[nn] = ax._label[nn];\n                    }\n                    else if (ax._label._elem){\n                        if (nn == 'textColor') {\n                            a.label[nn] = ax._label._elem.css('color');\n                        }\n                        else {\n                            a.label[nn] = ax._label._elem.css(nn);\n                        }\n                    }\n                }\n            }\n        }\n        this.themeEngine._add(th);\n        this.themeEngine.activeTheme  = this.themeEngine.themes[th._name];\n    };\n    /**\n     * Group: methods\n     * \n     * method: get\n     * \n     * Get and return the named theme or the active theme if no name given.\n     * \n     * parameter:\n     * \n     * name - name of theme to get.\n     * \n     * returns:\n     * \n     * Theme instance of given name.\n     */   \n    $.jqplot.ThemeEngine.prototype.get = function(name) {\n        if (!name) {\n            // return the active theme\n            return this.activeTheme;\n        }\n        else {\n            return this.themes[name];\n        }\n    };\n    \n    function numericalOrder(a,b) { return a-b; }\n    \n    /**\n     * method: getThemeNames\n     * \n     * Return the list of theme names in this manager in alpha-numerical order.\n     * \n     * parameter:\n     * \n     * None\n     * \n     * returns:\n     * \n     * A the list of theme names in this manager in alpha-numerical order.\n     */       \n    $.jqplot.ThemeEngine.prototype.getThemeNames = function() {\n        var tn = [];\n        for (var n in this.themes) {\n            tn.push(n);\n        }\n        return tn.sort(numericalOrder);\n    };\n\n    /**\n     * method: getThemes\n     * \n     * Return a list of themes in alpha-numerical order by name.\n     * \n     * parameter:\n     * \n     * None\n     * \n     * returns:\n     * \n     * A list of themes in alpha-numerical order by name.\n     */ \n    $.jqplot.ThemeEngine.prototype.getThemes = function() {\n        var tn = [];\n        var themes = [];\n        for (var n in this.themes) {\n            tn.push(n);\n        }\n        tn.sort(numericalOrder);\n        for (var i=0; i<tn.length; i++) {\n            themes.push(this.themes[tn[i]]);\n        }\n        return themes;\n    };\n    \n    $.jqplot.ThemeEngine.prototype.activate = function(plot, name) {\n        // sometimes need to redraw whole plot.\n        var redrawPlot = false;\n        if (!name && this.activeTheme && this.activeTheme._name) {\n            name = this.activeTheme._name;\n        }\n        if (!this.themes.hasOwnProperty(name)) {\n            throw new Error(\"No theme of that name\");\n        }\n        else {\n            var th = this.themes[name];\n            this.activeTheme = th;\n            var val, checkBorderColor = false, checkBorderWidth = false;\n            var arr = ['xaxis', 'x2axis', 'yaxis', 'y2axis'];\n            \n            for (i=0; i<arr.length; i++) {\n                var ax = arr[i];\n                if (th.axesStyles.borderColor != null) {\n                    plot.axes[ax].borderColor = th.axesStyles.borderColor;\n                }\n                if (th.axesStyles.borderWidth != null) {\n                    plot.axes[ax].borderWidth = th.axesStyles.borderWidth;\n                }\n            }\n            \n            for (var axname in plot.axes) {\n                var axis = plot.axes[axname];\n                if (axis.show) {\n                    var thaxis = th.axes[axname] || {};\n                    var thaxstyle = th.axesStyles;\n                    var thax = $.jqplot.extend(true, {}, thaxis, thaxstyle);\n                    val = (th.axesStyles.borderColor != null) ? th.axesStyles.borderColor : thax.borderColor;\n                    if (thax.borderColor != null) {\n                        axis.borderColor = thax.borderColor;\n                        redrawPlot = true;\n                    }\n                    val = (th.axesStyles.borderWidth != null) ? th.axesStyles.borderWidth : thax.borderWidth;\n                    if (thax.borderWidth != null) {\n                        axis.borderWidth = thax.borderWidth;\n                        redrawPlot = true;\n                    }\n                    if (axis._ticks && axis._ticks[0]) {\n                        for (var nn in thax.ticks) {\n                            // val = null;\n                            // if (th.axesStyles.ticks && th.axesStyles.ticks[nn] != null) {\n                            //     val = th.axesStyles.ticks[nn];\n                            // }\n                            // else if (thax.ticks[nn] != null){\n                            //     val = thax.ticks[nn]\n                            // }\n                            val = thax.ticks[nn];\n                            if (val != null) {\n                                axis.tickOptions[nn] = val;\n                                axis._ticks = [];\n                                redrawPlot = true;\n                            }\n                        }\n                    }\n                    if (axis._label && axis._label.show) {\n                        for (var nn in thax.label) {\n                            // val = null;\n                            // if (th.axesStyles.label && th.axesStyles.label[nn] != null) {\n                            //     val = th.axesStyles.label[nn];\n                            // }\n                            // else if (thax.label && thax.label[nn] != null){\n                            //     val = thax.label[nn]\n                            // }\n                            val = thax.label[nn];\n                            if (val != null) {\n                                axis.labelOptions[nn] = val;\n                                redrawPlot = true;\n                            }\n                        }\n                    }\n                    \n                }\n            }            \n            \n            for (var n in th.grid) {\n                if (th.grid[n] != null) {\n                    plot.grid[n] = th.grid[n];\n                }\n            }\n            if (!redrawPlot) {\n                plot.grid.draw();\n            }\n            \n            if (plot.legend.show) { \n                for (n in th.legend) {\n                    if (th.legend[n] != null) {\n                        plot.legend[n] = th.legend[n];\n                    }\n                }\n            }\n            if (plot.title.show) {\n                for (n in th.title) {\n                    if (th.title[n] != null) {\n                        plot.title[n] = th.title[n];\n                    }\n                }\n            }\n            \n            var i;\n            for (i=0; i<th.series.length; i++) {\n                var opts = {};\n                var redrawSeries = false;\n                for (n in th.series[i]) {\n                    val = (th.seriesStyles[n] != null) ? th.seriesStyles[n] : th.series[i][n];\n                    if (val != null) {\n                        opts[n] = val;\n                        if (n == 'color') {\n                            plot.series[i].renderer.shapeRenderer.fillStyle = val;\n                            plot.series[i].renderer.shapeRenderer.strokeStyle = val;\n                            plot.series[i][n] = val;\n                        }\n                        else if ((n == 'lineWidth') || (n == 'linePattern')) {\n                            plot.series[i].renderer.shapeRenderer[n] = val;\n                            plot.series[i][n] = val;\n                        }\n                        else if (n == 'markerOptions') {\n                            merge (plot.series[i].markerOptions, val);\n                            merge (plot.series[i].markerRenderer, val);\n                        }\n                        else {\n                            plot.series[i][n] = val;\n                        }\n                        redrawPlot = true;\n                    }\n                }\n            }\n            \n            if (redrawPlot) {\n                plot.target.empty();\n                plot.draw();\n            }\n            \n            for (n in th.target) {\n                if (th.target[n] != null) {\n                    plot.target.css(n, th.target[n]);\n                }\n            }\n        }\n        \n    };\n    \n    $.jqplot.ThemeEngine.prototype._add = function(theme, name) {\n        if (name) {\n            theme._name = name;\n        }\n        if (!theme._name) {\n            theme._name = Date.parse(new Date());\n        }\n        if (!this.themes.hasOwnProperty(theme._name)) {\n            this.themes[theme._name] = theme;\n        }\n        else {\n            throw new Error(\"jqplot.ThemeEngine Error: Theme already in use\");\n        }\n    };\n    \n    // method remove\n    // Delete the named theme, return true on success, false on failure.\n    \n\n    /**\n     * method: remove\n     * \n     * Remove the given theme from the themeEngine.\n     * \n     * parameters:\n     * \n     * name - name of the theme to remove.\n     * \n     * returns:\n     * \n     * true on success, false on failure.\n     */\n    $.jqplot.ThemeEngine.prototype.remove = function(name) {\n        if (name == 'Default') {\n            return false;\n        }\n        return delete this.themes[name];\n    };\n\n    /**\n     * method: newTheme\n     * \n     * Create a new theme based on the default theme, adding it the themeEngine.\n     * \n     * parameters:\n     * \n     * name - name of the new theme.\n     * obj - optional object of styles to be applied to this new theme.\n     * \n     * returns:\n     * \n     * new Theme object.\n     */\n    $.jqplot.ThemeEngine.prototype.newTheme = function(name, obj) {\n        if (typeof(name) == 'object') {\n            obj = obj || name;\n            name = null;\n        }\n        if (obj && obj._name) {\n            name = obj._name;\n        }\n        else {\n            name = name || Date.parse(new Date());\n        }\n        // var th = new $.jqplot.Theme(name);\n        var th = this.copy(this.themes['Default']._name, name);\n        $.jqplot.extend(th, obj);\n        return th;\n    };\n    \n    // function clone(obj) {\n    //     return eval(obj.toSource());\n    // }\n    \n    function clone(obj){\n        if(obj == null || typeof(obj) != 'object'){\n            return obj;\n        }\n    \n        var temp = new obj.constructor();\n        for(var key in obj){\n            temp[key] = clone(obj[key]);\n        }   \n        return temp;\n    }\n    \n    $.jqplot.clone = clone;\n    \n    function merge(obj1, obj2) {\n        if (obj2 ==  null || typeof(obj2) != 'object') {\n            return;\n        }\n        for (var key in obj2) {\n            if (key == 'highlightColors') {\n                obj1[key] = clone(obj2[key]);\n            }\n            if (obj2[key] != null && typeof(obj2[key]) == 'object') {\n                if (!obj1.hasOwnProperty(key)) {\n                    obj1[key] = {};\n                }\n                merge(obj1[key], obj2[key]);\n            }\n            else {\n                obj1[key] = obj2[key];\n            }\n        }\n    }\n    \n    $.jqplot.merge = merge;\n    \n        // Use the jQuery 1.3.2 extend function since behaviour in jQuery 1.4 seems problematic\n    $.jqplot.extend = function() {\n        // copy reference to target object\n        var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;\n\n        // Handle a deep copy situation\n        if ( typeof target === \"boolean\" ) {\n            deep = target;\n            target = arguments[1] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // Handle case when target is a string or something (possible in deep copy)\n        if ( typeof target !== \"object\" && !toString.call(target) === \"[object Function]\" ) {\n            target = {};\n        }\n\n        for ( ; i < length; i++ ){\n            // Only deal with non-null/undefined values\n            if ( (options = arguments[ i ]) != null ) {\n                // Extend the base object\n                for ( var name in options ) {\n                    var src = target[ name ], copy = options[ name ];\n\n                    // Prevent never-ending loop\n                    if ( target === copy ) {\n                        continue;\n                    }\n\n                    // Recurse if we're merging object values\n                    if ( deep && copy && typeof copy === \"object\" && !copy.nodeType ) {\n                        target[ name ] = $.jqplot.extend( deep, \n                            // Never move original objects, clone them\n                            src || ( copy.length != null ? [ ] : { } )\n                        , copy );\n                    }\n                    // Don't bring in undefined values\n                    else if ( copy !== undefined ) {\n                        target[ name ] = copy;\n                    }\n                }\n            }\n        }\n        // Return the modified object\n        return target;\n    };\n\n    /**\n     * method: rename\n     * \n     * Rename a theme.\n     * \n     * parameters:\n     * \n     * oldName - current name of the theme.\n     * newName - desired name of the theme.\n     * \n     * returns:\n     * \n     * new Theme object.\n     */\n    $.jqplot.ThemeEngine.prototype.rename = function (oldName, newName) {\n        if (oldName == 'Default' || newName == 'Default') {\n            throw new Error (\"jqplot.ThemeEngine Error: Cannot rename from/to Default\");\n        }\n        if (this.themes.hasOwnProperty(newName)) {\n            throw new Error (\"jqplot.ThemeEngine Error: New name already in use.\");\n        }\n        else if (this.themes.hasOwnProperty(oldName)) {\n            var th = this.copy (oldName, newName);\n            this.remove(oldName);\n            return th;\n        }\n        throw new Error(\"jqplot.ThemeEngine Error: Old name or new name invalid\");\n    };\n\n    /**\n     * method: copy\n     * \n     * Create a copy of an existing theme in the themeEngine, adding it the themeEngine.\n     * \n     * parameters:\n     * \n     * sourceName - name of the existing theme.\n     * targetName - name of the copy.\n     * obj - optional object of style parameter to apply to the new theme.\n     * \n     * returns:\n     * \n     * new Theme object.\n     */\n    $.jqplot.ThemeEngine.prototype.copy = function (sourceName, targetName, obj) {\n        if (targetName == 'Default') {\n            throw new Error (\"jqplot.ThemeEngine Error: Cannot copy over Default theme\");\n        }\n        if (!this.themes.hasOwnProperty(sourceName)) {\n            var s = \"jqplot.ThemeEngine Error: Source name invalid\";\n            throw new Error(s);\n        }\n        if (this.themes.hasOwnProperty(targetName)) {\n            var s = \"jqplot.ThemeEngine Error: Target name invalid\";\n            throw new Error(s);\n        }\n        else {\n            var th = clone(this.themes[sourceName]);\n            th._name = targetName;\n            $.jqplot.extend(true, th, obj);\n            this._add(th);\n            return th;\n        }\n    };\n    \n    \n    $.jqplot.Theme = function(name, obj) {\n        if (typeof(name) == 'object') {\n            obj = obj || name;\n            name = null;\n        }\n        name = name || Date.parse(new Date());\n        this._name = name;\n        this.target = {\n            backgroundColor: null\n        };\n        this.legend = {\n            textColor: null,\n            fontFamily: null,\n            fontSize: null,\n            border: null,\n            background: null\n        };\n        this.title = {\n            textColor: null,\n            fontFamily: null,\n            fontSize: null,\n            textAlign: null\n        };\n        this.seriesStyles = {};\n        this.series = [];\n        this.grid = {\n            drawGridlines: null,\n            gridLineColor: null,\n            gridLineWidth: null,\n            backgroundColor: null,\n            borderColor: null,\n            borderWidth: null,\n            shadow: null\n        };\n        this.axesStyles = {label:{}, ticks:{}};\n        this.axes = {};\n        if (typeof(obj) == 'string') {\n            this._name = obj;\n        }\n        else if(typeof(obj) == 'object') {\n            $.jqplot.extend(true, this, obj);\n        }\n    };\n    \n    var AxisProperties = function() {\n        this.borderColor = null;\n        this.borderWidth = null;\n        this.ticks = new AxisTicks();\n        this.label = new AxisLabel();\n    };\n    \n    var AxisTicks = function() {\n        this.show = null;\n        this.showGridline = null;\n        this.showLabel = null;\n        this.showMark = null;\n        this.size = null;\n        this.textColor = null;\n        this.whiteSpace = null;\n        this.fontSize = null;\n        this.fontFamily = null;\n    };\n    \n    var AxisLabel = function() {\n        this.textColor = null;\n        this.whiteSpace = null;\n        this.fontSize = null;\n        this.fontFamily = null;\n        this.fontWeight = null;\n    };\n    \n    var LineSeriesProperties = function() {\n        this.color=null;\n        this.lineWidth=null;\n        this.linePattern=null;\n        this.shadow=null;\n        this.fillColor=null;\n        this.showMarker=null;\n        this.markerOptions = new MarkerOptions();\n    };\n    \n    var MarkerOptions = function() {\n        this.show = null;\n        this.style = null;\n        this.lineWidth = null;\n        this.size = null;\n        this.color = null;\n        this.shadow = null;\n    };\n    \n    var BarSeriesProperties = function() {\n        this.color=null;\n        this.seriesColors=null;\n        this.lineWidth=null;\n        this.shadow=null;\n        this.barPadding=null;\n        this.barMargin=null;\n        this.barWidth=null;\n        this.highlightColors=null;\n    };\n    \n    var PieSeriesProperties = function() {\n        this.seriesColors=null;\n        this.padding=null;\n        this.sliceMargin=null;\n        this.fill=null;\n        this.shadow=null;\n        this.startAngle=null;\n        this.lineWidth=null;\n        this.highlightColors=null;\n    };\n    \n    var DonutSeriesProperties = function() {\n        this.seriesColors=null;\n        this.padding=null;\n        this.sliceMargin=null;\n        this.fill=null;\n        this.shadow=null;\n        this.startAngle=null;\n        this.lineWidth=null;\n        this.innerDiameter=null;\n        this.thickness=null;\n        this.ringMargin=null;\n        this.highlightColors=null;\n    };\n    \n    var FunnelSeriesProperties = function() {\n        this.color=null;\n        this.lineWidth=null;\n        this.shadow=null;\n        this.padding=null;\n        this.sectionMargin=null;\n        this.seriesColors=null;\n        this.highlightColors=null;\n    };\n    \n    var MeterSeriesProperties = function() {\n        this.padding=null;\n        this.backgroundColor=null;\n        this.ringColor=null;\n        this.tickColor=null;\n        this.ringWidth=null;\n        this.intervalColors=null;\n        this.intervalInnerRadius=null;\n        this.intervalOuterRadius=null;\n        this.hubRadius=null;\n        this.needleThickness=null;\n        this.needlePad=null;\n    };\n        \n\n\n\n    $.fn.jqplotChildText = function() {\n        return $(this).contents().filter(function() {\n            return this.nodeType == 3;  // Node.TEXT_NODE not defined in I7\n        }).text();\n    };\n\n    // Returns font style as abbreviation for \"font\" property.\n    $.fn.jqplotGetComputedFontStyle = function() {\n        var css = window.getComputedStyle ?  window.getComputedStyle(this[0], \"\") : this[0].currentStyle;\n        var attrs = css['font-style'] ? ['font-style', 'font-weight', 'font-size', 'font-family'] : ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily'];\n        var style = [];\n\n        for (var i=0 ; i < attrs.length; ++i) {\n            var attr = String(css[attrs[i]]);\n\n            if (attr && attr != 'normal') {\n                style.push(attr);\n            }\n        }\n        return style.join(' ');\n    };\n\n    /**\n     * Namespace: $.fn\n     * jQuery namespace to attach functions to jQuery elements.\n     *  \n     */\n\n    $.fn.jqplotToImageCanvas = function(options) {\n\n        options = options || {};\n        var x_offset = (options.x_offset == null) ? 0 : options.x_offset;\n        var y_offset = (options.y_offset == null) ? 0 : options.y_offset;\n        var backgroundColor = (options.backgroundColor == null) ? 'rgb(255,255,255)' : options.backgroundColor;\n\n        if ($(this).width() == 0 || $(this).height() == 0) {\n            return null;\n        }\n\n        // excanvas and hence IE < 9 do not support toDataURL and cannot export images.\n        if ($.jqplot.use_excanvas) {\n            return null;\n        }\n        \n        var newCanvas = document.createElement(\"canvas\");\n        var h = $(this).outerHeight(true);\n        var w = $(this).outerWidth(true);\n        var offs = $(this).offset();\n        var plotleft = offs.left;\n        var plottop = offs.top;\n        var transx = 0, transy = 0;\n\n        // have to check if any elements are hanging outside of plot area before rendering,\n        // since changing width of canvas will erase canvas.\n\n        var clses = ['jqplot-table-legend', 'jqplot-xaxis-tick', 'jqplot-x2axis-tick', 'jqplot-yaxis-tick', 'jqplot-y2axis-tick', 'jqplot-y3axis-tick', \n        'jqplot-y4axis-tick', 'jqplot-y5axis-tick', 'jqplot-y6axis-tick', 'jqplot-y7axis-tick', 'jqplot-y8axis-tick', 'jqplot-y9axis-tick',\n        'jqplot-xaxis-label', 'jqplot-x2axis-label', 'jqplot-yaxis-label', 'jqplot-y2axis-label', 'jqplot-y3axis-label', 'jqplot-y4axis-label', \n        'jqplot-y5axis-label', 'jqplot-y6axis-label', 'jqplot-y7axis-label', 'jqplot-y8axis-label', 'jqplot-y9axis-label' ];\n\n        var temptop, templeft, tempbottom, tempright;\n\n        for (var i = 0; i < clses.length; i++) {\n            $(this).find('.'+clses[i]).each(function() {\n                temptop = $(this).offset().top - plottop;\n                templeft = $(this).offset().left - plotleft;\n                tempright = templeft + $(this).outerWidth(true) + transx;\n                tempbottom = temptop + $(this).outerHeight(true) + transy;\n                if (templeft < -transx) {\n                    w = w - transx - templeft;\n                    transx = -templeft;\n                }\n                if (temptop < -transy) {\n                    h = h - transy - temptop;\n                    transy = - temptop;\n                }\n                if (tempright > w) {\n                    w = tempright;\n                }\n                if (tempbottom > h) {\n                    h =  tempbottom;\n                }\n            });\n        }\n\n        newCanvas.width = w + Number(x_offset);\n        newCanvas.height = h + Number(y_offset);\n\n        var newContext = newCanvas.getContext(\"2d\"); \n\n        newContext.save();\n        newContext.fillStyle = backgroundColor;\n        newContext.fillRect(0,0, newCanvas.width, newCanvas.height);\n        newContext.restore();\n\n        newContext.translate(transx, transy);\n        newContext.textAlign = 'left';\n        newContext.textBaseline = 'top';\n\n        function getLineheight(el) {\n            var lineheight = parseInt($(el).css('line-height'), 10);\n\n            if (isNaN(lineheight)) {\n                lineheight = parseInt($(el).css('font-size'), 10) * 1.2;\n            }\n            return lineheight;\n        }\n\n        function writeWrappedText (el, context, text, left, top, canvasWidth) {\n            var lineheight = getLineheight(el);\n            var tagwidth = $(el).innerWidth();\n            var tagheight = $(el).innerHeight();\n            var words = text.split(/\\s+/);\n            var wl = words.length;\n            var w = '';\n            var breaks = [];\n            var temptop = top;\n            var templeft = left;\n\n            for (var i=0; i<wl; i++) {\n                w += words[i];\n                if (context.measureText(w).width > tagwidth && w.length > words[i].length) {\n                    breaks.push(i);\n                    w = '';\n                    i--;\n                }   \n            }\n            if (breaks.length === 0) {\n                // center text if necessary\n                if ($(el).css('textAlign') === 'center') {\n                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;\n                }\n                context.fillText(text, templeft, top);\n            }\n            else {\n                w = words.slice(0, breaks[0]).join(' ');\n                // center text if necessary\n                if ($(el).css('textAlign') === 'center') {\n                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;\n                }\n                context.fillText(w, templeft, temptop);\n                temptop += lineheight;\n                for (var i=1, l=breaks.length; i<l; i++) {\n                    w = words.slice(breaks[i-1], breaks[i]).join(' ');\n                    // center text if necessary\n                    if ($(el).css('textAlign') === 'center') {\n                        templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;\n                    }\n                    context.fillText(w, templeft, temptop);\n                    temptop += lineheight;\n                }\n                w = words.slice(breaks[i-1], words.length).join(' ');\n                // center text if necessary\n                if ($(el).css('textAlign') === 'center') {\n                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;\n                }\n                context.fillText(w, templeft, temptop);\n            }\n\n        }\n\n        function _jqpToImage(el, x_offset, y_offset) {\n            var tagname = el.tagName.toLowerCase();\n            var p = $(el).position();\n            var css = window.getComputedStyle ?  window.getComputedStyle(el, \"\") : el.currentStyle; // for IE < 9\n            var left = x_offset + p.left + parseInt(css.marginLeft, 10) + parseInt(css.borderLeftWidth, 10) + parseInt(css.paddingLeft, 10);\n            var top = y_offset + p.top + parseInt(css.marginTop, 10) + parseInt(css.borderTopWidth, 10)+ parseInt(css.paddingTop, 10);\n            var w = newCanvas.width;\n            // var left = x_offset + p.left + $(el).css('marginLeft') + $(el).css('borderLeftWidth') \n\n            // somehow in here, for divs within divs, the width of the inner div should be used instead of the canvas.\n\n            if ((tagname == 'div' || tagname == 'span') && !$(el).hasClass('jqplot-highlighter-tooltip') && !$(el).hasClass('jqplot-canvasOverlay-tooltip')) {\n                $(el).children().each(function() {\n                    _jqpToImage(this, left, top);\n                });\n                var text = $(el).jqplotChildText();\n\n                if (text) {\n                    newContext.font = $(el).jqplotGetComputedFontStyle();\n                    newContext.fillStyle = $(el).css('color');\n\n                    writeWrappedText(el, newContext, text, left, top, w);\n                }\n            }\n\n            // handle the standard table legend\n\n            else if (tagname === 'table' && $(el).hasClass('jqplot-table-legend')) {\n                newContext.strokeStyle = $(el).css('border-top-color');\n                newContext.fillStyle = $(el).css('background-color');\n                newContext.fillRect(left, top, $(el).innerWidth(), $(el).innerHeight());\n                if (parseInt($(el).css('border-top-width'), 10) > 0) {\n                    newContext.strokeRect(left, top, $(el).innerWidth(), $(el).innerHeight());\n                }\n\n                // find all the swatches\n                $(el).find('div.jqplot-table-legend-swatch-outline').each(function() {\n                    // get the first div and stroke it\n                    var elem = $(this);\n                    newContext.strokeStyle = elem.css('border-top-color');\n                    var l = left + elem.position().left;\n                    var t = top + elem.position().top;\n                    newContext.strokeRect(l, t, elem.innerWidth(), elem.innerHeight());\n\n                    // now fill the swatch\n                    \n                    l += parseInt(elem.css('padding-left'), 10);\n                    t += parseInt(elem.css('padding-top'), 10);\n                    var h = elem.innerHeight() - 2 * parseInt(elem.css('padding-top'), 10);\n                    var w = elem.innerWidth() - 2 * parseInt(elem.css('padding-left'), 10);\n\n                    var swatch = elem.children('div.jqplot-table-legend-swatch');\n                    newContext.fillStyle = swatch.css('background-color');\n                    newContext.fillRect(l, t, w, h);\n                });\n\n                // now add text\n\n                $(el).find('td.jqplot-table-legend-label').each(function(){\n                    var elem = $(this);\n                    var l = left + elem.position().left;\n                    var t = top + elem.position().top + parseInt(elem.css('padding-top'), 10);\n                    newContext.font = elem.jqplotGetComputedFontStyle();\n                    newContext.fillStyle = elem.css('color');\n                    writeWrappedText(elem, newContext, elem.text(), l, t, w);\n                });\n\n                var elem = null;\n            }\n\n            else if (tagname == 'canvas') {\n                newContext.drawImage(el, left, top);\n            }\n        }\n        $(this).children().each(function() {\n            _jqpToImage(this, x_offset, y_offset);\n        });\n        return newCanvas;\n    };\n\n    // return the raw image data string.\n    // Should work on canvas supporting browsers.\n    $.fn.jqplotToImageStr = function(options) {\n        var imgCanvas = $(this).jqplotToImageCanvas(options);\n        if (imgCanvas) {\n            return imgCanvas.toDataURL(\"image/png\");\n        }\n        else {\n            return null;\n        }\n    };\n\n    // return a DOM <img> element and return it.\n    // Should work on canvas supporting browsers.\n    $.fn.jqplotToImageElem = function(options) {\n        var elem = document.createElement(\"img\");\n        var str = $(this).jqplotToImageStr(options);\n        elem.src = str;\n        return elem;\n    };\n\n    // return a string for an <img> element and return it.\n    // Should work on canvas supporting browsers.\n    $.fn.jqplotToImageElemStr = function(options) {\n        var str = '<img src='+$(this).jqplotToImageStr(options)+' />';\n        return str;\n    };\n\n    // Not guaranteed to work, even on canvas supporting browsers due to \n    // limitations with location.href and browser support.\n    $.fn.jqplotSaveImage = function() {\n        var imgData = $(this).jqplotToImageStr({});\n        if (imgData) {\n            window.location.href = imgData.replace(\"image/png\", \"image/octet-stream\");\n        }\n\n    };\n\n    // Not guaranteed to work, even on canvas supporting browsers due to\n    // limitations with window.open and arbitrary data.\n    $.fn.jqplotViewImage = function() {\n        var imgStr = $(this).jqplotToImageElemStr({});\n        var imgData = $(this).jqplotToImageStr({});\n        if (imgStr) {\n            var w = window.open('');\n            w.document.open(\"image/png\");\n            w.document.write(imgStr);\n            w.document.close();\n            w = null;\n        }\n    };\n    \n\n\n\n    /** \n     * @description\n     * <p>Object with extended date parsing and formatting capabilities.\n     * This library borrows many concepts and ideas from the Date Instance \n     * Methods by Ken Snyder along with some parts of Ken's actual code.</p>\n     *\n     * <p>jsDate takes a different approach by not extending the built-in \n     * Date Object, improving date parsing, allowing for multiple formatting \n     * syntaxes and multiple and more easily expandable localization.</p>\n     * \n     * @author Chris Leonello\n     * @date #date#\n     * @version #VERSION#\n     * @copyright (c) 2010-2015 Chris Leonello\n     * jsDate is currently available for use in all personal or commercial projects \n     * under both the MIT and GPL version 2.0 licenses. This means that you can \n     * choose the license that best suits your project and use it accordingly.\n     * \n     * <p>Ken's original Date Instance Methods and copyright notice:</p>\n     * <pre>\n     * Ken Snyder (ken d snyder at gmail dot com)\n     * 2008-09-10\n     * version 2.0.2 (http://kendsnyder.com/sandbox/date/)     \n     * Creative Commons Attribution License 3.0 (http://creativecommons.org/licenses/by/3.0/)\n     * </pre>\n     * \n     * @class\n     * @name jsDate\n     * @param  {String | Number | Array | Date&nbsp;Object | Options&nbsp;Object} arguments Optional arguments, either a parsable date/time string,\n     * a JavaScript timestamp, an array of numbers of form [year, month, day, hours, minutes, seconds, milliseconds],\n     * a Date object, or an options object of form {syntax: \"perl\", date:some Date} where all options are optional.\n     */\n     \n    var jsDate = function () {\n    \n        this.syntax = jsDate.config.syntax;\n        this._type = \"jsDate\";\n        this.proxy = new Date();\n        this.options = {};\n        this.locale = jsDate.regional.getLocale();\n        this.formatString = '';\n        this.defaultCentury = jsDate.config.defaultCentury;\n\n        switch ( arguments.length ) {\n            case 0:\n                break;\n            case 1:\n                // other objects either won't have a _type property or,\n                // if they do, it shouldn't be set to \"jsDate\", so\n                // assume it is an options argument.\n                if (get_type(arguments[0]) == \"[object Object]\" && arguments[0]._type != \"jsDate\") {\n                    var opts = this.options = arguments[0];\n                    this.syntax = opts.syntax || this.syntax;\n                    this.defaultCentury = opts.defaultCentury || this.defaultCentury;\n                    this.proxy = jsDate.createDate(opts.date);\n                }\n                else {\n                    this.proxy = jsDate.createDate(arguments[0]);\n                }\n                break;\n            default:\n                var a = [];\n                for ( var i=0; i<arguments.length; i++ ) {\n                    a.push(arguments[i]);\n                }\n                // this should be the current date/time?\n                this.proxy = new Date();\n                this.proxy.setFullYear.apply( this.proxy, a.slice(0,3) );\n                if ( a.slice(3).length ) {\n                    this.proxy.setHours.apply( this.proxy, a.slice(3) );\n                }\n                break;\n        }\n    };\n    \n    /**\n     * @namespace Configuration options that will be used as defaults for all instances on the page.\n     * @property {String} defaultLocale The default locale to use [en].\n     * @property {String} syntax The default syntax to use [perl].\n     * @property {Number} defaultCentury The default centry for 2 digit dates.\n     */\n    jsDate.config = {\n        defaultLocale: 'en',\n        syntax: 'perl',\n        defaultCentury: 1900\n    };\n        \n    /**\n     * Add an arbitrary amount to the currently stored date\n     * \n     * @param {Number} number      \n     * @param {String} unit\n     * @returns {jsDate}       \n     */\n     \n    jsDate.prototype.add = function(number, unit) {\n        var factor = multipliers[unit] || multipliers.day;\n        if (typeof factor == 'number') {\n            this.proxy.setTime(this.proxy.getTime() + (factor * number));\n        } else {\n            factor.add(this, number);\n        }\n        return this;\n    };\n        \n    /**\n     * Create a new jqplot.date object with the same date\n     * \n     * @returns {jsDate}\n     */  \n     \n    jsDate.prototype.clone = function() {\n            return new jsDate(this.proxy.getTime());\n    };\n\n    /**\n     * Get the UTC TimeZone Offset of this date in milliseconds.\n     *\n     * @returns {Number}\n     */\n\n    jsDate.prototype.getUtcOffset = function() {\n        return this.proxy.getTimezoneOffset() * 60000;\n    };\n\n    /**\n     * Find the difference between this jsDate and another date.\n     * \n     * @param {String| Number| Array| jsDate&nbsp;Object| Date&nbsp;Object} dateObj\n     * @param {String} unit\n     * @param {Boolean} allowDecimal\n     * @returns {Number} Number of units difference between dates.\n     */\n     \n    jsDate.prototype.diff = function(dateObj, unit, allowDecimal) {\n        // ensure we have a Date object\n        dateObj = new jsDate(dateObj);\n        if (dateObj === null) {\n            return null;\n        }\n        // get the multiplying factor integer or factor function\n        var factor = multipliers[unit] || multipliers.day;\n        if (typeof factor == 'number') {\n            // multiply\n            var unitDiff = (this.proxy.getTime() - dateObj.proxy.getTime()) / factor;\n        } else {\n            // run function\n            var unitDiff = factor.diff(this.proxy, dateObj.proxy);\n        }\n        // if decimals are not allowed, round toward zero\n        return (allowDecimal ? unitDiff : Math[unitDiff > 0 ? 'floor' : 'ceil'](unitDiff));          \n    };\n    \n    /**\n     * Get the abbreviated name of the current week day\n     * \n     * @returns {String}\n     */   \n     \n    jsDate.prototype.getAbbrDayName = function() {\n        return jsDate.regional[this.locale][\"dayNamesShort\"][this.proxy.getDay()];\n    };\n    \n    /**\n     * Get the abbreviated name of the current month\n     * \n     * @returns {String}\n     */\n     \n    jsDate.prototype.getAbbrMonthName = function() {\n        return jsDate.regional[this.locale][\"monthNamesShort\"][this.proxy.getMonth()];\n    };\n    \n    /**\n     * Get UPPER CASE AM or PM for the current time\n     * \n     * @returns {String}\n     */\n     \n    jsDate.prototype.getAMPM = function() {\n        return this.proxy.getHours() >= 12 ? 'PM' : 'AM';\n    };\n    \n    /**\n     * Get lower case am or pm for the current time\n     * \n     * @returns {String}\n     */\n     \n    jsDate.prototype.getAmPm = function() {\n        return this.proxy.getHours() >= 12 ? 'pm' : 'am';\n    };\n    \n    /**\n     * Get the century (19 for 20th Century)\n     *\n     * @returns {Integer} Century (19 for 20th century).\n     */\n    jsDate.prototype.getCentury = function() { \n        return parseInt(this.proxy.getFullYear()/100, 10);\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getDate = function() {\n        return this.proxy.getDate();\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getDay = function() {\n        return this.proxy.getDay();\n    };\n    \n    /**\n     * Get the Day of week 1 (Monday) thru 7 (Sunday)\n     * \n     * @returns {Integer} Day of week 1 (Monday) thru 7 (Sunday)\n     */\n    jsDate.prototype.getDayOfWeek = function() { \n        var dow = this.proxy.getDay(); \n        return dow===0?7:dow; \n    };\n    \n    /**\n     * Get the day of the year\n     * \n     * @returns {Integer} 1 - 366, day of the year\n     */\n    jsDate.prototype.getDayOfYear = function() {\n        var d = this.proxy;\n        var ms = d - new Date('' + d.getFullYear() + '/1/1 GMT');\n        ms += d.getTimezoneOffset()*60000;\n        d = null;\n        return parseInt(ms/60000/60/24, 10)+1;\n    };\n    \n    /**\n     * Get the name of the current week day\n     * \n     * @returns {String}\n     */  \n     \n    jsDate.prototype.getDayName = function() {\n        return jsDate.regional[this.locale][\"dayNames\"][this.proxy.getDay()];\n    };\n    \n    /**\n     * Get the week number of the given year, starting with the first Sunday as the first week\n     * @returns {Integer} Week number (13 for the 13th full week of the year).\n     */\n    jsDate.prototype.getFullWeekOfYear = function() {\n        var d = this.proxy;\n        var doy = this.getDayOfYear();\n        var rdow = 6-d.getDay();\n        var woy = parseInt((doy+rdow)/7, 10);\n        return woy;\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getFullYear = function() {\n        return this.proxy.getFullYear();\n    };\n    \n    /**\n     * Get the GMT offset in hours and minutes (e.g. +06:30)\n     * \n     * @returns {String}\n     */\n     \n    jsDate.prototype.getGmtOffset = function() {\n        // divide the minutes offset by 60\n        var hours = this.proxy.getTimezoneOffset() / 60;\n        // decide if we are ahead of or behind GMT\n        var prefix = hours < 0 ? '+' : '-';\n        // remove the negative sign if any\n        hours = Math.abs(hours);\n        // add the +/- to the padded number of hours to : to the padded minutes\n        return prefix + addZeros(Math.floor(hours), 2) + ':' + addZeros((hours % 1) * 60, 2);\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getHours = function() {\n        return this.proxy.getHours();\n    };\n    \n    /**\n     * Get the current hour on a 12-hour scheme\n     * \n     * @returns {Integer}\n     */\n     \n    jsDate.prototype.getHours12  = function() {\n        var hours = this.proxy.getHours();\n        return hours > 12 ? hours - 12 : (hours == 0 ? 12 : hours);\n    };\n    \n    \n    jsDate.prototype.getIsoWeek = function() {\n        var d = this.proxy;\n        var woy = this.getWeekOfYear();\n        var dow1_1 = (new Date('' + d.getFullYear() + '/1/1')).getDay();\n        // First week is 01 and not 00 as in the case of %U and %W,\n        // so we add 1 to the final result except if day 1 of the year\n        // is a Monday (then %W returns 01).\n        // We also need to subtract 1 if the day 1 of the year is \n        // Friday-Sunday, so the resulting equation becomes:\n        var idow = woy + (dow1_1 > 4 || dow1_1 <= 1 ? 0 : 1);\n        if(idow == 53 && (new Date('' + d.getFullYear() + '/12/31')).getDay() < 4)\n        {\n            idow = 1;\n        }\n        else if(idow === 0)\n        {\n            d = new jsDate(new Date('' + (d.getFullYear()-1) + '/12/31'));\n            idow = d.getIsoWeek();\n        }\n        d = null;\n        return idow;\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getMilliseconds = function() {\n        return this.proxy.getMilliseconds();\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getMinutes = function() {\n        return this.proxy.getMinutes();\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getMonth = function() {\n        return this.proxy.getMonth();\n    };\n    \n    /**\n     * Get the name of the current month\n     * \n     * @returns {String}\n     */\n     \n    jsDate.prototype.getMonthName = function() {\n        return jsDate.regional[this.locale][\"monthNames\"][this.proxy.getMonth()];\n    };\n    \n    /**\n     * Get the number of the current month, 1-12\n     * \n     * @returns {Integer}\n     */\n     \n    jsDate.prototype.getMonthNumber = function() {\n        return this.proxy.getMonth() + 1;\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getSeconds = function() {\n        return this.proxy.getSeconds();\n    };\n    \n    /**\n     * Return a proper two-digit year integer\n     * \n     * @returns {Integer}\n     */\n     \n    jsDate.prototype.getShortYear = function() {\n        return this.proxy.getYear() % 100;\n    };\n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getTime = function() {\n        return this.proxy.getTime();\n    };\n    \n    /**\n     * Get the timezone abbreviation\n     *\n     * @returns {String} Abbreviation for the timezone\n     */\n    jsDate.prototype.getTimezoneAbbr = function() {\n        return this.proxy.toString().replace(/^.*\\(([^)]+)\\)$/, '$1'); \n    };\n    \n    /**\n     * Get the browser-reported name for the current timezone (e.g. MDT, Mountain Daylight Time)\n     * \n     * @returns {String}\n     */\n    jsDate.prototype.getTimezoneName = function() {\n        var match = /(?:\\((.+)\\)$| ([A-Z]{3}) )/.exec(this.toString());\n        return match[1] || match[2] || 'GMT' + this.getGmtOffset();\n    }; \n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getTimezoneOffset = function() {\n        return this.proxy.getTimezoneOffset();\n    };\n    \n    \n    /**\n     * Get the week number of the given year, starting with the first Monday as the first week\n     * @returns {Integer} Week number (13 for the 13th week of the year).\n     */\n    jsDate.prototype.getWeekOfYear = function() {\n        var doy = this.getDayOfYear();\n        var rdow = 7 - this.getDayOfWeek();\n        var woy = parseInt((doy+rdow)/7, 10);\n        return woy;\n    };\n    \n    /**\n     * Get the current date as a Unix timestamp\n     * \n     * @returns {Integer}\n     */\n     \n    jsDate.prototype.getUnix = function() {\n        return Math.round(this.proxy.getTime() / 1000, 0);\n    }; \n    \n    /**\n     * Implements Date functionality\n     */\n    jsDate.prototype.getYear = function() {\n        return this.proxy.getYear();\n    };\n    \n    /**\n     * Return a date one day ahead (or any other unit)\n     * \n     * @param {String} unit Optional, year | month | day | week | hour | minute | second | millisecond\n     * @returns {jsDate}\n     */\n     \n    jsDate.prototype.next = function(unit) {\n        unit = unit || 'day';\n        return this.clone().add(1, unit);\n    };\n    \n    /**\n     * Set the jsDate instance to a new date.\n     *\n     * @param  {String | Number | Array | Date Object | jsDate Object | Options Object} arguments Optional arguments, \n     * either a parsable date/time string,\n     * a JavaScript timestamp, an array of numbers of form [year, month, day, hours, minutes, seconds, milliseconds],\n     * a Date object, jsDate Object or an options object of form {syntax: \"perl\", date:some Date} where all options are optional.\n     */\n    jsDate.prototype.set = function() {\n        switch ( arguments.length ) {\n            case 0:\n                this.proxy = new Date();\n                break;\n            case 1:\n                // other objects either won't have a _type property or,\n                // if they do, it shouldn't be set to \"jsDate\", so\n                // assume it is an options argument.\n                if (get_type(arguments[0]) == \"[object Object]\" && arguments[0]._type != \"jsDate\") {\n                    var opts = this.options = arguments[0];\n                    this.syntax = opts.syntax || this.syntax;\n                    this.defaultCentury = opts.defaultCentury || this.defaultCentury;\n                    this.proxy = jsDate.createDate(opts.date);\n                }\n                else {\n                    this.proxy = jsDate.createDate(arguments[0]);\n                }\n                break;\n            default:\n                var a = [];\n                for ( var i=0; i<arguments.length; i++ ) {\n                    a.push(arguments[i]);\n                }\n                // this should be the current date/time\n                this.proxy = new Date();\n                this.proxy.setFullYear.apply( this.proxy, a.slice(0,3) );\n                if ( a.slice(3).length ) {\n                    this.proxy.setHours.apply( this.proxy, a.slice(3) );\n                }\n                break;\n        }\n        return this;\n    };\n    \n    /**\n     * Sets the day of the month for a specified date according to local time.\n     * @param {Integer} dayValue An integer from 1 to 31, representing the day of the month. \n     */\n    jsDate.prototype.setDate = function(n) {\n        this.proxy.setDate(n);\n        return this;\n    };\n    \n    /**\n     * Sets the full year for a specified date according to local time.\n     * @param {Integer} yearValue The numeric value of the year, for example, 1995.  \n     * @param {Integer} monthValue Optional, between 0 and 11 representing the months January through December.  \n     * @param {Integer} dayValue Optional, between 1 and 31 representing the day of the month. If you specify the dayValue parameter, you must also specify the monthValue. \n     */\n    jsDate.prototype.setFullYear = function() {\n        this.proxy.setFullYear.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Sets the hours for a specified date according to local time.\n     * \n     * @param {Integer} hoursValue An integer between 0 and 23, representing the hour.  \n     * @param {Integer} minutesValue Optional, An integer between 0 and 59, representing the minutes.  \n     * @param {Integer} secondsValue Optional, An integer between 0 and 59, representing the seconds. \n     * If you specify the secondsValue parameter, you must also specify the minutesValue.  \n     * @param {Integer} msValue Optional, A number between 0 and 999, representing the milliseconds. \n     * If you specify the msValue parameter, you must also specify the minutesValue and secondsValue. \n     */\n    jsDate.prototype.setHours = function() {\n        this.proxy.setHours.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setMilliseconds = function(n) {\n        this.proxy.setMilliseconds(n);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setMinutes = function() {\n        this.proxy.setMinutes.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setMonth = function() {\n        this.proxy.setMonth.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setSeconds = function() {\n        this.proxy.setSeconds.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setTime = function(n) {\n        this.proxy.setTime(n);\n        return this;\n    };\n    \n    /**\n     * Implements Date functionality\n     */ \n    jsDate.prototype.setYear = function() {\n        this.proxy.setYear.apply(this.proxy, arguments);\n        return this;\n    };\n    \n    /**\n     * Provide a formatted string representation of this date.\n     * \n     * @param {String} formatString A format string.  \n     * See: {@link jsDate.formats}.\n     * @returns {String} Date String.\n     */\n            \n    jsDate.prototype.strftime = function(formatString) {\n        formatString = formatString || this.formatString || jsDate.regional[this.locale]['formatString'];\n        return jsDate.strftime(this, formatString, this.syntax);\n    };\n        \n    /**\n     * Return a String representation of this jsDate object.\n     * @returns {String} Date string.\n     */\n    \n    jsDate.prototype.toString = function() {\n        return this.proxy.toString();\n    };\n        \n    /**\n     * Convert the current date to an 8-digit integer (%Y%m%d)\n     * \n     * @returns {Integer}\n     */\n     \n    jsDate.prototype.toYmdInt = function() {\n        return (this.proxy.getFullYear() * 10000) + (this.getMonthNumber() * 100) + this.proxy.getDate();\n    };\n    \n    /**\n     * @namespace Holds localizations for month/day names.\n     * <p>jsDate attempts to detect locale when loaded and defaults to 'en'.\n     * If a localization is detected which is not available, jsDate defaults to 'en'.\n     * Additional localizations can be added after jsDate loads.  After adding a localization,\n     * call the jsDate.regional.getLocale() method.  Currently, en, fr and de are defined.</p>\n     * \n     * <p>Localizations must be an object and have the following properties defined:  monthNames, monthNamesShort, dayNames, dayNamesShort and Localizations are added like:</p>\n     * <pre class=\"code\">\n     * jsDate.regional['en'] = {\n     * monthNames      : 'January February March April May June July August September October November December'.split(' '),\n     * monthNamesShort : 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '),\n     * dayNames        : 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),\n     * dayNamesShort   : 'Sun Mon Tue Wed Thu Fri Sat'.split(' ')\n     * };\n     * </pre>\n     * <p>After adding localizations, call <code>jsDate.regional.getLocale();</code> to update the locale setting with the\n     * new localizations.</p>\n     */\n     \n    jsDate.regional = {\n        'en': {\n            monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],\n            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun','Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'fr': {\n            monthNames: ['Janvier','Fvrier','Mars','Avril','Mai','Juin','Juillet','Aot','Septembre','Octobre','Novembre','Dcembre'],\n            monthNamesShort: ['Jan','Fv','Mar','Avr','Mai','Jun','Jul','Ao','Sep','Oct','Nov','Dc'],\n            dayNames: ['Dimanche','Lundi','Mardi','Mercredi','Jeudi','Vendredi','Samedi'],\n            dayNamesShort: ['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'de': {\n            monthNames: ['Januar','Februar','Mrz','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'],\n            monthNamesShort: ['Jan','Feb','Mr','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'],\n            dayNames: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],\n            dayNamesShort: ['So','Mo','Di','Mi','Do','Fr','Sa'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'es': {\n            monthNames: ['Enero','Febrero','Marzo','Abril','Mayo','Junio', 'Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'],\n            monthNamesShort: ['Ene','Feb','Mar','Abr','May','Jun', 'Jul','Ago','Sep','Oct','Nov','Dic'],\n            dayNames: ['Domingo','Lunes','Martes','Mi&eacute;rcoles','Jueves','Viernes','S&aacute;bado'],\n            dayNamesShort: ['Dom','Lun','Mar','Mi&eacute;','Juv','Vie','S&aacute;b'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'ru': {\n            monthNames: ['','','','','','','','','','','',''],\n            monthNamesShort: ['','','','','','','','','','','',''],\n            dayNames: ['','','','','','',''],\n            dayNamesShort: ['','','','','','',''],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'ar': {\n            monthNames: [' ', '', '', '', '', '','', '', '',   ' ', ' ', ' '],\n            monthNamesShort: ['1','2','3','4','5','6','7','8','9','10','11','12'],\n            dayNames: ['', '', '', '', '', '', ''],\n            dayNamesShort: ['', '', '', '', '', '', ''],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'pt': {\n            monthNames: ['Janeiro','Fevereiro','Mar&ccedil;o','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],\n            monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],\n            dayNames: ['Domingo','Segunda-feira','Ter&ccedil;a-feira','Quarta-feira','Quinta-feira','Sexta-feira','S&aacute;bado'],\n            dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','S&aacute;b'],\n            formatString: '%Y-%m-%d %H:%M:%S'   \n        },\n        \n        'pt-BR': {\n            monthNames: ['Janeiro','Fevereiro','Mar&ccedil;o','Abril','Maio','Junho', 'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],\n            monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],\n            dayNames: ['Domingo','Segunda-feira','Ter&ccedil;a-feira','Quarta-feira','Quinta-feira','Sexta-feira','S&aacute;bado'],\n            dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','S&aacute;b'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n        \n        'pl': {\n            monthNames: ['Stycze','Luty','Marzec','Kwiecie','Maj','Czerwiec','Lipiec','Sierpie','Wrzesie','Padziernik','Listopad','Grudzie'],\n            monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze','Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],\n            dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],\n            dayNamesShort: ['Ni', 'Pn', 'Wt', 'r', 'Cz', 'Pt', 'Sb'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n\n        'nl': {\n            monthNames: ['Januari','Februari','Maart','April','Mei','Juni','July','Augustus','September','Oktober','November','December'],\n            monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun','Jul','Aug','Sep','Okt','Nov','Dec'],\n            dayNames:','['Zondag','Maandag','Dinsdag','Woensdag','Donderdag','Vrijdag','Zaterdag'],\n            dayNamesShort: ['Zo','Ma','Di','Wo','Do','Vr','Za'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n\n        'sv': {\n            monthNames: ['januari','februari','mars','april','maj','juni','juli','augusti','september','oktober','november','december'],\n            monthNamesShort: ['jan','feb','mar','apr','maj','jun','jul','aug','sep','okt','nov','dec'],\n            dayNames: ['sndag','mndag','tisdag','onsdag','torsdag','fredag','lrdag'],\n            dayNamesShort: ['sn','mn','tis','ons','tor','fre','lr'],\n            formatString: '%Y-%m-%d %H:%M:%S'\n        },\n\n        'it': {\n            monthNames: ['Gennaio','Febbraio','Marzo','Aprile','Maggio','Giugno','Luglio','Agosto','Settembre','Ottobre','Novembre','Dicembre'],\n            monthNamesShort: ['Gen','Feb','Mar','Apr','Mag','Giu','Lug','Ago','Set','Ott','Nov','Dic'],\n            dayNames: ['Domenica','Lunedi','Martedi','Mercoledi','Giovedi','Venerdi','Sabato'],\n            dayNamesShort: ['Dom','Lun','Mar','Mer','Gio','Ven','Sab'],\n            formatString: '%d-%m-%Y %H:%M:%S'\n        }\n    \n    };\n    \n    // Set english variants to 'en'\n    jsDate.regional['en-US'] = jsDate.regional['en-GB'] = jsDate.regional['en'];\n    \n    /**\n     * Try to determine the users locale based on the lang attribute of the html page.  Defaults to 'en'\n     * if it cannot figure out a locale of if the locale does not have a localization defined.\n     * @returns {String} locale\n     */\n     \n    jsDate.regional.getLocale = function () {\n        var l = jsDate.config.defaultLocale;\n        \n        if ( document && document.getElementsByTagName('html') && document.getElementsByTagName('html')[0].lang ) {\n            l = document.getElementsByTagName('html')[0].lang;\n            if (!jsDate.regional.hasOwnProperty(l)) {\n                l = jsDate.config.defaultLocale;\n            }\n        }\n        \n        return l;\n    };\n    \n    // ms in day\n    var day = 24 * 60 * 60 * 1000;\n    \n    // padd a number with zeros\n    var addZeros = function(num, digits) {\n        num = String(num);\n        var i = digits - num.length;\n        var s = String(Math.pow(10, i)).slice(1);\n        return s.concat(num);\n    };\n\n    // representations used for calculating differences between dates.\n    // This borrows heavily from Ken Snyder's work.\n    var multipliers = {\n        millisecond: 1,\n        second: 1000,\n        minute: 60 * 1000,\n        hour: 60 * 60 * 1000,\n        day: day,\n        week: 7 * day,\n        month: {\n            // add a number of months\n            add: function(d, number) {\n                // add any years needed (increments of 12)\n                multipliers.year.add(d, Math[number > 0 ? 'floor' : 'ceil'](number / 12));\n                // ensure that we properly wrap betwen December and January\n                // 11 % 12 = 11\n                // 12 % 12 = 0\n                var prevMonth = d.getMonth() + (number % 12);\n                if (prevMonth == 12) {\n                    prevMonth = 0;\n                    d.setYear(d.getFullYear() + 1);\n                } else if (prevMonth == -1) {\n                    prevMonth = 11;\n                    d.setYear(d.getFullYear() - 1);\n                }\n                d.setMonth(prevMonth);\n            },\n            // get the number of months between two Date objects (decimal to the nearest day)\n            diff: function(d1, d2) {\n                // get the number of years\n                var diffYears = d1.getFullYear() - d2.getFullYear();\n                // get the number of remaining months\n                var diffMonths = d1.getMonth() - d2.getMonth() + (diffYears * 12);\n                // get the number of remaining days\n                var diffDays = d1.getDate() - d2.getDate();\n                // return the month difference with the days difference as a decimal\n                return diffMonths + (diffDays / 30);\n            }\n        },\n        year: {\n            // add a number of years\n            add: function(d, number) {\n                d.setYear(d.getFullYear() + Math[number > 0 ? 'floor' : 'ceil'](number));\n            },\n            // get the number of years between two Date objects (decimal to the nearest day)\n            diff: function(d1, d2) {\n                return multipliers.month.diff(d1, d2) / 12;\n            }\n        }        \n    };\n    //\n    // Alias each multiplier with an 's' to allow 'year' and 'years' for example.\n    // This comes from Ken Snyders work.\n    //\n    for (var unit in multipliers) {\n        if (unit.substring(unit.length - 1) != 's') { // IE will iterate newly added properties :|\n            multipliers[unit + 's'] = multipliers[unit];\n        }\n    }\n    \n    //\n    // take a jsDate instance and a format code and return the formatted value.\n    // This is a somewhat modified version of Ken Snyder's method.\n    //\n    var format = function(d, code, syntax) {\n        // if shorcut codes are used, recursively expand those.\n        if (jsDate.formats[syntax][\"shortcuts\"][code]) {\n            return jsDate.strftime(d, jsDate.formats[syntax][\"shortcuts\"][code], syntax);\n        } else {\n            // get the format code function and addZeros() argument\n            var getter = (jsDate.formats[syntax][\"codes\"][code] || '').split('.');\n            var nbr = d['get' + getter[0]] ? d['get' + getter[0]]() : '';\n            if (getter[1]) {\n                nbr = addZeros(nbr, getter[1]);\n            }\n            return nbr;\n        }       \n    };\n    \n    /**\n     * @static\n     * Static function for convert a date to a string according to a given format.  Also acts as namespace for strftime format codes.\n     * <p>strftime formatting can be accomplished without creating a jsDate object by calling jsDate.strftime():</p>\n     * <pre class=\"code\">\n     * var formattedDate = jsDate.strftime('Feb 8, 2006 8:48:32', '%Y-%m-%d %H:%M:%S');\n     * </pre>\n     * @param {String | Number | Array | jsDate&nbsp;Object | Date&nbsp;Object} date A parsable date string, JavaScript time stamp, Array of form [year, month, day, hours, minutes, seconds, milliseconds], jsDate Object or Date object.\n     * @param {String} formatString String with embedded date formatting codes.  \n     * See: {@link jsDate.formats}. \n     * @param {String} syntax Optional syntax to use [default perl].\n     * @param {String} locale Optional locale to use.\n     * @returns {String} Formatted representation of the date.\n    */\n    //\n    // Logic as implemented here is very similar to Ken Snyder's Date Instance Methods.\n    //\n    jsDate.strftime = function(d, formatString, syntax, locale) {\n        var syn = 'perl';\n        var loc = jsDate.regional.getLocale();\n        \n        // check if syntax and locale are available or reversed\n        if (syntax && jsDate.formats.hasOwnProperty(syntax)) {\n            syn = syntax;\n        }\n        else if (syntax && jsDate.regional.hasOwnProperty(syntax)) {\n            loc = syntax;\n        }\n        \n        if (locale && jsDate.formats.hasOwnProperty(locale)) {\n            syn = locale;\n        }\n        else if (locale && jsDate.regional.hasOwnProperty(locale)) {\n            loc = locale;\n        }\n        \n        if (get_type(d) != \"[object Object]\" || d._type != \"jsDate\") {\n            d = new jsDate(d);\n            d.locale = loc;\n        }\n        if (!formatString) {\n            formatString = d.formatString || jsDate.regional[loc]['formatString'];\n        }\n        // default the format string to year-month-day\n        var source = formatString || '%Y-%m-%d', \n            result = '', \n            match;\n        // replace each format code\n        while (source.length > 0) {\n            if (match = source.match(jsDate.formats[syn].codes.matcher)) {\n                result += source.slice(0, match.index);\n                result += (match[1] || '') + format(d, match[2], syn);\n                source = source.slice(match.index + match[0].length);\n            } else {\n                result += source;\n                source = '';\n            }\n        }\n        return result;\n    };\n    \n    /**\n     * @namespace\n     * Namespace to hold format codes and format shortcuts.  \"perl\" and \"php\" format codes \n     * and shortcuts are defined by default.  Additional codes and shortcuts can be\n     * added like:\n     * \n     * <pre class=\"code\">\n     * jsDate.formats[\"perl\"] = {\n     *     \"codes\": {\n     *         matcher: /someregex/,\n     *         Y: \"fullYear\",  // name of \"get\" method without the \"get\",\n     *         ...,            // more codes\n     *     },\n     *     \"shortcuts\": {\n     *         F: '%Y-%m-%d',\n     *         ...,            // more shortcuts\n     *     }\n     * };\n     * </pre>\n     * \n     * <p>Additionally, ISO and SQL shortcuts are defined and can be accesses via:\n     * <code>jsDate.formats.ISO</code> and <code>jsDate.formats.SQL</code>\n     */\n    \n    jsDate.formats = {\n        ISO:'%Y-%m-%dT%H:%M:%S.%N%G',\n        SQL:'%Y-%m-%d %H:%M:%S'\n    };\n    \n    /**\n     * Perl format codes and shortcuts for strftime.\n     * \n     * A hash (object) of codes where each code must be an array where the first member is \n     * the name of a Date.prototype or jsDate.prototype function to call\n     * and optionally a second member indicating the number to pass to addZeros()\n     * \n     * <p>The following format codes are defined:</p>\n     * \n     * <pre class=\"code\">\n     * Code    Result                    Description\n     * == Years ==           \n     * %Y      2008                      Four-digit year\n     * %y      08                        Two-digit year\n     * \n     * == Months ==          \n     * %m      09                        Two-digit month\n     * %#m     9                         One or two-digit month\n     * %B      September                 Full month name\n     * %b      Sep                       Abbreviated month name\n     * \n     * == Days ==            \n     * %d      05                        Two-digit day of month\n     * %#d     5                         One or two-digit day of month\n     * %e      5                         One or two-digit day of month\n     * %A      Sunday                    Full name of the day of the week\n     * %a      Sun                       Abbreviated name of the day of the week\n     * %w      0                         Number of the day of the week (0 = Sunday, 6 = Saturday)\n     * \n     * == Hours ==           \n     * %H      23                        Hours in 24-hour format (two digits)\n     * %#H     3                         Hours in 24-hour integer format (one or two digits)\n     * %I      11                        Hours in 12-hour format (two digits)\n     * %#I     3                         Hours in 12-hour integer format (one or two digits)\n     * %p      PM                        AM or PM\n     * \n     * == Minutes ==         \n     * %M      09                        Minutes (two digits)\n     * %#M     9                         Minutes (one or two digits)\n     * \n     * == Seconds ==         \n     * %S      02                        Seconds (two digits)\n     * %#S     2                         Seconds (one or two digits)\n     * %s      1206567625723             Unix timestamp (Seconds past 1970-01-01 00:00:00)\n     * \n     * == Milliseconds ==    \n     * %N      008                       Milliseconds (three digits)\n     * %#N     8                         Milliseconds (one to three digits)\n     * \n     * == Timezone ==        \n     * %O      360                       difference in minutes between local time and GMT\n     * %Z      Mountain Standard Time    Name of timezone as reported by browser\n     * %G      06:00                     Hours and minutes between GMT\n     * \n     * == Shortcuts ==       \n     * %F      2008-03-26                %Y-%m-%d\n     * %T      05:06:30                  %H:%M:%S\n     * %X      05:06:30                  %H:%M:%S\n     * %x      03/26/08                  %m/%d/%y\n     * %D      03/26/08                  %m/%d/%y\n     * %#c     Wed Mar 26 15:31:00 2008  %a %b %e %H:%M:%S %Y\n     * %v      3-Sep-2008                %e-%b-%Y\n     * %R      15:31                     %H:%M\n     * %r      03:31:00 PM               %I:%M:%S %p\n     * \n     * == Characters ==      \n     * %n      \\n                        Newline\n     * %t      \\t                        Tab\n     * %%      %                         Percent Symbol\n     * </pre>\n     * \n     * <p>Formatting shortcuts that will be translated into their longer version.\n     * Be sure that format shortcuts do not refer to themselves: this will cause an infinite loop.</p>\n     * \n     * <p>Format codes and format shortcuts can be redefined after the jsDate\n     * module is imported.</p>\n     * \n     * <p>Note that if you redefine the whole hash (object), you must supply a \"matcher\"\n     * regex for the parser.  The default matcher is:</p>\n     * \n     * <code>/()%(#?(%|[a-z]))/i</code>\n     * \n     * <p>which corresponds to the Perl syntax used by default.</p>\n     * \n     * <p>By customizing the matcher and format codes, nearly any strftime functionality is possible.</p>\n     */\n     \n    jsDate.formats.perl = {\n        codes: {\n            //\n            // 2-part regex matcher for format codes\n            //\n            // first match must be the character before the code (to account for escaping)\n            // second match must be the format code character(s)\n            //\n            matcher: /()%(#?(%|[a-z]))/i,\n            // year\n            Y: 'FullYear',\n            y: 'ShortYear.2',\n            // month\n            m: 'MonthNumber.2',\n            '#m': 'MonthNumber',\n            B: 'MonthName',\n            b: 'AbbrMonthName',\n            // day\n            d: 'Date.2',\n            '#d': 'Date',\n            e: 'Date',\n            A: 'DayName',\n            a: 'AbbrDayName',\n            w: 'Day',\n            // hours\n            H: 'Hours.2',\n            '#H': 'Hours',\n            I: 'Hours12.2',\n            '#I': 'Hours12',\n            p: 'AMPM',\n            // minutes\n            M: 'Minutes.2',\n            '#M': 'Minutes',\n            // seconds\n            S: 'Seconds.2',\n            '#S': 'Seconds',\n            s: 'Unix',\n            // milliseconds\n            N: 'Milliseconds.3',\n            '#N': 'Milliseconds',\n            // timezone\n            O: 'TimezoneOffset',\n            Z: 'TimezoneName',\n            G: 'GmtOffset'  \n        },\n        \n        shortcuts: {\n            // date\n            F: '%Y-%m-%d',\n            // time\n            T: '%H:%M:%S',\n            X: '%H:%M:%S',\n            // local format date\n            x: '%m/%d/%y',\n            D: '%m/%d/%y',\n            // local format extended\n            '#c': '%a %b %e %H:%M:%S %Y',\n            // local format short\n            v: '%e-%b-%Y',\n            R: '%H:%M',\n            r: '%I:%M:%S %p',\n            // tab and newline\n            t: '\\t',\n            n: '\\n',\n            '%': '%'\n        }\n    };\n    \n    /**\n     * PHP format codes and shortcuts for strftime.\n     * \n     * A hash (object) of codes where each code must be an array where the first member is \n     * the name of a Date.prototype or jsDate.prototype function to call\n     * and optionally a second member indicating the number to pass to addZeros()\n     * \n     * <p>The following format codes are defined:</p>\n     * \n     * <pre class=\"code\">\n     * Code    Result                    Description\n     * === Days ===        \n     * %a      Sun through Sat           An abbreviated textual representation of the day\n     * %A      Sunday - Saturday         A full textual representation of the day\n     * %d      01 to 31                  Two-digit day of the month (with leading zeros)\n     * %e      1 to 31                   Day of the month, with a space preceding single digits.\n     * %j      001 to 366                Day of the year, 3 digits with leading zeros\n     * %u      1 - 7 (Mon - Sun)         ISO-8601 numeric representation of the day of the week\n     * %w      0 - 6 (Sun - Sat)         Numeric representation of the day of the week\n     *                                  \n     * === Week ===                     \n     * %U      13                        Full Week number, starting with the first Sunday as the first week\n     * %V      01 through 53             ISO-8601:1988 week number, starting with the first week of the year \n     *                                   with at least 4 weekdays, with Monday being the start of the week\n     * %W      46                        A numeric representation of the week of the year, \n     *                                   starting with the first Monday as the first week\n     * === Month ===                    \n     * %b      Jan through Dec           Abbreviated month name, based on the locale\n     * %B      January - December        Full month name, based on the locale\n     * %h      Jan through Dec           Abbreviated month name, based on the locale (an alias of %b)\n     * %m      01 - 12 (Jan - Dec)       Two digit representation of the month\n     * \n     * === Year ===                     \n     * %C      19                        Two digit century (year/100, truncated to an integer)\n     * %y      09 for 2009               Two digit year\n     * %Y      2038                      Four digit year\n     * \n     * === Time ===                     \n     * %H      00 through 23             Two digit representation of the hour in 24-hour format\n     * %I      01 through 12             Two digit representation of the hour in 12-hour format\n     * %l      1 through 12              Hour in 12-hour format, with a space preceeding single digits\n     * %M      00 through 59             Two digit representation of the minute\n     * %p      AM/PM                     UPPER-CASE 'AM' or 'PM' based on the given time\n     * %P      am/pm                     lower-case 'am' or 'pm' based on the given time\n     * %r      09:34:17 PM               Same as %I:%M:%S %p\n     * %R      00:35                     Same as %H:%M\n     * %S      00 through 59             Two digit representation of the second\n     * %T      21:34:17                  Same as %H:%M:%S\n     * %X      03:59:16                  Preferred time representation based on locale, without the date\n     * %z      -0500 or EST              Either the time zone offset from UTC or the abbreviation\n     * %Z      -0500 or EST              The time zone offset/abbreviation option NOT given by %z\n     * \n     * === Time and Date ===            \n     * %D      02/05/09                  Same as %m/%d/%y\n     * %F      2009-02-05                Same as %Y-%m-%d (commonly used in database datestamps)\n     * %s      305815200                 Unix Epoch Time timestamp (same as the time() function)\n     * %x      02/05/09                  Preferred date representation, without the time\n     * \n     * === Miscellaneous ===            \n     * %n        ---                     A newline character (\\n)\n     * %t        ---                     A Tab character (\\t)\n     * %%        ---                     A literal percentage character (%)\n     * </pre>\n     */\n \n    jsDate.formats.php = {\n        codes: {\n            //\n            // 2-part regex matcher for format codes\n            //\n            // first match must be the character before the code (to account for escaping)\n            // second match must be the format code character(s)\n            //\n            matcher: /()%((%|[a-z]))/i,\n            // day\n            a: 'AbbrDayName',\n            A: 'DayName',\n            d: 'Date.2',\n            e: 'Date',\n            j: 'DayOfYear.3',\n            u: 'DayOfWeek',\n            w: 'Day',\n            // week\n            U: 'FullWeekOfYear.2',\n            V: 'IsoWeek.2',\n            W: 'WeekOfYear.2',\n            // month\n            b: 'AbbrMonthName',\n            B: 'MonthName',\n            m: 'MonthNumber.2',\n            h: 'AbbrMonthName',\n            // year\n            C: 'Century.2',\n            y: 'ShortYear.2',\n            Y: 'FullYear',\n            // time\n            H: 'Hours.2',\n            I: 'Hours12.2',\n            l: 'Hours12',\n            p: 'AMPM',\n            P: 'AmPm',\n            M: 'Minutes.2',\n            S: 'Seconds.2',\n            s: 'Unix',\n            O: 'TimezoneOffset',\n            z: 'GmtOffset',\n            Z: 'TimezoneAbbr'\n        },\n        \n        shortcuts: {\n            D: '%m/%d/%y',\n            F: '%Y-%m-%d',\n            T: '%H:%M:%S',\n            X: '%H:%M:%S',\n            x: '%m/%d/%y',\n            R: '%H:%M',\n            r: '%I:%M:%S %p',\n            t: '\\t',\n            n: '\\n',\n            '%': '%'\n        }\n    };   \n    //\n    // Conceptually, the logic implemented here is similar to Ken Snyder's Date Instance Methods.\n    // I use his idea of a set of parsers which can be regular expressions or functions,\n    // iterating through those, and then seeing if Date.parse() will create a date.\n    // The parser expressions and functions are a little different and some bugs have been\n    // worked out.  Also, a lot of \"pre-parsing\" is done to fix implementation\n    // variations of Date.parse() between browsers.\n    //\n    jsDate.createDate = function(date) {\n        // if passing in multiple arguments, try Date constructor\n        if (date == null) {\n            return new Date();\n        }\n        // If the passed value is already a date object, return it\n        if (date instanceof Date) {\n            return date;\n        }\n        // if (typeof date == 'number') return new Date(date * 1000);\n        // If the passed value is an integer, interpret it as a javascript timestamp\n        if (typeof date == 'number') {\n            return new Date(date);\n        }\n        \n        // Before passing strings into Date.parse(), have to normalize them for certain conditions.\n        // If strings are not formatted staccording to the EcmaScript spec, results from Date parse will be implementation dependent.  \n        // \n        // For example: \n        //  * FF and Opera assume 2 digit dates are pre y2k, Chome assumes <50 is pre y2k, 50+ is 21st century.  \n        //  * Chrome will correctly parse '1984-1-25' into localtime, FF and Opera will not parse.\n        //  * Both FF, Chrome and Opera will parse '1984/1/25' into localtime.\n        \n        // remove leading and trailing spaces\n        var parsable = String(date).replace(/^\\s*(.+)\\s*$/g, '$1');\n        \n        // replace dahses (-) with slashes (/) in dates like n[nnn]/n[n]/n[nnn]\n        parsable = parsable.replace(/^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,4})/, \"$1/$2/$3\");\n        \n        /////////\n        // Need to check for '15-Dec-09' also.\n        // FF will not parse, but Chrome will.\n        // Chrome will set date to 2009 as well.\n        /////////\n        \n        // first check for 'dd-mmm-yyyy' or 'dd/mmm/yyyy' like '15-Dec-2010'\n        parsable = parsable.replace(/^(3[01]|[0-2]?\\d)[-\\/]([a-z]{3,})[-\\/](\\d{4})/i, \"$1 $2 $3\");\n        \n        // Now check for 'dd-mmm-yy' or 'dd/mmm/yy' and normalize years to default century.\n        var match = parsable.match(/^(3[01]|[0-2]?\\d)[-\\/]([a-z]{3,})[-\\/](\\d{2})\\D*/i);\n        if (match && match.length > 3) {\n            var m3 = parseFloat(match[3]);\n            var ny = jsDate.config.defaultCentury + m3;\n            ny = String(ny);\n            \n            // now replace 2 digit year with 4 digit year\n            parsable = parsable.replace(/^(3[01]|[0-2]?\\d)[-\\/]([a-z]{3,})[-\\/](\\d{2})\\D*/i, match[1] +' '+ match[2] +' '+ ny);\n            \n        }\n        \n        // Check for '1/19/70 8:14PM'\n        // where starts with mm/dd/yy or yy/mm/dd and have something after\n        // Check if 1st postiion is greater than 31, assume it is year.\n        // Assme all 2 digit years are 1900's.\n        // Finally, change them into US style mm/dd/yyyy representations.\n        match = parsable.match(/^([0-9]{1,2})[-\\/]([0-9]{1,2})[-\\/]([0-9]{1,2})[^0-9]/);\n        \n        function h1(parsable, match) {\n            var m1 = parseFloat(match[1]);\n            var m2 = parseFloat(match[2]);\n            var m3 = parseFloat(match[3]);\n            var cent = jsDate.config.defaultCentury;\n            var ny, nd, nm, str;\n            \n            if (m1 > 31) { // first number is a year\n                nd = m3;\n                nm = m2;\n                ny = cent + m1;\n            }\n            \n            else { // last number is the year\n                nd = m2;\n                nm = m1;\n                ny = cent + m3;\n            }\n            \n            str = nm+'/'+nd+'/'+ny;\n            \n            // now replace 2 digit year with 4 digit year\n            return  parsable.replace(/^([0-9]{1,2})[-\\/]([0-9]{1,2})[-\\/]([0-9]{1,2})/, str);\n        \n        }\n        \n        if (match && match.length > 3) {\n            parsable = h1(parsable, match);\n        }\n        \n        // Now check for '1/19/70' with nothing after and do as above\n        var match = parsable.match(/^([0-9]{1,2})[-\\/]([0-9]{1,2})[-\\/]([0-9]{1,2})$/);\n        \n        if (match && match.length > 3) {\n            parsable = h1(parsable, match);\n        }\n                \n        \n        var i = 0;\n        var length = jsDate.matchers.length;\n        var pattern,\n            ms,\n            current = parsable,\n            obj;\n        while (i < length) {\n            ms = Date.parse(current);\n            if (!isNaN(ms)) {\n                return new Date(ms);\n            }\n            pattern = jsDate.matchers[i];\n            if (typeof pattern == 'function') {\n                obj = pattern.call(jsDate, current);\n                if (obj instanceof Date) {\n                    return obj;\n                }\n            } else {\n                current = parsable.replace(pattern[0], pattern[1]);\n            }\n            i++;\n        }\n        return NaN;\n    };\n    \n\n    /**\n     * @static\n     * Handy static utility function to return the number of days in a given month.\n     * @param {Integer} year Year\n     * @param {Integer} month Month (1-12)\n     * @returns {Integer} Number of days in the month.\n    */\n    //\n    // handy utility method Borrowed right from Ken Snyder's Date Instance Mehtods.\n    // \n    jsDate.daysInMonth = function(year, month) {\n        if (month == 2) {\n            return new Date(year, 1, 29).getDate() == 29 ? 29 : 28;\n        }\n        return [undefined,31,undefined,31,30,31,30,31,31,30,31,30,31][month];\n    };\n\n\n    //\n    // An Array of regular expressions or functions that will attempt to match the date string.\n    // Functions are called with scope of a jsDate instance.\n    //\n    jsDate.matchers = [\n        // convert dd.mmm.yyyy to mm/dd/yyyy (world date to US date).\n        [/(3[01]|[0-2]\\d)\\s*\\.\\s*(1[0-2]|0\\d)\\s*\\.\\s*([1-9]\\d{3})/, '$2/$1/$3'],\n        // convert yyyy-mm-dd to mm/dd/yyyy (ISO date to US date).\n        [/([1-9]\\d{3})\\s*-\\s*(1[0-2]|0\\d)\\s*-\\s*(3[01]|[0-2]\\d)/, '$2/$3/$1'],\n        // Handle 12 hour or 24 hour time with milliseconds am/pm and optional date part.\n        function(str) { \n            var match = str.match(/^(?:(.+)\\s+)?([012]?\\d)(?:\\s*\\:\\s*(\\d\\d))?(?:\\s*\\:\\s*(\\d\\d(\\.\\d*)?))?\\s*(am|pm)?\\s*$/i);\n            //                   opt. date      hour       opt. minute     opt. second       opt. msec   opt. am or pm\n            if (match) {\n                if (match[1]) {\n                    var d = this.createDate(match[1]);\n                    if (isNaN(d)) {\n                        return;\n                    }\n                } else {\n                    var d = new Date();\n                    d.setMilliseconds(0);\n                }\n                var hour = parseFloat(match[2]);\n                if (match[6]) {\n                    hour = match[6].toLowerCase() == 'am' ? (hour == 12 ? 0 : hour) : (hour == 12 ? 12 : hour + 12);\n                }\n                d.setHours(hour, parseInt(match[3] || 0, 10), parseInt(match[4] || 0, 10), ((parseFloat(match[5] || 0)) || 0)*1000);\n                return d;\n            }\n            else {\n                return str;\n            }\n        },\n        // Handle ISO timestamp with time zone.\n        function(str) {\n            var match = str.match(/^(?:(.+))[T|\\s+]([012]\\d)(?:\\:(\\d\\d))(?:\\:(\\d\\d))(?:\\.\\d+)([\\+\\-]\\d\\d\\:\\d\\d)$/i);\n            if (match) {\n                if (match[1]) {\n                    var d = this.createDate(match[1]);\n                    if (isNaN(d)) {\n                        return;\n                    }\n                } else {\n                    var d = new Date();\n                    d.setMilliseconds(0);\n                }\n                var hour = parseFloat(match[2]);\n                d.setHours(hour, parseInt(match[3], 10), parseInt(match[4], 10), parseFloat(match[5])*1000);\n                return d;\n            }\n            else {\n                    return str;\n            }\n        },\n        // Try to match ambiguous strings like 12/8/22.\n        // Use FF date assumption that 2 digit years are 20th century (i.e. 1900's).\n        // This may be redundant with pre processing of date already performed.\n        function(str) {\n            var match = str.match(/^([0-3]?\\d)\\s*[-\\/.\\s]{1}\\s*([a-zA-Z]{3,9})\\s*[-\\/.\\s]{1}\\s*([0-3]?\\d)$/);\n            if (match) {\n                var d = new Date();\n                var cent = jsDate.config.defaultCentury;\n                var m1 = parseFloat(match[1]);\n                var m3 = parseFloat(match[3]);\n                var ny, nd, nm;\n                if (m1 > 31) { // first number is a year\n                    nd = m3;\n                    ny = cent + m1;\n                }\n                \n                else { // last number is the year\n                    nd = m1;\n                    ny = cent + m3;\n                }\n                \n                var nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()][\"monthNamesShort\"]);\n                \n                if (nm == -1) {\n                    nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()][\"monthNames\"]);\n                }\n            \n                d.setFullYear(ny, nm, nd);\n                d.setHours(0,0,0,0);\n                return d;\n            }\n            \n            else {\n                return str;\n            }\n        }      \n    ];\n\n    //\n    // I think John Reisig published this method on his blog, ejohn.\n    //\n    function inArray( elem, array ) {\n        if ( array.indexOf ) {\n            return array.indexOf( elem );\n        }\n\n        for ( var i = 0, length = array.length; i < length; i++ ) {\n            if ( array[ i ] === elem ) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n    \n    //\n    // Thanks to Kangax, Christian Sciberras and Stack Overflow for this method.\n    //\n    function get_type(thing){\n        if(thing===null) return \"[object Null]\"; // special case\n        return Object.prototype.toString.call(thing);\n    }\n    \n    $.jsDate = jsDate;\n\n      \n    /**\n     * JavaScript printf/sprintf functions.\n     * \n     * This code has been adapted from the publicly available sprintf methods\n     * by Ash Searle. His original header follows:\n     *\n     *     This code is unrestricted: you are free to use it however you like.\n     *     \n     *     The functions should work as expected, performing left or right alignment,\n     *     truncating strings, outputting numbers with a required precision etc.\n     *\n     *     For complex cases, these functions follow the Perl implementations of\n     *     (s)printf, allowing arguments to be passed out-of-order, and to set the\n     *     precision or length of the output based on arguments instead of fixed\n     *     numbers.\n     *\n     *     See http://perldoc.perl.org/functions/sprintf.html for more information.\n     *\n     *     Implemented:\n     *     - zero and space-padding\n     *     - right and left-alignment,\n     *     - base X prefix (binary, octal and hex)\n     *     - positive number prefix\n     *     - (minimum) width\n     *     - precision / truncation / maximum width\n     *     - out of order arguments\n     *\n     *     Not implemented (yet):\n     *     - vector flag\n     *     - size (bytes, words, long-words etc.)\n     *     \n     *     Will not implement:\n     *     - %n or %p (no pass-by-reference in JavaScript)\n     *\n     *     @version 2007.04.27\n     *     @author Ash Searle \n     * \n     * You can see the original work and comments on his blog:\n     * http://hexmen.com/blog/2007/03/printf-sprintf/\n     * http://hexmen.com/js/sprintf.js\n     */\n     \n     /**\n      * @Modifications 2009.05.26\n      * @author Chris Leonello\n      * \n      * Added %p %P specifier\n      * Acts like %g or %G but will not add more significant digits to the output than present in the input.\n      * Example:\n      * Format: '%.3p', Input: 0.012, Output: 0.012\n      * Format: '%.3g', Input: 0.012, Output: 0.0120\n      * Format: '%.4p', Input: 12.0, Output: 12.0\n      * Format: '%.4g', Input: 12.0, Output: 12.00\n      * Format: '%.4p', Input: 4.321e-5, Output: 4.321e-5\n      * Format: '%.4g', Input: 4.321e-5, Output: 4.3210e-5\n      * \n      * Example:\n      * >>> $.jqplot.sprintf('%.2f, %d', 23.3452, 43.23)\n      * \"23.35, 43\"\n      * >>> $.jqplot.sprintf(\"no value: %n, decimal with thousands separator: %'d\", 23.3452, 433524)\n      * \"no value: , decimal with thousands separator: 433,524\"\n      */\n    $.jqplot.sprintf = function() {\n        function pad(str, len, chr, leftJustify) {\n            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\n            return leftJustify ? str + padding : padding + str;\n\n        }\n\n        function thousand_separate(value) {\n            var value_str = new String(value);\n            for (var i=10; i>0; i--) {\n                if (value_str == (value_str = value_str.replace(/^(\\d+)(\\d{3})/, \"$1\"+$.jqplot.sprintf.thousandsSeparator+\"$2\"))) break;\n            }\n            return value_str; \n        }\n\n        function justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace) {\n            var diff = minWidth - value.length;\n            if (diff > 0) {\n                var spchar = ' ';\n                if (htmlSpace) { spchar = '&nbsp;'; }\n                if (leftJustify || !zeroPad) {\n                    value = pad(value, minWidth, spchar, leftJustify);\n                } else {\n                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\n                }\n            }\n            return value;\n        }\n\n        function formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad, htmlSpace) {\n            // Note: casts negative numbers to positive ones\n            var number = value >>> 0;\n            prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';\n            value = prefix + pad(number.toString(base), precision || 0, '0', false);\n            return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);\n        }\n\n        function formatString(value, leftJustify, minWidth, precision, zeroPad, htmlSpace) {\n            if (precision != null) {\n                value = value.slice(0, precision);\n            }\n            return justify(value, '', leftJustify, minWidth, zeroPad, htmlSpace);\n        }\n\n        var a = arguments, i = 0, format = a[i++];\n\n        return format.replace($.jqplot.sprintf.regex, function(substring, valueIndex, flags, minWidth, _, precision, type) {\n            if (substring == '%%') { return '%'; }\n\n            // parse flags\n            var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false, htmlSpace = false, thousandSeparation = false;\n            for (var j = 0; flags && j < flags.length; j++) switch (flags.charAt(j)) {\n                case ' ': positivePrefix = ' '; break;\n                case '+': positivePrefix = '+'; break;\n                case '-': leftJustify = true; break;\n                case '0': zeroPad = true; break;\n                case '#': prefixBaseX = true; break;\n                case '&': htmlSpace = true; break;\n                case '\\'': thousandSeparation = true; break;\n            }\n\n            // parameters may be null, undefined, empty-string or real valued\n            // we want to ignore null, undefined and empty-string values\n\n            if (!minWidth) {\n                minWidth = 0;\n            } \n            else if (minWidth == '*') {\n                minWidth = +a[i++];\n            } \n            else if (minWidth.charAt(0) == '*') {\n                minWidth = +a[minWidth.slice(1, -1)];\n            } \n            else {\n                minWidth = +minWidth;\n            }\n\n            // Note: undocumented perl feature:\n            if (minWidth < 0) {\n                minWidth = -minWidth;\n                leftJustify = true;\n            }\n\n            if (!isFinite(minWidth)) {\n                throw new Error('$.jqplot.sprintf: (minimum-)width must be finite');\n            }\n\n            if (!precision) {\n                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);\n            } \n            else if (precision == '*') {\n                precision = +a[i++];\n            } \n            else if (precision.charAt(0) == '*') {\n                precision = +a[precision.slice(1, -1)];\n            } \n            else {\n                precision = +precision;\n            }\n\n            // grab value using valueIndex if required?\n            var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\n\n            switch (type) {\n            case 's': {\n                if (value == null) {\n                    return '';\n                }\n                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, htmlSpace);\n            }\n            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad, htmlSpace);\n            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad,htmlSpace);\n            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);\n            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);\n            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace).toUpperCase();\n            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);\n            case 'i': {\n              var number = parseInt(+value, 10);\n              if (isNaN(number)) {\n                return '';\n              }\n              var prefix = number < 0 ? '-' : positivePrefix;\n              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))): String(Math.abs(number));\n              value = prefix + pad(number_str, precision, '0', false);\n              //value = prefix + pad(String(Math.abs(number)), precision, '0', false);\n              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);\n                  }\n            case 'd': {\n              var number = Math.round(+value);\n              if (isNaN(number)) {\n                return '';\n              }\n              var prefix = number < 0 ? '-' : positivePrefix;\n              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))): String(Math.abs(number));\n              value = prefix + pad(number_str, precision, '0', false);\n              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);\n                  }\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G':\n                      {\n                      var number = +value;\n                      if (isNaN(number)) {\n                          return '';\n                      }\n                      var prefix = number < 0 ? '-' : positivePrefix;\n                      var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n                      var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n                      var number_str = Math.abs(number)[method](precision);\n                      \n                      // Apply the decimal mark properly by splitting the number by the\n                      //   decimalMark, applying thousands separator, and then placing it\n                      //   back in.\n                      var parts = number_str.toString().split('.');\n                      parts[0] = thousandSeparation ? thousand_separate(parts[0]) : parts[0];\n                      number_str = parts.join($.jqplot.sprintf.decimalMark);\n                      \n                      value = prefix + number_str;\n                      var justified = justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();\n                      \n                      return justified;\n                  }\n            case 'p':\n            case 'P':\n            {\n                // make sure number is a number\n                var number = +value;\n                if (isNaN(number)) {\n                    return '';\n                }\n                var prefix = number < 0 ? '-' : positivePrefix;\n\n                var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);\n                var sd = (parts[0].indexOf('.') != -1) ? parts[0].length - 1 : String(number).length;\n                var zeros = (parts[1] < 0) ? -parts[1] - 1 : 0;\n                \n                if (Math.abs(number) < 1) {\n                    if (sd + zeros  <= precision) {\n                        value = prefix + Math.abs(number).toPrecision(sd);\n                    }\n                    else {\n                        if (sd  <= precision - 1) {\n                            value = prefix + Math.abs(number).toExponential(sd-1);\n                        }\n                        else {\n                            value = prefix + Math.abs(number).toExponential(precision-1);\n                        }\n                    }\n                }\n                else {\n                    var prec = (sd <= precision) ? sd : precision;\n                    value = prefix + Math.abs(number).toPrecision(prec);\n                }\n                var textTransform = ['toString', 'toUpperCase']['pP'.indexOf(type) % 2];\n                return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();\n            }\n            case 'n': return '';\n            default: return substring;\n            }\n        });\n    };\n\n    $.jqplot.sprintf.thousandsSeparator = ',';\n    // Specifies the decimal mark for floating point values. By default a period '.'\n    // is used. If you change this value to for example a comma be sure to also\n    // change the thousands separator or else this won't work since a simple String\n    // replace is used (replacing all periods with the mark specified here).\n    $.jqplot.sprintf.decimalMark = '.';\n    \n    $.jqplot.sprintf.regex = /%%|%(\\d+\\$)?([-+#0&\\' ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([nAscboxXuidfegpEGP])/g;\n\n    $.jqplot.getSignificantFigures = function(number) {\n        var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);\n        // total significant digits\n        var sd = (parts[0].indexOf('.') != -1) ? parts[0].length - 1 : parts[0].length;\n        var zeros = (parts[1] < 0) ? -parts[1] - 1 : 0;\n        // exponent\n        var expn = parseInt(parts[1], 10);\n        // digits to the left of the decimal place\n        var dleft = (expn + 1 > 0) ? expn + 1 : 0;\n        // digits to the right of the decimal place\n        var dright = (sd <= dleft) ? 0 : sd - expn - 1;\n        return {significantDigits: sd, digitsLeft: dleft, digitsRight: dright, zeros: zeros, exponent: expn} ;\n    };\n\n    $.jqplot.getPrecision = function(number) {\n        return $.jqplot.getSignificantFigures(number).digitsRight;\n    };\n\n  \n\n\n    var backCompat = $.uiBackCompat !== false;\n\n    $.jqplot.effects = {\n        effect: {}\n    };\n\n    // prefix used for storing data on .data()\n    var dataSpace = \"jqplot.storage.\";\n\n    /******************************************************************************/\n    /*********************************** EFFECTS **********************************/\n    /******************************************************************************/\n\n    $.extend( $.jqplot.effects, {\n        version: \"1.9pre\",\n\n        // Saves a set of properties in a data storage\n        save: function( element, set ) {\n            for( var i=0; i < set.length; i++ ) {\n                if ( set[ i ] !== null ) {\n                    element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );\n                }\n            }\n        },\n\n        // Restores a set of previously saved properties from a data storage\n        restore: function( element, set ) {\n            for( var i=0; i < set.length; i++ ) {\n                if ( set[ i ] !== null ) {\n                    element.css( set[ i ], element.data( dataSpace + set[ i ] ) );\n                }\n            }\n        },\n\n        setMode: function( el, mode ) {\n            if (mode === \"toggle\") {\n                mode = el.is( \":hidden\" ) ? \"show\" : \"hide\";\n            }\n            return mode;\n        },\n\n        // Wraps the element around a wrapper that copies position properties\n        createWrapper: function( element ) {\n\n            // if the element is already wrapped, return it\n            if ( element.parent().is( \".ui-effects-wrapper\" )) {\n                return element.parent();\n            }\n\n            // wrap the element\n            var props = {\n                    width: element.outerWidth(true),\n                    height: element.outerHeight(true),\n                    \"float\": element.css( \"float\" )\n                },\n                wrapper = $( \"<div></div>\" )\n                    .addClass( \"ui-effects-wrapper\" )\n                    .css({\n                        fontSize: \"100%\",\n                        background: \"transparent\",\n                        border: \"none\",\n                        margin: 0,\n                        padding: 0\n                    }),\n                // Store the size in case width/height are defined in % - Fixes #5245\n                size = {\n                    width: element.width(),\n                    height: element.height()\n                },\n                active = document.activeElement;\n\n            element.wrap( wrapper );\n\n            // Fixes #7595 - Elements lose focus when wrapped.\n            if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n                $( active ).focus();\n            }\n\n            wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element\n\n            // transfer positioning properties to the wrapper\n            if ( element.css( \"position\" ) === \"static\" ) {\n                wrapper.css({ position: \"relative\" });\n                element.css({ position: \"relative\" });\n            } else {\n                $.extend( props, {\n                    position: element.css( \"position\" ),\n                    zIndex: element.css( \"z-index\" )\n                });\n                $.each([ \"top\", \"left\", \"bottom\", \"right\" ], function(i, pos) {\n                    props[ pos ] = element.css( pos );\n                    if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {\n                        props[ pos ] = \"auto\";\n                    }\n                });\n                element.css({\n                    position: \"relative\",\n                    top: 0,\n                    left: 0,\n                    right: \"auto\",\n                    bottom: \"auto\"\n                });\n            }\n            element.css(size);\n\n            return wrapper.css( props ).show();\n        },\n\n        removeWrapper: function( element ) {\n            var active = document.activeElement;\n\n            if ( element.parent().is( \".ui-effects-wrapper\" ) ) {\n                element.parent().replaceWith( element );\n\n                // Fixes #7595 - Elements lose focus when wrapped.\n                if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n                    $( active ).focus();\n                }\n            }\n\n\n            return element;\n        }\n    });\n\n    // return an effect options object for the given parameters:\n    function _normalizeArguments( effect, options, speed, callback ) {\n\n        // short path for passing an effect options object:\n        if ( $.isPlainObject( effect ) ) {\n            return effect;\n        }\n\n        // convert to an object\n        effect = { effect: effect };\n\n        // catch (effect)\n        if ( options === undefined ) {\n            options = {};\n        }\n\n        // catch (effect, callback)\n        if ( $.isFunction( options ) ) {\n            callback = options;\n            speed = null;\n            options = {};\n        }\n\n        // catch (effect, speed, ?)\n        if ( $.type( options ) === \"number\" || $.fx.speeds[ options ]) {\n            callback = speed;\n            speed = options;\n            options = {};\n        }\n\n        // catch (effect, options, callback)\n        if ( $.isFunction( speed ) ) {\n            callback = speed;\n            speed = null;\n        }\n\n        // add options to effect\n        if ( options ) {\n            $.extend( effect, options );\n        }\n\n        speed = speed || options.duration;\n        effect.duration = $.fx.off ? 0 : typeof speed === \"number\"\n            ? speed : speed in $.fx.speeds ? $.fx.speeds[ speed ] : $.fx.speeds._default;\n\n        effect.complete = callback || options.complete;\n\n        return effect;\n    }\n\n    function standardSpeed( speed ) {\n        // valid standard speeds\n        if ( !speed || typeof speed === \"number\" || $.fx.speeds[ speed ] ) {\n            return true;\n        }\n\n        // invalid strings - treat as \"normal\" speed\n        if ( typeof speed === \"string\" && !$.jqplot.effects.effect[ speed ] ) {\n            // TODO: remove in 2.0 (#7115)\n            if ( backCompat && $.jqplot.effects[ speed ] ) {\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    $.fn.extend({\n        jqplotEffect: function( effect, options, speed, callback ) {\n            var args = _normalizeArguments.apply( this, arguments ),\n                mode = args.mode,\n                queue = args.queue,\n                effectMethod = $.jqplot.effects.effect[ args.effect ],\n\n                // DEPRECATED: remove in 2.0 (#7115)\n                oldEffectMethod = !effectMethod && backCompat && $.jqplot.effects[ args.effect ];\n\n            if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {\n                // delegate to the original method (e.g., .show()) if possible\n                if ( mode ) {\n                    return this[ mode ]( args.duration, args.complete );\n                } else {\n                    return this.each( function() {\n                        if ( args.complete ) {\n                            args.complete.call( this );\n                        }\n                    });\n                }\n            }\n\n            function run( next ) {\n                var elem = $( this ),\n                    complete = args.complete,\n                    mode = args.mode;\n\n                function done() {\n                    if ( $.isFunction( complete ) ) {\n                        complete.call( elem[0] );\n                    }\n                    if ( $.isFunction( next ) ) {\n                        next();\n                    }\n                }\n\n                // if the element is hiddden and mode is hide,\n                // or element is visible and mode is show\n                if ( elem.is( \":hidden\" ) ? mode === \"hide\" : mode === \"show\" ) {\n                    done();\n                } else {\n                    effectMethod.call( elem[0], args, done );\n                }\n            }\n\n            // TODO: remove this check in 2.0, effectMethod will always be true\n            if ( effectMethod ) {\n                return queue === false ? this.each( run ) : this.queue( queue || \"fx\", run );\n            } else {\n                // DEPRECATED: remove in 2.0 (#7115)\n                return oldEffectMethod.call(this, {\n                    options: args,\n                    duration: args.duration,\n                    callback: args.complete,\n                    mode: args.mode\n                });\n            }\n        }\n    });\n\n\n\n\n    var rvertical = /up|down|vertical/,\n        rpositivemotion = /up|left|vertical|horizontal/;\n\n    $.jqplot.effects.effect.blind = function( o, done ) {\n        // Create element\n        var el = $( this ),\n            props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n            mode = $.jqplot.effects.setMode( el, o.mode || \"hide\" ),\n            direction = o.direction || \"up\",\n            vertical = rvertical.test( direction ),\n            ref = vertical ? \"height\" : \"width\",\n            ref2 = vertical ? \"top\" : \"left\",\n            motion = rpositivemotion.test( direction ),\n            animation = {},\n            show = mode === \"show\",\n            wrapper, distance, top;\n\n        // // if already wrapped, the wrapper's properties are my property. #6245\n        if ( el.parent().is( \".ui-effects-wrapper\" ) ) {\n            $.jqplot.effects.save( el.parent(), props );\n        } else {\n            $.jqplot.effects.save( el, props );\n        }\n        el.show();\n        top = parseInt(el.css('top'), 10);\n        wrapper = $.jqplot.effects.createWrapper( el ).css({\n            overflow: \"hidden\"\n        });\n\n        distance = vertical ? wrapper[ ref ]() + top : wrapper[ ref ]();\n\n        animation[ ref ] = show ? String(distance) : '0';\n        if ( !motion ) {\n            el\n                .css( vertical ? \"bottom\" : \"right\", 0 )\n                .css( vertical ? \"top\" : \"left\", \"\" )\n                .css({ position: \"absolute\" });\n            animation[ ref2 ] = show ? '0' : String(distance);\n        }\n\n        // // start at 0 if we are showing\n        if ( show ) {\n            wrapper.css( ref, 0 );\n            if ( ! motion ) {\n                wrapper.css( ref2, distance );\n            }\n        }\n\n        // // Animate\n        wrapper.animate( animation, {\n            duration: o.duration,\n            easing: o.easing,\n            queue: false,\n            complete: function() {\n                if ( mode === \"hide\" ) {\n                    el.hide();\n                }\n                $.jqplot.effects.restore( el, props );\n                $.jqplot.effects.removeWrapper( el );\n                done();\n            }\n        });\n\n    };\n\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdXBkYXRlZC1qcXBsb3QvZGlzdC9qcXVlcnkudXBkYXRlZC1qcXBsb3QuanM/ZWUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRpdGxlOiBqcVBsb3QgQ2hhcnRzXG4gKiBcbiAqIFB1cmUgSmF2YVNjcmlwdCBwbG90dGluZyBwbHVnaW4gZm9yIGpRdWVyeS5cbiAqIFxuICogQWJvdXQ6IFZlcnNpb25cbiAqIFxuICogdmVyc2lvbjogMS4wLjktMSBcbiAqIHJldmlzaW9uOiAyZGJjZGU4XG4gKiBcbiAqIEFib3V0OiBDb3B5cmlnaHQgJiBMaWNlbnNlXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDE2IENocmlzIExlb25lbGxvXG4gKiBqcVBsb3QgaXMgY3VycmVudGx5IGF2YWlsYWJsZSBmb3IgdXNlIGluIGFsbCBwZXJzb25hbCBvciBjb21tZXJjaWFsIHByb2plY3RzIFxuICogdW5kZXIgYm90aCB0aGUgTUlUIGFuZCBHUEwgdmVyc2lvbiAyLjAgbGljZW5zZXMuIFRoaXMgbWVhbnMgdGhhdCB5b3UgY2FuIFxuICogY2hvb3NlIHRoZSBsaWNlbnNlIHRoYXQgYmVzdCBzdWl0cyB5b3VyIHByb2plY3QgYW5kIHVzZSBpdCBhY2NvcmRpbmdseS5cbiAqIFxuICogU2VlIDxHUEwgVmVyc2lvbiAyPiBhbmQgPE1JVCBMaWNlbnNlPiBjb250YWluZWQgd2l0aGluIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uLiBcbiAqXG4gKiBUaGUgYXV0aG9yIHdvdWxkIGFwcHJlY2lhdGUgYW4gZW1haWwgbGV0dGluZyBoaW0ga25vdyBvZiBhbnkgc3Vic3RhbnRpYWxcbiAqIHVzZSBvZiBqcVBsb3QuICBZb3UgY2FuIHJlYWNoIHRoZSBhdXRob3IgYXQ6IGNocmlzIGF0IGpxcGxvdCBkb3QgY29tIFxuICogb3Igc2VlIGh0dHA6Ly93d3cuanFwbG90LmNvbS9pbmZvLnBocC4gIFRoaXMgaXMsIG9mIGNvdXJzZSwgbm90IHJlcXVpcmVkLlxuICpcbiAqIElmIHlvdSBhcmUgZmVlbGluZyBraW5kIGFuZCBnZW5lcm91cywgY29uc2lkZXIgc3VwcG9ydGluZyB0aGUgcHJvamVjdCBieVxuICogbWFraW5nIGEgZG9uYXRpb24gYXQ6IGh0dHA6Ly93d3cuanFwbG90LmNvbS9kb25hdGUucGhwLlxuICpcbiAqIHNwcmludGYgZnVuY3Rpb25zIGNvbnRhaW5lZCBpbiBqcXBsb3Quc3ByaW50Zi5qcyBieSBBc2ggU2VhcmxlOlxuICogXG4gKiAgICAgdmVyc2lvbiAyMDA3LjA0LjI3XG4gKiAgICAgYXV0aG9yIEFzaCBTZWFybGVcbiAqICAgICBodHRwOi8vaGV4bWVuLmNvbS9ibG9nLzIwMDcvMDMvcHJpbnRmLXNwcmludGYvXG4gKiAgICAgaHR0cDovL2hleG1lbi5jb20vanMvc3ByaW50Zi5qc1xuICogICAgIFRoZSBhdXRob3IgKEFzaCBTZWFybGUpIGhhcyBwbGFjZWQgdGhpcyBjb2RlIGluIHRoZSBwdWJsaWMgZG9tYWluOlxuICogICAgIFwiVGhpcyBjb2RlIGlzIHVucmVzdHJpY3RlZDogeW91IGFyZSBmcmVlIHRvIHVzZSBpdCBob3dldmVyIHlvdSBsaWtlLlwiXG4gKiBcbiAqIFxuICogQWJvdXQ6IEludHJvZHVjdGlvblxuICogXG4gKiBqcVBsb3QgcmVxdWlyZXMgalF1ZXJ5ICgxLjQrIHJlcXVpcmVkIGZvciBjZXJ0YWluIGZlYXR1cmVzKS4galF1ZXJ5IDEuNC4yIGlzIGluY2x1ZGVkIGluIHRoZSBkaXN0cmlidXRpb24uICBcbiAqIFRvIHVzZSBqcVBsb3QgaW5jbHVkZSBqUXVlcnksIHRoZSBqcVBsb3QgalF1ZXJ5IHBsdWdpbiwgdGhlIGpxUGxvdCBjc3MgZmlsZSBhbmQgb3B0aW9uYWxseSBcbiAqIHRoZSBleGNhbnZhcyBzY3JpcHQgZm9yIElFIHN1cHBvcnQgaW4geW91ciB3ZWIgcGFnZTpcbiAqIFxuICogPiA8IS0tW2lmIGx0IElFIDldPjxzY3JpcHQgbGFuZ3VhZ2U9XCJqYXZhc2NyaXB0XCIgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cImV4Y2FudmFzLmpzXCI+PC9zY3JpcHQ+PCFbZW5kaWZdLS0+XG4gKiA+IDxzY3JpcHQgbGFuZ3VhZ2U9XCJqYXZhc2NyaXB0XCIgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cImpxdWVyeS0xLjQuNC5taW4uanNcIj48L3NjcmlwdD5cbiAqID4gPHNjcmlwdCBsYW5ndWFnZT1cImphdmFzY3JpcHRcIiB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwianF1ZXJ5LmpxcGxvdC5taW4uanNcIj48L3NjcmlwdD5cbiAqID4gPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiIGhyZWY9XCJqcXVlcnkuanFwbG90LmNzc1wiIC8+XG4gKiBcbiAqIGpxUGxvdCBjYW4gYmUgY3VzdG9taXplZCBieSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0cyBvZiBhbnkgb2YgdGhlIG9iamVjdHMgd2hpY2ggbWFrZVxuICogdXAgdGhlIHBsb3QuIFRoZSBnZW5lcmFsIHVzYWdlIG9mIGpxcGxvdCBpczpcbiAqIFxuICogPiBjaGFydCA9ICQuanFwbG90KCd0YXJnZXRFbGVtSWQnLCBbZGF0YUFycmF5LC4uLl0sIHtvcHRpb25zT2JqZWN0fSk7XG4gKiBcbiAqIFRoZSBvcHRpb25zIGF2YWlsYWJsZSB0byBqcXBsb3QgYXJlIGRldGFpbGVkIGluIDxqcVBsb3QgT3B0aW9ucz4gaW4gdGhlIGpxUGxvdE9wdGlvbnMudHh0IGZpbGUuXG4gKiBcbiAqIEFuIGFjdHVhbCBjYWxsIHRvICQuanFwbG90KCkgbWF5IGxvb2sgbGlrZSB0aGUgXG4gKiBleGFtcGxlcyBiZWxvdzpcbiAqIFxuICogPiBjaGFydCA9ICQuanFwbG90KCdjaGFydGRpdicsICBbW1sxLCAyXSxbMyw1LjEyXSxbNSwxMy4xXSxbNywzMy42XSxbOSw4NS45XSxbMTEsMjE5LjldXV0pO1xuICogXG4gKiBvclxuICogXG4gKiA+IGRhdGFBcnJheSA9IFszNCwxMiw0Myw1NSw3N107XG4gKiA+IGNoYXJ0ID0gJC5qcXBsb3QoJ3RhcmdldEVsZW1JZCcsIFtkYXRhQXJyYXksIC4uLl0sIHt0aXRsZTonTXkgUGxvdCcsIGF4ZXM6e3lheGlzOnttaW46MjAsIG1heDoxMDB9fX0pO1xuICogXG4gKiBGb3IgbW9yZSBpbmZvcnJtYXRpb24sIHNlZSA8anFQbG90IFVzYWdlPi5cbiAqIFxuICogQWJvdXQ6IFVzYWdlXG4gKiBcbiAqIFNlZSA8anFQbG90IFVzYWdlPlxuICogXG4gKiBBYm91dDogQXZhaWxhYmxlIE9wdGlvbnMgXG4gKiBcbiAqIFNlZSA8anFQbG90IE9wdGlvbnM+IGZvciBhIGxpc3Qgb2Ygb3B0aW9ucyBhdmFpbGFibGUgdGhvcnVnaCB0aGUgb3B0aW9ucyBvYmplY3QgKG5vdCBjb21wbGV0ZSB5ZXQhKVxuICogXG4gKiBBYm91dDogT3B0aW9ucyBVc2FnZVxuICogXG4gKiBTZWUgPE9wdGlvbnMgVHV0b3JpYWw+XG4gKiBcbiAqIEFib3V0OiBDaGFuZ2VzXG4gKiBcbiAqIFNlZSA8Q2hhbmdlIExvZz5cbiAqIFxuICovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgLy8gbWFrZSBzdXJlIHVuZGVmaW5lZCBpcyB1bmRlZmluZWRcbiAgICB2YXIgdW5kZWZpbmVkO1xuICAgIFxuICAgICQuZm4uZW1wdHlGb3JjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9ICQodGhpcylbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAkLmNsZWFuRGF0YSggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgaWYgKCQuanFwbG90LnVzZV9leGNhbnZhcykge1xuICAgICAgICAgIGVsZW0ub3V0ZXJIVE1MID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBudWxsO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiAkKHRoaXMpO1xuICAgIH07XG4gIFxuICAgICQuZm4ucmVtb3ZlQ2hpbGRGb3JjZSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgd2hpbGUgKCBwYXJlbnQuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZEZvcmNlKCBwYXJlbnQuZmlyc3RDaGlsZCApO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoIHBhcmVudC5maXJzdENoaWxkICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQuZm4uanFwbG90ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhcyA9IFtdO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IFtdO1xuICAgICAgICAvLyBzZWUgaG93IG1hbnkgZGF0YSBhcnJheXMgd2UgaGF2ZVxuICAgICAgICBmb3IgKHZhciBpPTAsIGw9YXJndW1lbnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoYXJndW1lbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGRhdGFzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChhcmd1bWVudHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdGlkLCBcbiAgICAgICAgICAgICAgICBwbG90LCBcbiAgICAgICAgICAgICAgICAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgZGwgPSBkYXRhcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb2wgPSBvcHRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkYXRhLCBcbiAgICAgICAgICAgICAgICBvcHRzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBkbCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGwgPyBkYXRhc1tkbC0xXSA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IG9sKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IG9wdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IG9sID8gb3B0aW9uc1tvbC0xXSA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvZXMgZWwgaGF2ZSBhbiBpZD9cbiAgICAgICAgICAgIC8vIGlmIG5vdCBhc3NpZ24gaXQgb25lLlxuICAgICAgICAgICAgdGlkID0gJHRoaXMuYXR0cignaWQnKTtcbiAgICAgICAgICAgIGlmICh0aWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRpZCA9ICdqcXBsb3RfdGFyZ2V0XycgKyAkLmpxcGxvdC50YXJnZXRDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXR0cignaWQnLCB0aWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbG90ID0gJC5qcXBsb3QodGlkLCBkYXRhLCBvcHRzKTtcblxuICAgICAgICAgICAgJHRoaXMuZGF0YSgnanFwbG90JywgcGxvdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZTogJC5qcXBsb3RcbiAgICAgKiBqUXVlcnkgZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB1c2VyIHRvIGNyZWF0ZSBhIHBsb3QuXG4gICAgICogIFxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogdGFyZ2V0IC0gSUQgb2YgdGFyZ2V0IGVsZW1lbnQgdG8gcmVuZGVyIHRoZSBwbG90IGludG8uXG4gICAgICogZGF0YSAtIGFuIGFycmF5IG9mIGRhdGEgc2VyaWVzLlxuICAgICAqIG9wdGlvbnMgLSB1c2VyIGRlZmluZWQgb3B0aW9ucyBvYmplY3QuICBTZWUgdGhlIGluZGl2aWR1YWwgY2xhc3NlcyBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgICogXG4gICAgICogUHJvcGVydGllczpcbiAgICAgKiBjb25maWcgLSBvYmplY3QgdG8gaG9sZCBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGZvciBqcVBsb3QgcGxvdCBvYmplY3QuXG4gICAgICogXG4gICAgICogYXR0cmlidXRlczpcbiAgICAgKiBlbmFibGVQbHVnaW5zIC0gRmFsc2UgdG8gZGlzYWJsZSBwbHVnaW5zIGJ5IGRlZmF1bHQuICBQbHVnaW5zIG11c3QgdGhlbiBiZSBleHBsaWNpdGx5IFxuICAgICAqICAgZW5hYmxlZCBpbiB0aGUgaW5kaXZpZHVhbCBwbG90IG9wdGlvbnMuICBEZWZhdWx0OiBmYWxzZS5cbiAgICAgKiAgIFRoaXMgcHJvcGVydHkgc2V0cyB0aGUgXCJzaG93XCIgcHJvcGVydHkgb2YgY2VydGFpbiBwbHVnaW5zIHRvIHRydWUgb3IgZmFsc2UuXG4gICAgICogICBPbmx5IHBsdWdpbnMgdGhhdCBjYW4gYmUgaW1tZWRpYXRlbHkgYWN0aXZlIHVwb24gbG9hZGluZyBhcmUgYWZmZWN0ZWQuICBUaGlzIGluY2x1ZGVzXG4gICAgICogICBub24tcmVuZGVyZXIgcGx1Z2lucyBsaWtlIGN1cnNvciwgZHJhZ2FibGUsIGhpZ2hsaWdodGVyLCBhbmQgdHJlbmRsaW5lLlxuICAgICAqIGRlZmF1bHRIZWlnaHQgLSBEZWZhdWx0IGhlaWdodCBmb3IgcGxvdHMgd2hlcmUgbm8gY3NzIGhlaWdodCBzcGVjaWZpY2F0aW9uIGV4aXN0cy4gIFRoaXNcbiAgICAgKiAgIGlzIGEganFwbG90IHdpZGUgZGVmYXVsdC5cbiAgICAgKiBkZWZhdWx0V2lkdGggLSBEZWZhdWx0IGhlaWdodCBmb3IgcGxvdHMgd2hlcmUgbm8gY3NzIGhlaWdodCBzcGVjaWZpY2F0aW9uIGV4aXN0cy4gIFRoaXNcbiAgICAgKiAgIGlzIGEganFwbG90IHdpZGUgZGVmYXVsdC5cbiAgICAgKi9cblxuICAgICQuanFwbG90ID0gZnVuY3Rpb24odGFyZ2V0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfZGF0YSA9IG51bGwsIF9vcHRpb25zID0gbnVsbDtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgX29wdGlvbnMgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9kYXRhID09PSBudWxsICYmIF9vcHRpb25zICE9PSBudWxsICYmIF9vcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIF9kYXRhID0gX29wdGlvbnMuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbG90ID0gbmV3IGpxUGxvdCgpO1xuICAgICAgICAvLyByZW1vdmUgYW55IGVycm9yIGNsYXNzIHRoYXQgbWF5IGJlIHN0dWNrIG9uIHRhcmdldC5cbiAgICAgICAgJCgnIycrdGFyZ2V0KS5yZW1vdmVDbGFzcygnanFwbG90LWVycm9yJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoJC5qcXBsb3QuY29uZmlnLmNhdGNoRXJyb3JzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBsb3QuaW5pdCh0YXJnZXQsIF9kYXRhLCBfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcGxvdC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgcGxvdC50aGVtZUVuZ2luZS5pbml0LmNhbGwocGxvdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICQuanFwbG90LmNvbmZpZy5lcnJvck1lc3NhZ2UgfHwgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICQoJyMnK3RhcmdldCkuYXBwZW5kKCc8ZGl2IGNsYXNzPVwianFwbG90LWVycm9yLW1lc3NhZ2VcIj4nK21zZysnPC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgJCgnIycrdGFyZ2V0KS5hZGRDbGFzcygnanFwbG90LWVycm9yJyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KS5zdHlsZS5iYWNrZ3JvdW5kID0gJC5qcXBsb3QuY29uZmlnLmVycm9yQmFja2dyb3VuZDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpLnN0eWxlLmJvcmRlciA9ICQuanFwbG90LmNvbmZpZy5lcnJvckJvcmRlcjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpLnN0eWxlLmZvbnRGYW1pbHkgPSAkLmpxcGxvdC5jb25maWcuZXJyb3JGb250RmFtaWx5O1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkuc3R5bGUuZm9udFNpemUgPSAkLmpxcGxvdC5jb25maWcuZXJyb3JGb250U2l6ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpLnN0eWxlLmZvbnRTdHlsZSA9ICQuanFwbG90LmNvbmZpZy5lcnJvckZvbnRTdHlsZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpLnN0eWxlLmZvbnRXZWlnaHQgPSAkLmpxcGxvdC5jb25maWcuZXJyb3JGb250V2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgXG4gICAgICAgICAgICBwbG90LmluaXQodGFyZ2V0LCBfZGF0YSwgX29wdGlvbnMpO1xuICAgICAgICAgICAgcGxvdC5kcmF3KCk7XG4gICAgICAgICAgICBwbG90LnRoZW1lRW5naW5lLmluaXQuY2FsbChwbG90KTtcbiAgICAgICAgICAgIHJldHVybiBwbG90O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuanFwbG90LnZlcnNpb24gPSBcIjEuMC45LTFcIjtcbiAgICAkLmpxcGxvdC5yZXZpc2lvbiA9IFwiMmRiY2RlOFwiO1xuXG4gICAgJC5qcXBsb3QudGFyZ2V0Q291bnRlciA9IDE7XG5cbiAgICAvLyBjYW52YXMgbWFuYWdlciB0byByZXVzZSBjYW52YXNlcyBvbiB0aGUgcGxvdC5cbiAgICAvLyBTaG91bGQgaGVscCBzb2x2ZSBwcm9ibGVtIG9mIGNhbnZhc2VzIG5vdCBiZWluZyBmcmVlZCBhbmRcbiAgICAvLyBwcm9ibGVtIG9mIHdhaXRpbmcgZm9yZXZlciBmb3IgZmlyZWZveCB0byBkZWNpZGUgdG8gZnJlZSBtZW1vcnkuXG4gICAgJC5qcXBsb3QuQ2FudmFzTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBjYW52YXNlcyBhcmUgbWFuYWdlZCBnbG9iYWxseSBzbyB0aGF0IHRoZXkgY2FuIGJlIHJldXNlZFxuICAgICAgICAvLyBhY3Jvc3MgcGxvdHMgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZnJlZWRcbiAgICAgICAgaWYgKHR5cGVvZiAkLmpxcGxvdC5DYW52YXNNYW5hZ2VyLmNhbnZhc2VzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAkLmpxcGxvdC5DYW52YXNNYW5hZ2VyLmNhbnZhc2VzID0gW107XG4gICAgICAgICAgICAkLmpxcGxvdC5DYW52YXNNYW5hZ2VyLmZyZWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG15Q2FudmFzZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICAgICAgdmFyIG1ha2VOZXcgPSB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoISQuanFwbG90LnVzZV9leGNhbnZhcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5jYW52YXNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuanFwbG90LkNhbnZhc01hbmFnZXIuZnJlZVtpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU5ldyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5jYW52YXNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICQoY2FudmFzKS5yZW1vdmVDbGFzcygnanFwbG90LWNhbnZhc01hbmFnZXItZnJlZScpLmFkZENsYXNzKCdqcXBsb3QtY2FudmFzTWFuYWdlci1pbnVzZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5mcmVlW2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNhbnZhc2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ha2VOZXcpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBteUNhbnZhc2VzLnB1c2goJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5jYW52YXNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICQuanFwbG90LkNhbnZhc01hbmFnZXIuY2FudmFzZXMucHVzaChjYW52YXMpO1xuICAgICAgICAgICAgICAgICQuanFwbG90LkNhbnZhc01hbmFnZXIuZnJlZS5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGhhcyB0byBiZSB1c2VkIGFmdGVyIHNldHRpbmdzIHRoZSBkaW1lc2lvbnNcbiAgICAgICAgLy8gb24gdGhlIGVsZW1lbnQgcmV0dXJuZWQgYnkgZ2V0Q2FudmFzKClcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAoJC5qcXBsb3QudXNlX2V4Y2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5HX3ZtbENhbnZhc01hbmFnZXIuaW5pdEVsZW1lbnQoY2FudmFzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgdmFyIGNhbnZhc0JhY2tpbmdTY2FsZSA9IDE7XG4gICAgICAgICAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmIChjY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyA8IDIpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQmFja2luZ1NjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzQmFja2luZ1NjYWxlICogY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0JhY2tpbmdTY2FsZSAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvbGRXaWR0aCArICdweCc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIGNjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICBjY3R4LnNjYWxlKGNhbnZhc0JhY2tpbmdTY2FsZSwgY2FudmFzQmFja2luZ1NjYWxlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmZyZWVBbGxDYW52YXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGw9bXlDYW52YXNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVDYW52YXMobXlDYW52YXNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBteUNhbnZhc2VzID0gW107XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5mcmVlQ2FudmFzID0gZnVuY3Rpb24oaWR4KSB7XG4gICAgICAgICAgICBpZiAoJC5qcXBsb3QudXNlX2V4Y2FudmFzICYmIHdpbmRvdy5HX3ZtbENhbnZhc01hbmFnZXIudW5pbml0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhjYW52YXMgY2FuJ3QgYmUgcmV1c2VkLCBidXQgcHJvcGVybHkgdW5zZXRcbiAgICAgICAgICAgICAgICB3aW5kb3cuR192bWxDYW52YXNNYW5hZ2VyLnVuaW5pdEVsZW1lbnQoJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5jYW52YXNlc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAkLmpxcGxvdC5DYW52YXNNYW5hZ2VyLmNhbnZhc2VzW2lkeF0gPSBudWxsO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSAkLmpxcGxvdC5DYW52YXNNYW5hZ2VyLmNhbnZhc2VzW2lkeF07XG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgJChjYW52YXMpLnVuYmluZCgpLnJlbW92ZUF0dHIoJ2NsYXNzJykucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAvLyBTdHlsZSBhdHRyaWJ1dGVzIHNlZW1lZCB0byBiZSBzdGlsbCBoYW5naW5nIGFyb3VuZC4gIHdpZXJkLiAgU29tZSB0aWNrc1xuICAgICAgICAgICAgICAgIC8vIHN0aWxsIHJldGFpbmVkIGEgbGVmdDogMHB4IGF0dHJpYnV0ZSBhZnRlciByZXVzaW5nIGEgY2FudmFzLlxuICAgICAgICAgICAgICAgICQoY2FudmFzKS5jc3Moe2xlZnQ6ICcnLCB0b3A6ICcnLCBwb3NpdGlvbjogJyd9KTtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHNpemUgdG8gMCBtYXkgc2F2ZSBtZW1vcnkgb2YgdW51c2VkIGNhbnZhc2VzP1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgJC5qcXBsb3QuQ2FudmFzTWFuYWdlci5mcmVlW2lkeF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9O1xuXG4gICAgICAgICAgICBcbiAgICAvLyBDb252aWVuZW5jZSBmdW5jdGlvbiB0aGF0IHdvbid0IGhhbmcgSUUgb3IgRkYgd2l0aG91dCBGaXJlQnVnLlxuICAgICQuanFwbG90LmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgICAgIFxuICAgICQuanFwbG90LmNvbmZpZyA9IHtcbiAgICAgICAgYWRkRG9tUmVmZXJlbmNlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlUGx1Z2luczpmYWxzZSxcbiAgICAgICAgZGVmYXVsdEhlaWdodDozMDAsXG4gICAgICAgIGRlZmF1bHRXaWR0aDo0MDAsXG4gICAgICAgIFVUQ0FkanVzdDpmYWxzZSxcbiAgICAgICAgdGltZXpvbmVPZmZzZXQ6IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiAnJyxcbiAgICAgICAgZXJyb3JCYWNrZ3JvdW5kOiAnJyxcbiAgICAgICAgZXJyb3JCb3JkZXI6ICcnLFxuICAgICAgICBlcnJvckZvbnRGYW1pbHk6ICcnLFxuICAgICAgICBlcnJvckZvbnRTaXplOiAnJyxcbiAgICAgICAgZXJyb3JGb250U3R5bGU6ICcnLFxuICAgICAgICBlcnJvckZvbnRXZWlnaHQ6ICcnLFxuICAgICAgICBjYXRjaEVycm9yczogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRUaWNrRm9ybWF0U3RyaW5nOiBcIiUuMWZcIixcbiAgICAgICAgZGVmYXVsdENvbG9yczogWyBcIiM0YmIyYzVcIiwgXCIjRUFBMjI4XCIsIFwiI2M1YjQ3ZlwiLCBcIiM1Nzk1NzVcIiwgXCIjODM5NTU3XCIsIFwiIzk1OGMxMlwiLCBcIiM5NTM1NzlcIiwgXCIjNGI1ZGU0XCIsIFwiI2Q4YjgzZlwiLCBcIiNmZjU4MDBcIiwgXCIjMDA4NWNjXCIsIFwiI2M3NDdhM1wiLCBcIiNjZGRmNTRcIiwgXCIjRkJEMTc4XCIsIFwiIzI2QjRFM1wiLCBcIiNiZDcwYzdcIl0sXG4gICAgICAgIGRlZmF1bHROZWdhdGl2ZUNvbG9yczogWyBcIiM0OTg5OTFcIiwgXCIjQzA4ODQwXCIsIFwiIzlGOTI3NFwiLCBcIiM1NDZENjFcIiwgXCIjNjQ2QzRBXCIsIFwiIzZGNjYyMVwiLCBcIiM2RTNGNUZcIiwgXCIjNEY2NEIwXCIsIFwiI0E4OTA1MFwiLCBcIiNDNDU5MjNcIiwgXCIjMTg3Mzk5XCIsIFwiIzk0NTM4MVwiLCBcIiM5NTlFNUNcIiwgXCIjQzdBRjdCXCIsIFwiIzQ3ODM5NlwiLCBcIiM5MDcyOTRcIl0sXG4gICAgICAgIGRhc2hMZW5ndGg6IDQsXG4gICAgICAgIGdhcExlbmd0aDogNCxcbiAgICAgICAgZG90R2FwTGVuZ3RoOiAyLjUsXG4gICAgICAgIHNyY0xvY2F0aW9uOiAnanFwbG90L3NyYy8nLFxuICAgICAgICBwbHVnaW5Mb2NhdGlvbjogJ2pxcGxvdC9zcmMvcGx1Z2lucy8nXG4gICAgfTtcbiAgICBcbiAgICBcbiAgICAkLmpxcGxvdC5hcnJheU1heCA9IGZ1bmN0aW9uKCBhcnJheSApe1xuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoIE1hdGgsIGFycmF5ICk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5hcnJheU1pbiA9IGZ1bmN0aW9uKCBhcnJheSApe1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoIE1hdGgsIGFycmF5ICk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5lbmFibGVQbHVnaW5zID0gJC5qcXBsb3QuY29uZmlnLmVuYWJsZVBsdWdpbnM7XG4gICAgXG4gICAgLy8gY2FudmFzIHJlbGF0ZWQgdGVzdHMgdGFrZW4gZnJvbSBtb2Rlcm5pemVyOlxuICAgIC8vIENvcHlyaWdodCAoYykgMjAwOSAtIDIwMTAgRmFydWsgQXRlcy5cbiAgICAvLyBodHRwOi8vd3d3Lm1vZGVybml6ci5jb21cbiAgICBcbiAgICAkLmpxcGxvdC5zdXBwb3J0X2NhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mICQuanFwbG90LnN1cHBvcnRfY2FudmFzLnJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgJC5qcXBsb3Quc3VwcG9ydF9jYW52YXMucmVzdWx0ID0gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0OyBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJC5qcXBsb3Quc3VwcG9ydF9jYW52YXMucmVzdWx0O1xuICAgIH07XG4gICAgICAgICAgICBcbiAgICAkLmpxcGxvdC5zdXBwb3J0X2NhbnZhc190ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJC5qcXBsb3Quc3VwcG9ydF9jYW52YXNfdGV4dC5yZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuR192bWxDYW52YXNNYW5hZ2VyICE9PSB1bmRlZmluZWQgJiYgd2luZG93Lkdfdm1sQ2FudmFzTWFuYWdlci5fdmVyc2lvbiA+IDg4Nykge1xuICAgICAgICAgICAgICAgICQuanFwbG90LnN1cHBvcnRfY2FudmFzX3RleHQucmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQuanFwbG90LnN1cHBvcnRfY2FudmFzX3RleHQucmVzdWx0ID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKS5maWxsVGV4dCA9PSAnZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJC5qcXBsb3Quc3VwcG9ydF9jYW52YXNfdGV4dC5yZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC51c2VfZXhjYW52YXMgPSAoKCEkLnN1cHBvcnQuYm94TW9kZWwgfHwgISQuc3VwcG9ydC5vYmplY3RBbGwgfHwgISRzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlKSAmJiAhJC5qcXBsb3Quc3VwcG9ydF9jYW52YXMoKSkgPyB0cnVlIDogZmFsc2U7XG4gICAgXG4gICAgLyoqXG4gICAgICogXG4gICAgICogSG9va3M6IGpxUGxvdCBQdWdpbiBIb29rc1xuICAgICAqIFxuICAgICAqICQuanFwbG90LnByZUluaXRIb29rcyAtIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uXG4gICAgICogJC5qcXBsb3QucG9zdEluaXRIb29rcyAtIGNhbGxlZCBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAgKiAkLmpxcGxvdC5wcmVQYXJzZU9wdGlvbnNIb29rcyAtIGNhbGxlZCBiZWZvcmUgdXNlciBvcHRpb25zIGFyZSBwYXJzZWQuXG4gICAgICogJC5qcXBsb3QucG9zdFBhcnNlT3B0aW9uc0hvb2tzIC0gY2FsbGVkIGFmdGVyIHVzZXIgb3B0aW9ucyBhcmUgcGFyc2VkLlxuICAgICAqICQuanFwbG90LnByZURyYXdIb29rcyAtIGNhbGxlZCBiZWZvcmUgcGxvdCBkcmF3LlxuICAgICAqICQuanFwbG90LnBvc3REcmF3SG9va3MgLSBjYWxsZWQgYWZ0ZXIgcGxvdCBkcmF3LlxuICAgICAqICQuanFwbG90LnByZURyYXdTZXJpZXNIb29rcyAtIGNhbGxlZCBiZWZvcmUgZWFjaCBzZXJpZXMgaXMgZHJhd24uXG4gICAgICogJC5qcXBsb3QucG9zdERyYXdTZXJpZXNIb29rcyAtIGNhbGxlZCBhZnRlciBlYWNoIHNlcmllcyBpcyBkcmF3bi5cbiAgICAgKiAkLmpxcGxvdC5wcmVEcmF3TGVnZW5kSG9va3MgLSBjYWxsZWQgYmVmb3JlIHRoZSBsZWdlbmQgaXMgZHJhd24uXG4gICAgICogJC5qcXBsb3QuYWRkTGVnZW5kUm93SG9va3MgLSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBsZWdlbmQgZHJhdywgc28gcGx1Z2luc1xuICAgICAqICAgICBjYW4gYWRkIHJvd3MgdG8gdGhlIGxlZ2VuZCB0YWJsZS5cbiAgICAgKiAkLmpxcGxvdC5wcmVTZXJpZXNJbml0SG9va3MgLSBjYWxsZWQgYmVmb3JlIHNlcmllcyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiAkLmpxcGxvdC5wb3N0U2VyaWVzSW5pdEhvb2tzIC0gY2FsbGVkIGFmdGVyIHNlcmllcyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiAkLmpxcGxvdC5wcmVQYXJzZVNlcmllc09wdGlvbnNIb29rcyAtIGNhbGxlZCBiZWZvcmUgc2VyaWVzIHJlbGF0ZWQgb3B0aW9uc1xuICAgICAqICAgICBhcmUgcGFyc2VkLlxuICAgICAqICQuanFwbG90LnBvc3RQYXJzZVNlcmllc09wdGlvbnNIb29rcyAtIGNhbGxlZCBhZnRlciBzZXJpZXMgcmVsYXRlZCBvcHRpb25zXG4gICAgICogICAgIGFyZSBwYXJzZWQuXG4gICAgICogJC5qcXBsb3QuZXZlbnRMaXN0ZW5lckhvb2tzIC0gY2FsbGVkIGF0IHRoZSBlbmQgb2YgcGxvdCBkcmF3aW5nLCBiaW5kc1xuICAgICAqICAgICBsaXN0ZW5lcnMgdG8gdGhlIGV2ZW50IGNhbnZhcyB3aGljaCBsYXlzIG9uIHRvcCBvZiB0aGUgZ3JpZCBhcmVhLlxuICAgICAqICQuanFwbG90LnByZURyYXdTZXJpZXNTaGFkb3dIb29rcyAtIGNhbGxlZCBiZWZvcmUgc2VyaWVzIHNoYWRvd3MgYXJlIGRyYXduLlxuICAgICAqICQuanFwbG90LnBvc3REcmF3U2VyaWVzU2hhZG93SG9va3MgLSBjYWxsZWQgYWZ0ZXIgc2VyaWVzIHNoYWRvd3MgYXJlIGRyYXduLlxuICAgICAqIFxuICAgICAqL1xuICAgIFxuICAgICQuanFwbG90LnByZUluaXRIb29rcyA9IFtdO1xuICAgICQuanFwbG90LnBvc3RJbml0SG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wcmVQYXJzZU9wdGlvbnNIb29rcyA9IFtdO1xuICAgICQuanFwbG90LnBvc3RQYXJzZU9wdGlvbnNIb29rcyA9IFtdO1xuICAgICQuanFwbG90LnByZURyYXdIb29rcyA9IFtdO1xuICAgICQuanFwbG90LnBvc3REcmF3SG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wcmVEcmF3U2VyaWVzSG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wb3N0RHJhd1Nlcmllc0hvb2tzID0gW107XG4gICAgJC5qcXBsb3QucHJlRHJhd0xlZ2VuZEhvb2tzID0gW107XG4gICAgJC5qcXBsb3QuYWRkTGVnZW5kUm93SG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wcmVTZXJpZXNJbml0SG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wb3N0U2VyaWVzSW5pdEhvb2tzID0gW107XG4gICAgJC5qcXBsb3QucHJlUGFyc2VTZXJpZXNPcHRpb25zSG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wb3N0UGFyc2VTZXJpZXNPcHRpb25zSG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5ldmVudExpc3RlbmVySG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wcmVEcmF3U2VyaWVzU2hhZG93SG9va3MgPSBbXTtcbiAgICAkLmpxcGxvdC5wb3N0RHJhd1Nlcmllc1NoYWRvd0hvb2tzID0gW107XG5cbiAgICAvLyBBIHN1cGVyY2xhc3MgaG9sZGluZyBzb21lIGNvbW1vbiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICAgICQuanFwbG90LkVsZW1Db250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZWxlbTtcbiAgICAgICAgdGhpcy5fcGxvdFdpZHRoO1xuICAgICAgICB0aGlzLl9wbG90SGVpZ2h0O1xuICAgICAgICB0aGlzLl9wbG90RGltZW5zaW9ucyA9IHtoZWlnaHQ6bnVsbCwgd2lkdGg6bnVsbH07XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oZWwsIG9mZnNldHMsIGNsc3MsIGNzc29wdHMsIGF0dHJpYikge1xuICAgICAgICB0aGlzLl9vZmZzZXRzID0gb2Zmc2V0cztcbiAgICAgICAgdmFyIGtsYXNzID0gY2xzcyB8fCAnanFwbG90JztcbiAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsKTtcbiAgICAgICAgdGhpcy5fZWxlbSA9ICQoZWxlbSk7XG4gICAgICAgIHRoaXMuX2VsZW0uYWRkQ2xhc3Moa2xhc3MpO1xuICAgICAgICB0aGlzLl9lbGVtLmNzcyhjc3NvcHRzKTtcbiAgICAgICAgdGhpcy5fZWxlbS5hdHRyKGF0dHJpYik7XG4gICAgICAgIC8vIGF2b2lkIG1lbW9yeSBsZWFrO1xuICAgICAgICBlbGVtID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW07XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW0ub3V0ZXJXaWR0aCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkVsZW1Db250YWluZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbS5wb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt0b3A6bnVsbCwgbGVmdDpudWxsLCBib3R0b206bnVsbCwgcmlnaHQ6bnVsbH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkVsZW1Db250YWluZXIucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb3NpdGlvbigpLnRvcDtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkVsZW1Db250YWluZXIucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9zaXRpb24oKS5sZWZ0O1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuRWxlbUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtLmNzcygnYm90dG9tJyk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbS5jc3MoJ3JpZ2h0Jyk7XG4gICAgfTtcbiAgICBcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBBeGlzXG4gICAgICogQW4gaW5kaXZpZHVhbCBheGlzIG9iamVjdC4gIENhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIGJ1dCBjcmVhdGVkXG4gICAgICogYnkgdGhlIFBsb3Qgb2JqZWN0LiAgQXhpcyBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgb3Igb3ZlcnJpZGRlbiBieSB0aGUgXG4gICAgICogb3B0aW9ucyBwYXNzZWQgaW4gZnJvbSB0aGUgdXNlci5cbiAgICAgKiBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBeGlzKG5hbWUpIHtcbiAgICAgICAgJC5qcXBsb3QuRWxlbUNvbnRhaW5lci5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBHcm91cDogUHJvcGVydGllc1xuICAgICAgICAvL1xuICAgICAgICAvLyBBeGVzIG9wdGlvbnMgYXJlIHNwZWNpZmllZCB3aXRoaW4gYW4gYXhlcyBvYmplY3QgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgXG4gICAgICAgIC8vIHBsb3Qgb3B0aW9ucyBsaWtlIHNvOlxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gPiAgICBheGVzOiB7XG4gICAgICAgIC8vID4gICAgICAgIHhheGlzOiB7bWluOiA1fSxcbiAgICAgICAgLy8gPiAgICAgICAgeWF4aXM6IHttaW46IDIsIG1heDogOCwgbnVtYmVyVGlja3M6NH0sXG4gICAgICAgIC8vID4gICAgICAgIHgyYXhpczoge3BhZDogMS41fSxcbiAgICAgICAgLy8gPiAgICAgICAgeTJheGlzOiB7dGlja3M6WzIyLCA0NCwgNjYsIDg4XX1cbiAgICAgICAgLy8gPiAgICAgICAgfVxuICAgICAgICAvLyA+IH1cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgeCBheGVzLCAneGF4aXMnIGFuZCAneDJheGlzJywgYW5kIFxuICAgICAgICAvLyA5IHlheGVzLCAneWF4aXMnLCAneTJheGlzJy4gJ3kzYXhpcycsIC4uLiAgQW55IG9yIGFsbCBvZiB3aGljaCBtYXkgYmUgc3BlY2lmaWVkLlxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9zZXJpZXMgPSBbXTtcbiAgICAgICAgLy8gcHJvcDogc2hvd1xuICAgICAgICAvLyBXZXRoZXIgdG8gZGlzcGxheSB0aGUgYXhpcyBvbiB0aGUgZ3JhcGguXG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiB0aWNrUmVuZGVyZXJcbiAgICAgICAgLy8gQSBjbGFzcyBvZiBhIHJlbmRlcmluZyBlbmdpbmUgZm9yIGNyZWF0aW5nIHRoZSB0aWNrcyBsYWJlbHMgZGlzcGxheWVkIG9uIHRoZSBwbG90LCBcbiAgICAgICAgLy8gU2VlIDwkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyPi5cbiAgICAgICAgdGhpcy50aWNrUmVuZGVyZXIgPSAkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyO1xuICAgICAgICAvLyBwcm9wOiB0aWNrT3B0aW9uc1xuICAgICAgICAvLyBPcHRpb25zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRpY2tSZW5kZXJlciwgc2VlIDwkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyPiBvcHRpb25zLlxuICAgICAgICB0aGlzLnRpY2tPcHRpb25zID0ge307XG4gICAgICAgIC8vIHByb3A6IGxhYmVsUmVuZGVyZXJcbiAgICAgICAgLy8gQSBjbGFzcyBvZiBhIHJlbmRlcmluZyBlbmdpbmUgZm9yIGNyZWF0aW5nIGFuIGF4aXMgbGFiZWwuXG4gICAgICAgIHRoaXMubGFiZWxSZW5kZXJlciA9ICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyO1xuICAgICAgICAvLyBwcm9wOiBsYWJlbE9wdGlvbnNcbiAgICAgICAgLy8gT3B0aW9ucyBwYXNzZWQgdG8gdGhlIGxhYmVsIHJlbmRlcmVyLlxuICAgICAgICB0aGlzLmxhYmVsT3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBwcm9wOiBsYWJlbFxuICAgICAgICAvLyBMYWJlbCBmb3IgdGhlIGF4aXNcbiAgICAgICAgdGhpcy5sYWJlbCA9IG51bGw7XG4gICAgICAgIC8vIHByb3A6IHNob3dMYWJlbFxuICAgICAgICAvLyB0cnVlIHRvIHNob3cgdGhlIGF4aXMgbGFiZWwuXG4gICAgICAgIHRoaXMuc2hvd0xhYmVsID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogbWluXG4gICAgICAgIC8vIG1pbmltdW0gdmFsdWUgb2YgdGhlIGF4aXMgKGluIGRhdGEgdW5pdHMsIG5vdCBwaXhlbHMpLlxuICAgICAgICB0aGlzLm1pbiA9IG51bGw7XG4gICAgICAgIC8vIHByb3A6IG1heFxuICAgICAgICAvLyBtYXhpbXVtIHZhbHVlIG9mIHRoZSBheGlzIChpbiBkYXRhIHVuaXRzLCBub3QgcGl4ZWxzKS5cbiAgICAgICAgdGhpcy5tYXggPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBhdXRvc2NhbGVcbiAgICAgICAgLy8gREVQUkVDQVRFRFxuICAgICAgICAvLyB0aGUgZGVmYXVsdCBzY2FsaW5nIGFsZ29yaXRobSBwcm9kdWNlcyBzdXBlcmlvciByZXN1bHRzLlxuICAgICAgICB0aGlzLmF1dG9zY2FsZSA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBwYWRcbiAgICAgICAgLy8gUGFkZGluZyB0byBleHRlbmQgdGhlIHJhbmdlIGFib3ZlIGFuZCBiZWxvdyB0aGUgZGF0YSBib3VuZHMuXG4gICAgICAgIC8vIFRoZSBkYXRhIHJhbmdlIGlzIG11bHRpcGxpZWQgYnkgdGhpcyBmYWN0b3IgdG8gZGV0ZXJtaW5lIG1pbmltdW0gYW5kIG1heGltdW0gYXhpcyBib3VuZHMuXG4gICAgICAgIC8vIEEgdmFsdWUgb2YgMCB3aWxsIGJlIGludGVycHJldGVkIHRvIG1lYW4gbm8gcGFkZGluZywgYW5kIHBhZCB3aWxsIGJlIHNldCB0byAxLjAuXG4gICAgICAgIHRoaXMucGFkID0gMS4yO1xuICAgICAgICAvLyBwcm9wOiBwYWRNYXhcbiAgICAgICAgLy8gUGFkZGluZyB0byBleHRlbmQgdGhlIHJhbmdlIGFib3ZlIGRhdGEgYm91bmRzLlxuICAgICAgICAvLyBUaGUgdG9wIG9mIHRoZSBkYXRhIHJhbmdlIGlzIG11bHRpcGxpZWQgYnkgdGhpcyBmYWN0b3IgdG8gZGV0ZXJtaW5lIG1heGltdW0gYXhpcyBib3VuZHMuXG4gICAgICAgIC8vIEEgdmFsdWUgb2YgMCB3aWxsIGJlIGludGVycHJldGVkIHRvIG1lYW4gbm8gcGFkZGluZywgYW5kIHBhZE1heCB3aWxsIGJlIHNldCB0byAxLjAuXG4gICAgICAgIHRoaXMucGFkTWF4ID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogcGFkTWluXG4gICAgICAgIC8vIFBhZGRpbmcgdG8gZXh0ZW5kIHRoZSByYW5nZSBiZWxvdyBkYXRhIGJvdW5kcy5cbiAgICAgICAgLy8gVGhlIGJvdHRvbSBvZiB0aGUgZGF0YSByYW5nZSBpcyBtdWx0aXBsaWVkIGJ5IHRoaXMgZmFjdG9yIHRvIGRldGVybWluZSBtaW5pbXVtIGF4aXMgYm91bmRzLlxuICAgICAgICAvLyBBIHZhbHVlIG9mIDAgd2lsbCBiZSBpbnRlcnByZXRlZCB0byBtZWFuIG5vIHBhZGRpbmcsIGFuZCBwYWRNaW4gd2lsbCBiZSBzZXQgdG8gMS4wLlxuICAgICAgICB0aGlzLnBhZE1pbiA9IG51bGw7XG4gICAgICAgIC8vIHByb3A6IHRpY2tzXG4gICAgICAgIC8vIDFEIFt2YWwsIHZhbCwgLi4uXSBvciAyRCBbW3ZhbCwgbGFiZWxdLCBbdmFsLCBsYWJlbF0sIC4uLl0gYXJyYXkgb2YgdGlja3MgZm9yIHRoZSBheGlzLlxuICAgICAgICAvLyBJZiBubyBsYWJlbCBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZSBpcyBmb3JtYXR0ZWQgaW50byBhbiBhcHByb3ByaWF0ZSBsYWJlbC5cbiAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICAvLyBwcm9wOiBudW1iZXJUaWNrc1xuICAgICAgICAvLyBEZXNpcmVkIG51bWJlciBvZiB0aWNrcy4gIERlZmF1bHQgaXMgdG8gY29tcHV0ZSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICB0aGlzLm51bWJlclRpY2tzO1xuICAgICAgICAvLyBwcm9wOiB0aWNrSW50ZXJ2YWxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHVuaXRzIGJldHdlZW4gdGlja3MuICBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBudW1iZXJUaWNrcy5cbiAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgIC8vIHByb3A6IHJlbmRlcmVyXG4gICAgICAgIC8vIEEgY2xhc3Mgb2YgYSByZW5kZXJpbmcgZW5naW5lIHRoYXQgaGFuZGxlcyB0aWNrIGdlbmVyYXRpb24sIFxuICAgICAgICAvLyBzY2FsaW5nIGlucHV0IGRhdGEgdG8gcGl4ZWwgZ3JpZCB1bml0cyBhbmQgZHJhd2luZyB0aGUgYXhpcyBlbGVtZW50LlxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gJC5qcXBsb3QuTGluZWFyQXhpc1JlbmRlcmVyO1xuICAgICAgICAvLyBwcm9wOiByZW5kZXJlck9wdGlvbnNcbiAgICAgICAgLy8gcmVuZGVyZXIgc3BlY2lmaWMgb3B0aW9ucy4gIFNlZSA8JC5qcXBsb3QuTGluZWFyQXhpc1JlbmRlcmVyPiBmb3Igb3B0aW9ucy5cbiAgICAgICAgdGhpcy5yZW5kZXJlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gcHJvcDogc2hvd1RpY2tzXG4gICAgICAgIC8vIFdldGhlciB0byBzaG93IHRoZSB0aWNrcyAoYm90aCBtYXJrcyBhbmQgbGFiZWxzKSBvciBub3QuXG4gICAgICAgIC8vIFdpbGwgbm90IG92ZXJyaWRlIHNob3dNYXJrIGFuZCBzaG93TGFiZWwgb3B0aW9ucyBpZiBzcGVjaWZpZWQgb24gdGhlIHRpY2tzIHRoZW1zZWx2ZXMuXG4gICAgICAgIHRoaXMuc2hvd1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogc2hvd1RpY2tNYXJrc1xuICAgICAgICAvLyBXZXRoZXIgdG8gc2hvdyB0aGUgdGljayBtYXJrcyAobGluZSBjcm9zc2luZyBncmlkKSBvciBub3QuXG4gICAgICAgIC8vIE92ZXJyaWRkZW4gYnkgc2hvd1RpY2tzIGFuZCBzaG93TWFyayBvcHRpb24gb2YgdGljayBpdHNlbGYuXG4gICAgICAgIHRoaXMuc2hvd1RpY2tNYXJrcyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNob3dNaW5vclRpY2tzXG4gICAgICAgIC8vIFdldGhlciBvciBub3QgdG8gc2hvdyBtaW5vciB0aWNrcy4gIFRoaXMgaXMgcmVuZGVyZXIgZGVwZW5kZW50LlxuICAgICAgICB0aGlzLnNob3dNaW5vclRpY2tzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogZHJhd01ham9yR3JpZGxpbmVzXG4gICAgICAgIC8vIFRydWUgdG8gZHJhdyBncmlkbGluZXMgZm9yIG1ham9yIGF4aXMgdGlja3MuXG4gICAgICAgIHRoaXMuZHJhd01ham9yR3JpZGxpbmVzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogZHJhd01pbm9yR3JpZGxpbmVzXG4gICAgICAgIC8vIFRydWUgdG8gZHJhdyBncmlkbGluZXMgZm9yIG1pbm9yIHRpY2tzLlxuICAgICAgICB0aGlzLmRyYXdNaW5vckdyaWRsaW5lcyA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBkcmF3TWFqb3JUaWNrTWFya3NcbiAgICAgICAgLy8gVHJ1ZSB0byBkcmF3IHRpY2sgbWFya3MgZm9yIG1ham9yIGF4aXMgdGlja3MuXG4gICAgICAgIHRoaXMuZHJhd01ham9yVGlja01hcmtzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogZHJhd01pbm9yVGlja01hcmtzXG4gICAgICAgIC8vIFRydWUgdG8gZHJhdyB0aWNrIG1hcmtzIGZvciBtaW5vciB0aWNrcy4gIFRoaXMgaXMgcmVuZGVyZXIgZGVwZW5kZW50LlxuICAgICAgICB0aGlzLmRyYXdNaW5vclRpY2tNYXJrcyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHVzZVNlcmllc0NvbG9yXG4gICAgICAgIC8vIFVzZSB0aGUgY29sb3Igb2YgdGhlIGZpcnN0IHNlcmllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBheGlzIGZvciB0aGVcbiAgICAgICAgLy8gdGljayBtYXJrcyBhbmQgbGluZSBib3JkZXJpbmcgdGhpcyBheGlzLlxuICAgICAgICB0aGlzLnVzZVNlcmllc0NvbG9yID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IGJvcmRlcldpZHRoXG4gICAgICAgIC8vIHdpZHRoIG9mIGxpbmUgc3Ryb2tlZCBhdCB0aGUgYm9yZGVyIG9mIHRoZSBheGlzLiAgRGVmYXVsdHNcbiAgICAgICAgLy8gdG8gdGhlIHdpZHRoIG9mIHRoZSBncmlkIGJvYXJkZXIuXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBib3JkZXJDb2xvclxuICAgICAgICAvLyBjb2xvciBvZiB0aGUgYm9yZGVyIGFkamFjZW50IHRvIHRoZSBheGlzLiAgRGVmYXVsdHMgdG8gZ3JpZCBib3JkZXIgY29sb3IuXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBzY2FsZVRvSGlkZGVuU2VyaWVzXG4gICAgICAgIC8vIFRydWUgdG8gaW5jbHVkZSBoaWRkZW4gc2VyaWVzIHdoZW4gY29tcHV0aW5nIGF4ZXMgYm91bmRzIGFuZCBzY2FsaW5nLlxuICAgICAgICB0aGlzLnNjYWxlVG9IaWRkZW5TZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgb24gdGhlIGF4aXMuXG4gICAgICAgIHRoaXMuX2RhdGFCb3VuZHMgPSB7bWluOm51bGwsIG1heDpudWxsfTtcbiAgICAgICAgLy8gc3RhdGlzdGljcyAobWluLCBtYXgsIG1lYW4pIGFzIHdlbGwgYXMgYWN0dWFsIGRhdGEgaW50ZXJ2YWxzIGZvciBlYWNoIHNlcmllcyBhdHRhY2hlZCB0byBheGlzLlxuICAgICAgICAvLyBob2xkcyBjb2xsZWN0aW9uIG9mIHtpbnRlcnZhbHM6W10sIG1pbjosIG1heDosIG1lYW46IH0gb2JqZWN0cyBmb3IgZWFjaCBzZXJpZXMgb24gYXhpcy5cbiAgICAgICAgdGhpcy5faW50ZXJ2YWxTdGF0cyA9IFtdO1xuICAgICAgICAvLyBwaXhlbCBwb3NpdGlvbiBmcm9tIHRoZSB0b3AgbGVmdCBvZiB0aGUgbWluIHZhbHVlIGFuZCBtYXggdmFsdWUgb24gdGhlIGF4aXMuXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSB7bWluOm51bGwsIG1heDpudWxsfTtcbiAgICAgICAgdGhpcy5fdGlja3M9W107XG4gICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogc3luY1RpY2tzXG4gICAgICAgIC8vIHRydWUgdG8gdHJ5IGFuZCBzeW5jaHJvbml6ZSB0aWNrIHNwYWNpbmcgYWNyb3NzIG11bHRpcGxlIGF4ZXMgc28gdGhhdCB0aWNrcyBhbmRcbiAgICAgICAgLy8gZ3JpZCBsaW5lcyBsaW5lIHVwLiAgVGhpcyBoYXMgYW4gaW1wYWN0IG9uIGF1dG9zY2FsaW5nIGFsZ29yaXRobSwgaG93ZXZlci5cbiAgICAgICAgLy8gSW4gZ2VuZXJhbCwgYXV0b3NjYWxpbmcgYW4gaW5kaXZpZHVhbCBheGlzIHdpbGwgd29yayBiZXR0ZXIgaWYgaXQgZG9lcyBub3RcbiAgICAgICAgLy8gaGF2ZSB0byBzeW5jIHRpY2tzLlxuICAgICAgICB0aGlzLnN5bmNUaWNrcyA9IG51bGw7XG4gICAgICAgIC8vIHByb3A6IHRpY2tTcGFjaW5nXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHBpeGVsIHNwYWNpbmcgYmV0d2VlbiB0aWNrcyBvbiBncmFwaC4gIFVzZWQgZHVyaW5nIGF1dG9zY2FsaW5nLlxuICAgICAgICAvLyBUaGlzIG51bWJlciB3aWxsIGJlIGFuIHVwcGVyIGJvdW5kLCBhY3R1YWwgc3BhY2luZyB3aWxsIGJlIGxlc3MuXG4gICAgICAgIHRoaXMudGlja1NwYWNpbmcgPSA3NTtcbiAgICAgICAgLy8gUHJvcGVydGllcyB0byBob2xkIHRoZSBvcmlnaW5hbCB2YWx1ZXMgZm9yIG1pbiwgbWF4LCB0aWNrcywgdGlja0ludGVydmFsIGFuZCBudW1iZXJUaWNrc1xuICAgICAgICAvLyBzbyB0aGV5IGNhbiBiZSByZXN0b3JlZCBpZiBhbHRlcmVkIGJ5IHBsdWdpbnMuXG4gICAgICAgIHRoaXMuX21pbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX21heCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bWJlclRpY2tzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3RpY2tzID0gbnVsbDtcbiAgICAgICAgLy8gaG9sZCBvcmlnaW5hbCB1c2VyIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgQXhpcy5wcm90b3R5cGUgPSBuZXcgJC5qcXBsb3QuRWxlbUNvbnRhaW5lcigpO1xuICAgIEF4aXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXhpcztcbiAgICBcbiAgICBBeGlzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5yZW5kZXJlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgdGhpcy5yZW5kZXJlcigpOyAgXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSBheGlzIG5hbWVcbiAgICAgICAgdGhpcy50aWNrT3B0aW9ucy5heGlzID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBpZiBzaG93TWFyayBvciBzaG93TGFiZWwgdGljayBvcHRpb25zIG5vdCBzcGVjaWZpZWQsIHVzZSB2YWx1ZSBvZiBheGlzIG9wdGlvbi5cbiAgICAgICAgLy8gc2hvd1RpY2tzIG92ZXJyaWRlcyBzaG93VGlja01hcmtzLlxuICAgICAgICBpZiAodGhpcy50aWNrT3B0aW9ucy5zaG93TWFyayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tPcHRpb25zLnNob3dNYXJrID0gdGhpcy5zaG93VGlja3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlja09wdGlvbnMuc2hvd01hcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aWNrT3B0aW9ucy5zaG93TWFyayA9IHRoaXMuc2hvd1RpY2tNYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aWNrT3B0aW9ucy5zaG93TGFiZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aWNrT3B0aW9ucy5zaG93TGFiZWwgPSB0aGlzLnNob3dUaWNrcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMubGFiZWwgPT0gbnVsbCB8fCB0aGlzLmxhYmVsID09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMYWJlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYWJlbE9wdGlvbnMubGFiZWwgPSB0aGlzLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dMYWJlbCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbE9wdGlvbnMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgZGVmYXVsdCBwYWRNYXgsIHBhZE1pbiBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIC8vIHNwZWNpYWwgY2hlY2ssIGlmIG5vIHBhZGRpbmcgZGVzaXJlZCwgcGFkZGluZ1xuICAgICAgICAvLyBzaG91bGQgYmUgc2V0IHRvIDEuMFxuICAgICAgICBpZiAodGhpcy5wYWQgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWQgPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFkTWF4ID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGFkTWF4ID0gMS4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhZE1pbiA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhZE1pbiA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYWRNYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYWRNYXggPSAodGhpcy5wYWQtMSkvMiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFkTWluID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFkTWluID0gKHRoaXMucGFkLTEpLzIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyB0aGF0IHBhZE1pbiBhbmQgcGFkTWF4IGFyZSBjb3JyZWN0bHkgc2V0LCByZXNldCBwYWQgaW4gY2FzZSB1c2VyIGhhcyBzdXBwbGllZCBcbiAgICAgICAgLy8gcGFkTWluIGFuZC9vciBwYWRNYXhcbiAgICAgICAgdGhpcy5wYWQgPSB0aGlzLnBhZE1heCArIHRoaXMucGFkTWluIC0gMTtcbiAgICAgICAgaWYgKHRoaXMubWluICE9IG51bGwgfHwgdGhpcy5tYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvc2NhbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBub3Qgc2V0LCBzeW5jIHRpY2tzIGZvciB5IGF4ZXMgYnV0IG5vdCB4IGJ5IGRlZmF1bHQuXG4gICAgICAgIGlmICh0aGlzLnN5bmNUaWNrcyA9PSBudWxsICYmIHRoaXMubmFtZS5pbmRleE9mKCd5JykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5zeW5jVGlja3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3luY1RpY2tzID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5zeW5jVGlja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXQuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyT3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgQXhpcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgcGxvdCkge1xuICAgICAgICAvLyBNZW1vcnkgTGVha3MgcGF0Y2hcbiAgICAgICAgaWYgKHRoaXMuX190aWNrcykge1xuICAgICAgICAgIHRoaXMuX190aWNrcyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kcmF3LmNhbGwodGhpcywgY3R4LCBwbG90KTtcbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBBeGlzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFxuICAgIEF4aXMucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbihwb3MsIG9mZnNldHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wYWNrLmNhbGwodGhpcywgcG9zLCBvZmZzZXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBhbGwgYmUgYXZhaWxhYmxlIG5vdy5cbiAgICAgICAgaWYgKHRoaXMuX21pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSB0aGlzLm1pbjtcbiAgICAgICAgICAgIHRoaXMuX21heCA9IHRoaXMubWF4O1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJUaWNrcyA9IHRoaXMubnVtYmVyVGlja3M7XG4gICAgICAgICAgICB0aGlzLl9fdGlja3MgPSB0aGlzLl90aWNrcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gcmVzZXQgdGhlIGF4aXMgYmFjayB0byBvcmlnaW5hbCB2YWx1ZXMgaWYgaXQgaGFzIGJlZW4gc2NhbGVkLCB6b29tZWQsIGV0Yy5cbiAgICBBeGlzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc2V0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBcbiAgICBBeGlzLnByb3RvdHlwZS5yZXNldFNjYWxlID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCB7bWluOiBudWxsLCBtYXg6IG51bGwsIG51bWJlclRpY2tzOiBudWxsLCB0aWNrSW50ZXJ2YWw6IG51bGwsIF90aWNrczogW10sIHRpY2tzOiBbXX0sIG9wdHMpO1xuICAgICAgICB0aGlzLnJlc2V0RGF0YUJvdW5kcygpO1xuICAgIH07XG4gICAgXG4gICAgQXhpcy5wcm90b3R5cGUucmVzZXREYXRhQm91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEdvIHRocm91Z2ggYWxsIHRoZSBzZXJpZXMgYXR0YWNoZWQgdG8gdGhpcyBheGlzIGFuZCBmaW5kXG4gICAgICAgIC8vIHRoZSBtaW4vbWF4IGJvdW5kcyBmb3IgdGhpcyBheGlzLlxuICAgICAgICB2YXIgZGIgPSB0aGlzLl9kYXRhQm91bmRzO1xuICAgICAgICBkYi5taW4gPSBudWxsO1xuICAgICAgICBkYi5tYXggPSBudWxsO1xuICAgICAgICB2YXIgbCwgcywgZDtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHdoZW4gdG8gZm9yY2UgbWluIDAgb24gYmFyIHNlcmllcyBwbG90cy5cbiAgICAgICAgdmFyIGRvZm9yY2UgPSAodGhpcy5zaG93KSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuX3Nlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyA9IHRoaXMuX3Nlcmllc1tpXTtcbiAgICAgICAgICAgIGlmIChzLnNob3cgfHwgdGhpcy5zY2FsZVRvSGlkZGVuU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgZCA9IHMuX3Bsb3REYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzLl90eXBlID09PSAnbGluZScgJiYgcy5yZW5kZXJlci5iYW5kcy5zaG93ICYmIHRoaXMubmFtZS5jaGFyQXQoMCkgIT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICBkID0gW1swLCBzLnJlbmRlcmVyLmJhbmRzLl9taW5dLCBbMSwgcy5yZW5kZXJlci5iYW5kcy5fbWF4XV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1pbnlpZHggPSAxLCBtYXh5aWR4ID0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChzLl90eXBlICE9IG51bGwgJiYgcy5fdHlwZSA9PSAnb2hsYycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlueWlkeCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIG1heHlpZHggPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTAsIGw9ZC5sZW5ndGg7IGo8bDsgaisrKSB7IFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lID09ICd4YXhpcycgfHwgdGhpcy5uYW1lID09ICd4MmF4aXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRbal1bMF0gIT0gbnVsbCAmJiBkW2pdWzBdIDwgZGIubWluKSB8fCBkYi5taW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm1pbiA9IGRbal1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRbal1bMF0gIT0gbnVsbCAmJiBkW2pdWzBdID4gZGIubWF4KSB8fCBkYi5tYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm1heCA9IGRbal1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZFtqXVttaW55aWR4XSAhPSBudWxsICYmIGRbal1bbWlueWlkeF0gPCBkYi5taW4pIHx8IGRiLm1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIubWluID0gZFtqXVttaW55aWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZFtqXVttYXh5aWR4XSAhPSBudWxsICYmIGRbal1bbWF4eWlkeF0gPiBkYi5tYXgpIHx8IGRiLm1heCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIubWF4ID0gZFtqXVttYXh5aWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFjayB0byBub3QgcGFkIG91dCBib3R0b20gb2YgYmFyIHBsb3RzIHVubGVzcyB1c2VyIGhhcyBzcGVjaWZpZWQgYSBwYWRkaW5nLlxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IHNlcmllcyB3aWxsIGhhdmUgYSBjaGFuY2UgdG8gc2V0IGRvZm9yY2UgdG8gZmFsc2UuICBvbmNlIGl0IGlzIHNldCB0byBcbiAgICAgICAgICAgICAgICAvLyBmYWxzZSwgaXQgY2Fubm90IGJlIHJlc2V0IHRvIHRydWUuXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IHNlcmllcyBhdHRhY2hlZCB0byBheGlzIGlzIG5vdCBhIGJhciwgd29udCBmb3JjZSAwLlxuICAgICAgICAgICAgICAgIGlmIChkb2ZvcmNlICYmIHMucmVuZGVyZXIuY29uc3RydWN0b3IgIT09ICQuanFwbG90LkJhclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkb2ZvcmNlICYmIHRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2ZvcmNlVGlja0F0MCcpICYmIHRoaXMuX29wdGlvbnMuZm9yY2VUaWNrQXQwID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkb2ZvcmNlICYmIHMucmVuZGVyZXIuY29uc3RydWN0b3IgPT09ICQuanFwbG90LkJhclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmJhckRpcmVjdGlvbiA9PSAndmVydGljYWwnICYmIHRoaXMubmFtZSAhPSAneGF4aXMnICYmIHRoaXMubmFtZSAhPSAneDJheGlzJykgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhZCAhPSBudWxsIHx8IHRoaXMuX29wdGlvbnMucGFkTWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2ZvcmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzLmJhckRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcgJiYgKHRoaXMubmFtZSA9PSAneGF4aXMnIHx8IHRoaXMubmFtZSA9PSAneDJheGlzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhZCAhPSBudWxsIHx8IHRoaXMuX29wdGlvbnMucGFkTWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2ZvcmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2ZvcmNlICYmIHRoaXMucmVuZGVyZXIuY29uc3RydWN0b3IgPT09ICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlciAmJiBkYi5taW4gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWRNaW4gPSAxLjA7XG4gICAgICAgICAgICB0aGlzLmZvcmNlVGlja0F0MCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3M6IExlZ2VuZFxuICAgICAqIExlZ2VuZCBvYmplY3QuICBDYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LCBidXQgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBQbG90IG9iamVjdC4gIExlZ2VuZCBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgb3Igb3ZlcnJpZGRlbiBieSB0aGUgXG4gICAgICogb3B0aW9ucyBwYXNzZWQgaW4gZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMZWdlbmQob3B0aW9ucykge1xuICAgICAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIEdyb3VwOiBQcm9wZXJ0aWVzXG4gICAgICAgIFxuICAgICAgICAvLyBwcm9wOiBzaG93XG4gICAgICAgIC8vIFdldGhlciB0byBkaXNwbGF5IHRoZSBsZWdlbmQgb24gdGhlIGdyYXBoLlxuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogbG9jYXRpb25cbiAgICAgICAgLy8gUGxhY2VtZW50IG9mIHRoZSBsZWdlbmQuICBvbmUgb2YgdGhlIGNvbXBhc3MgZGlyZWN0aW9uczogbncsIG4sIG5lLCBlLCBzZSwgcywgc3csIHdcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICduZSc7XG4gICAgICAgIC8vIHByb3A6IGxhYmVsc1xuICAgICAgICAvLyBBcnJheSBvZiBsYWJlbHMgdG8gdXNlLiAgQnkgZGVmYXVsdCB0aGUgcmVuZGVyZXIgd2lsbCBsb29rIGZvciBsYWJlbHMgb24gdGhlIHNlcmllcy5cbiAgICAgICAgLy8gTGFiZWxzIHNwZWNpZmllZCBpbiB0aGlzIGFycmF5IHdpbGwgb3ZlcnJpZGUgbGFiZWxzIHNwZWNpZmllZCBvbiB0aGUgc2VyaWVzLlxuICAgICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgICAvLyBwcm9wOiBzaG93TGFiZWxzXG4gICAgICAgIC8vIHRydWUgdG8gc2hvdyB0aGUgbGFiZWwgdGV4dCBvbiB0aGUgIGxlZ2VuZC5cbiAgICAgICAgdGhpcy5zaG93TGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogc2hvd1N3YXRjaFxuICAgICAgICAvLyB0cnVlIHRvIHNob3cgdGhlIGNvbG9yIHN3YXRjaGVzIG9uIHRoZSBsZWdlbmQuXG4gICAgICAgIHRoaXMuc2hvd1N3YXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogcGxhY2VtZW50XG4gICAgICAgIC8vIFwiaW5zaWRlR3JpZFwiIHBsYWNlcyBsZWdlbmQgaW5zaWRlIHRoZSBncmlkIGFyZWEgb2YgdGhlIHBsb3QuXG4gICAgICAgIC8vIFwib3V0c2lkZUdyaWRcIiBwbGFjZXMgdGhlIGxlZ2VuZCBvdXRzaWRlIHRoZSBncmlkIGJ1dCBpbnNpZGUgdGhlIHBsb3QgY29udGFpbmVyLCBcbiAgICAgICAgLy8gc2hyaW5raW5nIHRoZSBncmlkIHRvIGFjY29tbW9kYXRlIHRoZSBsZWdlbmQuXG4gICAgICAgIC8vIFwiaW5zaWRlXCIgc3lub255bSBmb3IgXCJpbnNpZGVHcmlkXCIsIFxuICAgICAgICAvLyBcIm91dHNpZGVcIiBwbGFjZXMgdGhlIGxlZ2VuZCBvdXNpZGUgdGhlIGdyaWQgYXJlYSwgYnV0IGRvZXMgbm90IHNocmluayB0aGUgZ3JpZCB3aGljaFxuICAgICAgICAvLyBjYW4gY2F1c2UgdGhlIGxlZ2VuZCB0byBvdmVyZmxvdyB0aGUgcGxvdCBjb250YWluZXIuXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gXCJpbnNpZGVHcmlkXCI7XG4gICAgICAgIC8vIHByb3A6IHhvZmZzZXRcbiAgICAgICAgLy8gREVQUkVDQVRFRC4gIFNldCB0aGUgbWFyZ2lucyBvbiB0aGUgbGVnZW5kIHVzaW5nIHRoZSBtYXJnaW5Ub3AsIG1hcmdpbkxlZnQsIGV0Yy4gXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb3IgdmlhIENTUyBtYXJnaW4gc3R5bGluZyBvZiB0aGUgLmpxcGxvdC10YWJsZS1sZWdlbmQgY2xhc3MuXG4gICAgICAgIHRoaXMueG9mZnNldCA9IDA7XG4gICAgICAgIC8vIHByb3A6IHlvZmZzZXRcbiAgICAgICAgLy8gREVQUkVDQVRFRC4gIFNldCB0aGUgbWFyZ2lucyBvbiB0aGUgbGVnZW5kIHVzaW5nIHRoZSBtYXJnaW5Ub3AsIG1hcmdpbkxlZnQsIGV0Yy4gXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb3IgdmlhIENTUyBtYXJnaW4gc3R5bGluZyBvZiB0aGUgLmpxcGxvdC10YWJsZS1sZWdlbmQgY2xhc3MuXG4gICAgICAgIHRoaXMueW9mZnNldCA9IDA7XG4gICAgICAgIC8vIHByb3A6IGJvcmRlclxuICAgICAgICAvLyBjc3Mgc3BlYyBmb3IgdGhlIGJvcmRlciBhcm91bmQgdGhlIGxlZ2VuZCBib3guXG4gICAgICAgIHRoaXMuYm9yZGVyO1xuICAgICAgICAvLyBwcm9wOiBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIGNzcyBzcGVjIGZvciB0aGUgYmFja2dyb3VuZCBvZiB0aGUgbGVnZW5kIGJveC5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kO1xuICAgICAgICAvLyBwcm9wOiB0ZXh0Q29sb3JcbiAgICAgICAgLy8gY3NzIGNvbG9yIHNwZWMgZm9yIHRoZSBsZWdlbmQgdGV4dC5cbiAgICAgICAgdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIC8vIHByb3A6IGZvbnRGYW1pbHlcbiAgICAgICAgLy8gY3NzIGZvbnQtZmFtaWx5IHNwZWMgZm9yIHRoZSBsZWdlbmQgdGV4dC5cbiAgICAgICAgdGhpcy5mb250RmFtaWx5OyBcbiAgICAgICAgLy8gcHJvcDogZm9udFNpemVcbiAgICAgICAgLy8gY3NzIGZvbnQtc2l6ZSBzcGVjIGZvciB0aGUgbGVnZW5kIHRleHQuXG4gICAgICAgIHRoaXMuZm9udFNpemUgO1xuICAgICAgICAvLyBwcm9wOiByb3dTcGFjaW5nXG4gICAgICAgIC8vIGNzcyBwYWRkaW5nLXRvcCBzcGVjIGZvciB0aGUgcm93cyBpbiB0aGUgbGVnZW5kLlxuICAgICAgICB0aGlzLnJvd1NwYWNpbmcgPSAnMC41ZW0nO1xuICAgICAgICAvLyByZW5kZXJlclxuICAgICAgICAvLyBBIGNsYXNzIHRoYXQgd2lsbCBjcmVhdGUgYSBET00gb2JqZWN0IGZvciB0aGUgbGVnZW5kLFxuICAgICAgICAvLyBzZWUgPCQuanFwbG90LlRhYmxlTGVnZW5kUmVuZGVyZXI+LlxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gJC5qcXBsb3QuVGFibGVMZWdlbmRSZW5kZXJlcjtcbiAgICAgICAgLy8gcHJvcDogcmVuZGVyZXJPcHRpb25zXG4gICAgICAgIC8vIHJlbmRlcmVyIHNwZWNpZmljIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSByZW5kZXJlci5cbiAgICAgICAgdGhpcy5yZW5kZXJlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gcHJvcDogcHJlZHJhd1xuICAgICAgICAvLyBXZXRoZXIgdG8gZHJhdyB0aGUgbGVnZW5kIGJlZm9yZSB0aGUgc2VyaWVzIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlZCB3aXRoIHNlcmllcyBzcGVjaWZpYyBsZWdlbmQgcmVuZGVyZXJzIGZvciBwaWUsIGRvbnV0LCBtZWtrbyBjaGFydHMsIGV0Yy5cbiAgICAgICAgdGhpcy5wcmVEcmF3ID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IG1hcmdpblRvcFxuICAgICAgICAvLyBDU1MgbWFyZ2luIGZvciB0aGUgbGVnZW5kIERPTSBlbGVtZW50LiBUaGlzIHdpbGwgc2V0IGFuIGVsZW1lbnQgXG4gICAgICAgIC8vIENTUyBzdHlsZSBmb3IgdGhlIG1hcmdpbiB3aGljaCB3aWxsIG92ZXJyaWRlIGFueSBzdHlsZSBzaGVldCBzZXR0aW5nLlxuICAgICAgICAvLyBUaGUgZGVmYXVsdCB3aWxsIGJlIHRha2VuIGZyb20gdGhlIHN0eWxlc2hlZXQuXG4gICAgICAgIHRoaXMubWFyZ2luVG9wID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogbWFyZ2luUmlnaHRcbiAgICAgICAgLy8gQ1NTIG1hcmdpbiBmb3IgdGhlIGxlZ2VuZCBET00gZWxlbWVudC4gVGhpcyB3aWxsIHNldCBhbiBlbGVtZW50IFxuICAgICAgICAvLyBDU1Mgc3R5bGUgZm9yIHRoZSBtYXJnaW4gd2hpY2ggd2lsbCBvdmVycmlkZSBhbnkgc3R5bGUgc2hlZXQgc2V0dGluZy5cbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgd2lsbCBiZSB0YWtlbiBmcm9tIHRoZSBzdHlsZXNoZWV0LlxuICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogbWFyZ2luQm90dG9tXG4gICAgICAgIC8vIENTUyBtYXJnaW4gZm9yIHRoZSBsZWdlbmQgRE9NIGVsZW1lbnQuIFRoaXMgd2lsbCBzZXQgYW4gZWxlbWVudCBcbiAgICAgICAgLy8gQ1NTIHN0eWxlIGZvciB0aGUgbWFyZ2luIHdoaWNoIHdpbGwgb3ZlcnJpZGUgYW55IHN0eWxlIHNoZWV0IHNldHRpbmcuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IHdpbGwgYmUgdGFrZW4gZnJvbSB0aGUgc3R5bGVzaGVldC5cbiAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBtYXJnaW5MZWZ0XG4gICAgICAgIC8vIENTUyBtYXJnaW4gZm9yIHRoZSBsZWdlbmQgRE9NIGVsZW1lbnQuIFRoaXMgd2lsbCBzZXQgYW4gZWxlbWVudCBcbiAgICAgICAgLy8gQ1NTIHN0eWxlIGZvciB0aGUgbWFyZ2luIHdoaWNoIHdpbGwgb3ZlcnJpZGUgYW55IHN0eWxlIHNoZWV0IHNldHRpbmcuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IHdpbGwgYmUgdGFrZW4gZnJvbSB0aGUgc3R5bGVzaGVldC5cbiAgICAgICAgdGhpcy5tYXJnaW5MZWZ0ID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogZXNjYXBlSHRtbFxuICAgICAgICAvLyBUcnVlIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgd2l0aCB0aGVpciBodG1sIGVudGl0eSBlcXVpdmFsZW50c1xuICAgICAgICAvLyBpbiBsZWdlbmQgdGV4dC4gIFwiPFwiIGJlY29tZXMgJmx0OyBhbmQgc28gb24sIHNvIGh0bWwgdGFncyBhcmUgbm90IHJlbmRlcmVkLlxuICAgICAgICB0aGlzLmVzY2FwZUh0bWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VyaWVzID0gW107XG4gICAgICAgIFxuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgXG4gICAgTGVnZW5kLnByb3RvdHlwZSA9IG5ldyAkLmpxcGxvdC5FbGVtQ29udGFpbmVyKCk7XG4gICAgTGVnZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlZ2VuZDtcbiAgICBcbiAgICBMZWdlbmQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgZGVwcmVjYXRlZCBiZWhhdmlvdXJcbiAgICAgICAgLy8gaWYgdXNlciBoYXMgc3BlY2lmaWVkIHhvZmZzZXQgb3IgeW9mZnNldCwgY29weSB0aGVzZSB0b1xuICAgICAgICAvLyB0aGUgbWFyZ2luIHByb3BlcnRpZXMuXG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gICdpbnNpZGUnKSB7XG4gICAgICAgICAgICB0aGlzLnBsYWNlbWVudCA9ICdpbnNpZGVHcmlkJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMueG9mZnNldCA+MCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxhY2VtZW50ID09ICdpbnNpZGVHcmlkJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJnaW5MZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbkxlZnQgPSB0aGlzLnhvZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJnaW5SaWdodCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gdGhpcy54b2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luTGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ253JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gdGhpcy54b2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luTGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpbkxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luTGVmdCA9IHRoaXMueG9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnhvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy55b2Zmc2V0ID4wKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblRvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLnlvZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdudyc6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJnaW5Cb3R0b20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luQm90dG9tID0gdGhpcy55b2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luVG9wID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnaW5zaWRlR3JpZCcpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3cnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFyZ2luQm90dG9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbkJvdHRvbSA9IHRoaXMueW9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpblRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ253JzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblRvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLnlvZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueW9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRPLURPOlxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBvZmZzZXRzIGFyZSA8IDAuXG4gICAgICAgIC8vXG4gICAgfTtcbiAgICBcbiAgICBMZWdlbmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyB0aGlzLnJlbmRlcmVyKCk7ICBcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXQuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyT3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICBMZWdlbmQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihvZmZzZXRzLCBwbG90KSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTwkLmpxcGxvdC5wcmVEcmF3TGVnZW5kSG9va3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgJC5qcXBsb3QucHJlRHJhd0xlZ2VuZEhvb2tzW2ldLmNhbGwodGhpcywgb2Zmc2V0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZHJhdy5jYWxsKHRoaXMsIG9mZnNldHMsIHBsb3QpO1xuICAgIH07XG4gICAgXG4gICAgTGVnZW5kLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24ob2Zmc2V0cykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnBhY2suY2FsbCh0aGlzLCBvZmZzZXRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3M6IFRpdGxlXG4gICAgICogUGxvdCBUaXRsZSBvYmplY3QuICBDYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LCBidXQgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBQbG90IG9iamVjdC4gIFRpdGxlIHByb3BlcnRpZXMgY2FuIGJlIHNldCBvciBvdmVycmlkZGVuIGJ5IHRoZSBcbiAgICAgKiBvcHRpb25zIHBhc3NlZCBpbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogdGV4dCAtIHRleHQgb2YgdGhlIHRpdGxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpdGxlKHRleHQpIHtcbiAgICAgICAgJC5qcXBsb3QuRWxlbUNvbnRhaW5lci5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBHcm91cDogUHJvcGVydGllc1xuICAgICAgICBcbiAgICAgICAgLy8gcHJvcDogdGV4dFxuICAgICAgICAvLyB0ZXh0IG9mIHRoZSB0aXRsZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgLy8gcHJvcDogc2hvd1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSB0aXRsZVxuICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAvLyBwcm9wOiBmb250RmFtaWx5XG4gICAgICAgIC8vIGNzcyBmb250LWZhbWlseSBzcGVjIGZvciB0aGUgdGV4dC5cbiAgICAgICAgdGhpcy5mb250RmFtaWx5O1xuICAgICAgICAvLyBwcm9wOiBmb250U2l6ZVxuICAgICAgICAvLyBjc3MgZm9udC1zaXplIHNwZWMgZm9yIHRoZSB0ZXh0LlxuICAgICAgICB0aGlzLmZvbnRTaXplIDtcbiAgICAgICAgLy8gcHJvcDogdGV4dEFsaWduXG4gICAgICAgIC8vIGNzcyB0ZXh0LWFsaWduIHNwZWMgZm9yIHRoZSB0ZXh0LlxuICAgICAgICB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgLy8gcHJvcDogdGV4dENvbG9yXG4gICAgICAgIC8vIGNzcyBjb2xvciBzcGVjIGZvciB0aGUgdGV4dC5cbiAgICAgICAgdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIC8vIHByb3A6IHJlbmRlcmVyXG4gICAgICAgIC8vIEEgY2xhc3MgZm9yIGNyZWF0aW5nIGEgRE9NIGVsZW1lbnQgZm9yIHRoZSB0aXRsZSxcbiAgICAgICAgLy8gc2VlIDwkLmpxcGxvdC5EaXZUaXRsZVJlbmRlcmVyPi5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9ICQuanFwbG90LkRpdlRpdGxlUmVuZGVyZXI7XG4gICAgICAgIC8vIHByb3A6IHJlbmRlcmVyT3B0aW9uc1xuICAgICAgICAvLyByZW5kZXJlciBzcGVjaWZpYyBvcHRpb25zIHBhc3NlZCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICAgIHRoaXMucmVuZGVyZXJPcHRpb25zID0ge307ICAgXG4gICAgICAgIC8vIHByb3A6IGVzY2FwZUh0bWxcbiAgICAgICAgLy8gVHJ1ZSB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHdpdGggdGhlaXIgaHRtbCBlbnRpdHkgZXF1aXZhbGVudHNcbiAgICAgICAgLy8gaW4gdGl0bGUgdGV4dC4gIFwiPFwiIGJlY29tZXMgJmx0OyBhbmQgc28gb24sIHNvIGh0bWwgdGFncyBhcmUgbm90IHJlbmRlcmVkLlxuICAgICAgICB0aGlzLmVzY2FwZUh0bWwgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgVGl0bGUucHJvdG90eXBlID0gbmV3ICQuanFwbG90LkVsZW1Db250YWluZXIoKTtcbiAgICBUaXRsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaXRsZTtcbiAgICBcbiAgICBUaXRsZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMucmVuZGVyZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IHRoaXMucmVuZGVyZXIoKTsgIFxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaW5pdC5jYWxsKHRoaXMsIHRoaXMucmVuZGVyZXJPcHRpb25zKTtcbiAgICB9O1xuICAgIFxuICAgIFRpdGxlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZHJhdy5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICB9O1xuICAgIFxuICAgIFRpdGxlLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucGFjay5jYWxsKHRoaXMpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBTZXJpZXNcbiAgICAgKiBBbiBpbmRpdmlkdWFsIGRhdGEgc2VyaWVzIG9iamVjdC4gIENhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIGJ1dCBjcmVhdGVkXG4gICAgICogYnkgdGhlIFBsb3Qgb2JqZWN0LiAgU2VyaWVzIHByb3BlcnRpZXMgY2FuIGJlIHNldCBvciBvdmVycmlkZGVuIGJ5IHRoZSBcbiAgICAgKiBvcHRpb25zIHBhc3NlZCBpbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlcmllcyhvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIEdyb3VwOiBQcm9wZXJ0aWVzXG4gICAgICAgIC8vIFByb3BlcnRpZXMgd2lsbCBiZSBhc3NpZ25lZCBmcm9tIGEgc2VyaWVzIGFycmF5IGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIG9wdGlvbnMuICBJZiB5b3UgaGFkIHR3byBzZXJpZXMgYW5kIHdhbnRlZCB0byBjaGFuZ2UgdGhlIGNvbG9yIGFuZCBsaW5lXG4gICAgICAgIC8vIHdpZHRoIG9mIHRoZSBmaXJzdCBhbmQgc2V0IHRoZSBzZWNvbmQgdG8gdXNlIHRoZSBzZWNvbmRhcnkgeSBheGlzIHdpdGhcbiAgICAgICAgLy8gbm8gc2hhZG93IGFuZCBzdXBwbHkgY3VzdG9tIGxhYmVscyBmb3IgZWFjaDpcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vID4gICAgc2VyaWVzOltcbiAgICAgICAgLy8gPiAgICAgICAge2NvbG9yOiAnI2ZmNDQ2NicsIGxpbmVXaWR0aDogNSwgbGFiZWw6J2dvb2QgbGluZSd9LFxuICAgICAgICAvLyA+ICAgICAgICB7eWF4aXM6ICd5MmF4aXMnLCBzaGFkb3c6IGZhbHNlLCBsYWJlbDonYmFkIGxpbmUnfVxuICAgICAgICAvLyA+ICAgIF1cbiAgICAgICAgLy8gPiB9XG5cbiAgICAgICAgLy8gcHJvcDogc2hvd1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBzZXJpZXMuXG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHhheGlzXG4gICAgICAgIC8vIHdoaWNoIHggYXhpcyB0byB1c2Ugd2l0aCB0aGlzIHNlcmllcywgZWl0aGVyICd4YXhpcycgb3IgJ3gyYXhpcycuXG4gICAgICAgIHRoaXMueGF4aXMgPSAneGF4aXMnO1xuICAgICAgICB0aGlzLl94YXhpcztcbiAgICAgICAgLy8gcHJvcDogeWF4aXNcbiAgICAgICAgLy8gd2hpY2ggeSBheGlzIHRvIHVzZSB3aXRoIHRoaXMgc2VyaWVzLCBlaXRoZXIgJ3lheGlzJyBvciAneTJheGlzJy5cbiAgICAgICAgdGhpcy55YXhpcyA9ICd5YXhpcyc7XG4gICAgICAgIHRoaXMuX3lheGlzO1xuICAgICAgICB0aGlzLmdyaWRCb3JkZXJXaWR0aCA9IDIuMDtcbiAgICAgICAgLy8gcHJvcDogcmVuZGVyZXJcbiAgICAgICAgLy8gQSBjbGFzcyBvZiBhIHJlbmRlcmVyIHdoaWNoIHdpbGwgZHJhdyB0aGUgc2VyaWVzLCBcbiAgICAgICAgLy8gc2VlIDwkLmpxcGxvdC5MaW5lUmVuZGVyZXI+LlxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gJC5qcXBsb3QuTGluZVJlbmRlcmVyO1xuICAgICAgICAvLyBwcm9wOiByZW5kZXJlck9wdGlvbnNcbiAgICAgICAgLy8gT3B0aW9ucyB0byBwYXNzIG9uIHRvIHRoZSByZW5kZXJlci5cbiAgICAgICAgdGhpcy5yZW5kZXJlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuZ3JpZERhdGEgPSBbXTtcbiAgICAgICAgLy8gcHJvcDogbGFiZWxcbiAgICAgICAgLy8gTGluZSBsYWJlbCB0byB1c2UgaW4gdGhlIGxlZ2VuZC5cbiAgICAgICAgdGhpcy5sYWJlbCA9ICcnO1xuICAgICAgICAvLyBwcm9wOiBzaG93TGFiZWxcbiAgICAgICAgLy8gdHJ1ZSB0byBzaG93IGxhYmVsIGZvciB0aGlzIHNlcmllcyBpbiB0aGUgbGVnZW5kLlxuICAgICAgICB0aGlzLnNob3dMYWJlbCA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IGNvbG9yXG4gICAgICAgIC8vIGNzcyBjb2xvciBzcGVjIGZvciB0aGUgc2VyaWVzXG4gICAgICAgIHRoaXMuY29sb3I7XG4gICAgICAgIC8vIHByb3A6IG5lZ2F0aXZlQ29sb3JcbiAgICAgICAgLy8gY3NzIGNvbG9yIHNwZWMgdXNlZCBmb3IgZmlsbGVkIChhcmVhKSBwbG90cyB0aGF0IGFyZSBmaWxsZWQgdG8gemVybyBhbmRcbiAgICAgICAgLy8gdGhlIFwidXNlTmVnYXRpdmVDb2xvcnNcIiBvcHRpb24gaXMgdHJ1ZS5cbiAgICAgICAgdGhpcy5uZWdhdGl2ZUNvbG9yO1xuICAgICAgICAvLyBwcm9wOiBsaW5lV2lkdGhcbiAgICAgICAgLy8gd2lkdGggb2YgdGhlIGxpbmUgaW4gcGl4ZWxzLiAgTWF5IGhhdmUgZGlmZmVyZW50IG1lYW5pbmdzIGRlcGVuZGluZyBvbiByZW5kZXJlci5cbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSAyLjU7XG4gICAgICAgIC8vIHByb3A6IGxpbmVKb2luXG4gICAgICAgIC8vIENhbnZhcyBsaW5lSm9pbiBzdHlsZSBiZXR3ZWVuIHNlZ21lbnRzIG9mIHNlcmllcy5cbiAgICAgICAgdGhpcy5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICAgIC8vIHByb3A6IGxpbmVDYXBcbiAgICAgICAgLy8gQ2FudmFzIGxpbmVDYXAgc3R5bGUgYXQgZW5kcyBvZiBsaW5lLlxuICAgICAgICB0aGlzLmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICAvLyBwcm9wOiBsaW5lUGF0dGVyblxuICAgICAgICAvLyBsaW5lIHBhdHRlcm4gJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnc29saWQnLCBzb21lIGNvbWJpbmF0aW9uXG4gICAgICAgIC8vIG9mICctJyBhbmQgJy4nIGNoYXJhY3RlcnMgc3VjaCBhcyAnLi0uJyBvciBhIG51bWVyaWNhbCBhcnJheSBsaWtlIFxuICAgICAgICAvLyBbZHJhdywgc2tpcCwgZHJhdywgc2tpcCwgLi4uXSBzdWNoIGFzIFsxLCAxMF0gdG8gZHJhdyBhIGRvdHRlZCBsaW5lLCBcbiAgICAgICAgLy8gWzEsIDEwLCAyMCwgMTBdIHRvIGRyYXcgYSBkb3QtZGFzaCBsaW5lLCBhbmQgc28gb24uXG4gICAgICAgIHRoaXMubGluZVBhdHRlcm4gPSAnc29saWQnO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd0FuZ2xlXG4gICAgICAgIC8vIFNoYWRvdyBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICAgIHRoaXMuc2hhZG93QW5nbGUgPSA0NTtcbiAgICAgICAgLy8gcHJvcDogc2hhZG93T2Zmc2V0XG4gICAgICAgIC8vIFNoYWRvdyBvZmZzZXQgZnJvbSBsaW5lIGluIHBpeGVsc1xuICAgICAgICB0aGlzLnNoYWRvd09mZnNldCA9IDEuMjU7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd0RlcHRoXG4gICAgICAgIC8vIE51bWJlciBvZiB0aW1lcyBzaGFkb3cgaXMgc3Ryb2tlZCwgZWFjaCBzdHJva2Ugb2Zmc2V0IHNoYWRvd09mZnNldCBmcm9tIHRoZSBsYXN0LlxuICAgICAgICB0aGlzLnNoYWRvd0RlcHRoID0gMztcbiAgICAgICAgLy8gcHJvcDogc2hhZG93QWxwaGFcbiAgICAgICAgLy8gQWxwaGEgY2hhbm5lbCB0cmFuc3BhcmVuY3kgb2Ygc2hhZG93LiAgMCA9IHRyYW5zcGFyZW50LlxuICAgICAgICB0aGlzLnNoYWRvd0FscGhhID0gJzAuMSc7XG4gICAgICAgIC8vIHByb3A6IGJyZWFrT25OdWxsXG4gICAgICAgIC8vIFdldGhlciBsaW5lIHNlZ21lbnRzIHNob3VsZCBiZSBiZSBicm9rZW4gYXQgbnVsbCB2YWx1ZS5cbiAgICAgICAgLy8gRmFsc2Ugd2lsbCBqb2luIHBvaW50IG9uIGVpdGhlciBzaWRlIG9mIGxpbmUuXG4gICAgICAgIHRoaXMuYnJlYWtPbk51bGwgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogbWFya2VyUmVuZGVyZXJcbiAgICAgICAgLy8gQSBjbGFzcyBvZiBhIHJlbmRlcmVyIHdoaWNoIHdpbGwgZHJhdyBtYXJrZXIgKGUuZy4gY2lyY2xlLCBzcXVhcmUsIC4uLikgYXQgdGhlIGRhdGEgcG9pbnRzLFxuICAgICAgICAvLyBzZWUgPCQuanFwbG90Lk1hcmtlclJlbmRlcmVyPi5cbiAgICAgICAgdGhpcy5tYXJrZXJSZW5kZXJlciA9ICQuanFwbG90Lk1hcmtlclJlbmRlcmVyO1xuICAgICAgICAvLyBwcm9wOiBtYXJrZXJPcHRpb25zXG4gICAgICAgIC8vIHJlbmRlcmVyIHNwZWNpZmljIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbWFya2VyUmVuZGVyZXIsXG4gICAgICAgIC8vIHNlZSA8JC5qcXBsb3QuTWFya2VyUmVuZGVyZXI+LlxuICAgICAgICB0aGlzLm1hcmtlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gcHJvcDogc2hvd0xpbmVcbiAgICAgICAgLy8gd2hldGhlciB0byBhY3R1YWxseSBkcmF3IHRoZSBsaW5lIG9yIG5vdC4gIFNlcmllcyB3aWxsIHN0aWxsIGJlIHJlbmRlcmVyZWQsIGV2ZW4gaWYgbm8gbGluZSBpcyBkcmF3bi5cbiAgICAgICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNob3dNYXJrZXJcbiAgICAgICAgLy8gd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgbWFya2VycyBhdCB0aGUgZGF0YSBwb2ludHMuXG4gICAgICAgIHRoaXMuc2hvd01hcmtlciA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IGluZGV4XG4gICAgICAgIC8vIDAgYmFzZWQgaW5kZXggb2YgdGhpcyBzZXJpZXMgaW4gdGhlIHBsb3Qgc2VyaWVzIGFycmF5LlxuICAgICAgICB0aGlzLmluZGV4O1xuICAgICAgICAvLyBwcm9wOiBmaWxsXG4gICAgICAgIC8vIHRydWUgb3IgZmFsc2UsIHdoZXRoZXIgdG8gZmlsbCB1bmRlciBsaW5lcyBvciBpbiBiYXJzLlxuICAgICAgICAvLyBNYXkgbm90IGJlIGltcGxlbWVudGVkIGluIGFsbCByZW5kZXJlcnMuXG4gICAgICAgIHRoaXMuZmlsbCA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBmaWxsQ29sb3JcbiAgICAgICAgLy8gQ1NTIGNvbG9yIHNwZWMgdG8gdXNlIGZvciBmaWxsIHVuZGVyIGxpbmUuICBEZWZhdWx0cyB0byBsaW5lIGNvbG9yLlxuICAgICAgICB0aGlzLmZpbGxDb2xvcjtcbiAgICAgICAgLy8gcHJvcDogZmlsbEFscGhhXG4gICAgICAgIC8vIEFscGhhIHRyYW5zcGFyZW5jeSB0byBhcHBseSB0byB0aGUgZmlsbCB1bmRlciB0aGUgbGluZS5cbiAgICAgICAgLy8gVXNlIHRoaXMgdG8gYWRqdXN0IGFscGhhIHNlcGFyYXRlIGZyb20gZmlsbCBjb2xvci5cbiAgICAgICAgdGhpcy5maWxsQWxwaGE7XG4gICAgICAgIC8vIHByb3A6IGZpbGxBbmRTdHJva2VcbiAgICAgICAgLy8gSWYgdHJ1ZSB3aWxsIHN0cm9rZSB0aGUgbGluZSAod2l0aCBjb2xvciB0aGlzLmNvbG9yKSBhcyB3ZWxsIGFzIGZpbGwgdW5kZXIgaXQuXG4gICAgICAgIC8vIEFwcGxpZXMgb25seSB3aGVuIGZpbGwgaXMgdHJ1ZS5cbiAgICAgICAgdGhpcy5maWxsQW5kU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IGRpc2FibGVTdGFja1xuICAgICAgICAvLyB0cnVlIHRvIG5vdCBzdGFjayB0aGlzIHNlcmllcyB3aXRoIG90aGVyIHNlcmllcyBpbiB0aGUgcGxvdC5cbiAgICAgICAgLy8gVG8gcmVuZGVyIHByb3Blcmx5LCBub24tc3RhY2tlZCBzZXJpZXMgbXVzdCBjb21lIGFmdGVyIGFueSBzdGFja2VkIHNlcmllc1xuICAgICAgICAvLyBpbiB0aGUgcGxvdCdzIGRhdGEgc2VyaWVzIGFycmF5LiAgU28sIHRoZSBwbG90J3MgZGF0YSBzZXJpZXMgYXJyYXkgd291bGQgbG9vayBsaWtlOlxuICAgICAgICAvLyA+IFtzdGFja2VkU2VyaWVzMSwgc3RhY2tlZFNlcmllczIsIC4uLiwgbm9uU3RhY2tlZFNlcmllczEsIG5vblN0YWNrZWRTZXJpZXMyLCAuLi5dXG4gICAgICAgIC8vIGRpc2FibGVTdGFjayB3aWxsIHB1dCBhIGdhcCBpbiB0aGUgc3RhY2tpbmcgb3JkZXIgb2Ygc2VyaWVzLCBhbmQgc3Vic2VxdWVudFxuICAgICAgICAvLyBzdGFja2VkIHNlcmllcyB3aWxsIG5vdCBmaWxsIGRvd24gdGhyb3VnaCB0aGUgbm9uLXN0YWNrZWQgc2VyaWVzIGFuZCB3aWxsXG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IG5vdCBzdGFjayBwcm9wZXJseSBvbiB0b3Agb2YgdGhlIG5vbi1zdGFja2VkIHNlcmllcy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgLy8gX3N0YWNrIGlzIHNldCBieSB0aGUgUGxvdCBpZiB0aGUgcGxvdCBpcyBhIHN0YWNrZWQgY2hhcnQuXG4gICAgICAgIC8vIHdpbGwgc3RhY2sgbGluZXMgb3IgYmFycyBvbiB0b3Agb2Ygb25lIGFub3RoZXIgdG8gYnVpbGQgYSBcIm1vdW50YWluXCIgc3R5bGUgY2hhcnQuXG4gICAgICAgIC8vIE1heSBub3QgYmUgaW1wbGVtZW50ZWQgaW4gYWxsIHJlbmRlcmVycy5cbiAgICAgICAgdGhpcy5fc3RhY2sgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogbmVpZ2hib3JUaHJlc2hvbGRcbiAgICAgICAgLy8gaG93IGNsb3NlIG9yIGZhciAoaW4gcGl4ZWxzKSB0aGUgY3Vyc29yIG11c3QgYmUgZnJvbSBhIHBvaW50IG1hcmtlciB0byBkZXRlY3QgdGhlIHBvaW50LlxuICAgICAgICB0aGlzLm5laWdoYm9yVGhyZXNob2xkID0gNDtcbiAgICAgICAgLy8gcHJvcDogZmlsbFRvWmVyb1xuICAgICAgICAvLyB0cnVlIHdpbGwgZm9yY2UgYmFyIGFuZCBmaWxsZWQgc2VyaWVzIHRvIGZpbGwgdG93YXJkIHplcm8gb24gdGhlIGZpbGwgQXhpcy5cbiAgICAgICAgdGhpcy5maWxsVG9aZXJvID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IGZpbGxUb1ZhbHVlXG4gICAgICAgIC8vIGZpbGwgYSBmaWxsZWQgc2VyaWVzIHRvIHRoaXMgdmFsdWUgb24gdGhlIGZpbGwgYXhpcy5cbiAgICAgICAgLy8gV29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCBmaWxsVG9aZXJvLCBzbyB0aGF0IG11c3QgYmUgdHJ1ZS5cbiAgICAgICAgdGhpcy5maWxsVG9WYWx1ZSA9IDA7XG4gICAgICAgIC8vIHByb3A6IGZpbGxBeGlzXG4gICAgICAgIC8vIEVpdGhlciAneCcgb3IgJ3knLiAgV2hpY2ggYXhpcyB0byBmaWxsIHRoZSBsaW5lIHRvd2FyZCBpZiBmaWxsVG9aZXJvIGlzIHRydWUuXG4gICAgICAgIC8vICd5JyBtZWFucyBmaWxsIHVwL2Rvd24gdG8gMCBvbiB0aGUgeSBheGlzIGZvciB0aGlzIHNlcmllcy5cbiAgICAgICAgdGhpcy5maWxsQXhpcyA9ICd5JztcbiAgICAgICAgLy8gcHJvcDogdXNlTmVnYXRpdmVDb2xvcnNcbiAgICAgICAgLy8gdHJ1ZSB0byBjb2xvciBuZWdhdGl2ZSB2YWx1ZXMgZGlmZmVyZW50bHkgaW4gZmlsbGVkIGFuZCBiYXIgY2hhcnRzLlxuICAgICAgICB0aGlzLnVzZU5lZ2F0aXZlQ29sb3JzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhY2tEYXRhID0gW107XG4gICAgICAgIC8vIF9wbG90RGF0YSBhY2NvdW50cyBmb3Igc3RhY2tpbmcuICBJZiBwbG90cyBub3Qgc3RhY2tlZCwgX3Bsb3REYXRhIGFuZCBkYXRhIGFyZSBzYW1lLiAgSWZcbiAgICAgICAgLy8gc3RhY2tlZCwgX3Bsb3REYXRhIGlzIGFjY3VtdWxhdGlvbiBvZiBzdGFja2luZyBkYXRhLlxuICAgICAgICB0aGlzLl9wbG90RGF0YSA9IFtdO1xuICAgICAgICAvLyBfcGxvdFZhbHVlcyBob2xkIHRoZSBpbmRpdmlkdWFsIHggYW5kIHkgdmFsdWVzIHRoYXQgd2lsbCBiZSBwbG90dGVkIGZvciB0aGlzIHNlcmllcy5cbiAgICAgICAgdGhpcy5fcGxvdFZhbHVlcyA9IHt4OltdLCB5OltdfTtcbiAgICAgICAgLy8gc3RhdGlzdGljcyBhYm91dCB0aGUgaW50ZXJ2YWxzIGJldHdlZW4gZGF0YSBwb2ludHMuICBVc2VkIGZvciBhdXRvIHNjYWxpbmcuXG4gICAgICAgIHRoaXMuX2ludGVydmFscyA9IHt4Ont9LCB5Ont9fTtcbiAgICAgICAgLy8gZGF0YSBmcm9tIHRoZSBwcmV2aW91cyBzZXJpZXMsIGZvciBzdGFja2VkIGNoYXJ0cy5cbiAgICAgICAgdGhpcy5fcHJldlBsb3REYXRhID0gW107XG4gICAgICAgIHRoaXMuX3ByZXZHcmlkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9zdGFja0F4aXMgPSAneSc7XG4gICAgICAgIHRoaXMuX3ByaW1hcnlBeGlzID0gJ194YXhpcyc7XG4gICAgICAgIC8vIGdpdmUgZWFjaCBzZXJpZXMgYSBjYW52YXMgdG8gZHJhdyBvbi4gIFRoaXMgc2hvdWxkIGFsbG93IGZvciByZWRyYXdpbmcgc3BlZWR1cHMuXG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3ICQuanFwbG90LkdlbmVyaWNDYW52YXMoKTtcbiAgICAgICAgdGhpcy5zaGFkb3dDYW52YXMgPSBuZXcgJC5qcXBsb3QuR2VuZXJpY0NhbnZhcygpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgLy8gc3VtIG9mIHkgdmFsdWVzIGluIHRoaXMgc2VyaWVzLlxuICAgICAgICB0aGlzLl9zdW15ID0gMDtcbiAgICAgICAgdGhpcy5fc3VteCA9IDA7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnJztcbiAgICAgICAgdGhpcy5zdGVwID0gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIFNlcmllcy5wcm90b3R5cGUgPSBuZXcgJC5qcXBsb3QuRWxlbUNvbnRhaW5lcigpO1xuICAgIFNlcmllcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXJpZXM7XG4gICAgXG4gICAgU2VyaWVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oaW5kZXgsIGdyaWRidywgcGxvdCkge1xuICAgICAgICAvLyB3ZWVkIG91dCBhbnkgbnVsbCB2YWx1ZXMgaW4gdGhlIGRhdGEuXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5ncmlkQm9yZGVyV2lkdGggPSBncmlkYnc7XG4gICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgdGVtcCA9IFtdLCBpLCBsO1xuICAgICAgICBmb3IgKGk9MCwgbD1kLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghIHRoaXMuYnJlYWtPbk51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZFtpXSA9PSBudWxsIHx8IGRbaV1bMF0gPT0gbnVsbCB8fCBkW2ldWzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggbnVsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBpbnZvbHZlIGtlZXBpbmcgbnVsbHMgaW4gZGF0YSBhcnJheVxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIHVwZGF0aW5nIHJlbmRlcmVycyB0byBicmVhayBsaW5lXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpdCBoaXRzIG51bGwgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdywganVzdCBrZWVwIHZhbHVlLlxuICAgICAgICAgICAgICAgIHRlbXAucHVzaChkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSB0ZW1wO1xuXG4gICAgICAgIC8vIHBhcnNlIHRoZSByZW5kZXJlciBvcHRpb25zIGFuZCBhcHBseSBkZWZhdWx0IGNvbG9ycyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgLy8gU2V0IGNvbG9yIGV2ZW4gaWYgbm90IHNob3duLCBzbyBzZXJpZXMgZG9uJ3QgY2hhbmdlIGNvbG9ycyB3aGVuIG90aGVyXG4gICAgICAgIC8vIHNlcmllcyBvbiBwbG90IHNob3duL2hpZGRlbi5cbiAgICAgICAgaWYgKCF0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gcGxvdC5jb2xvckdlbmVyYXRvci5nZXQodGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5lZ2F0aXZlQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVDb2xvciA9IHBsb3QubmVnYXRpdmVDb2xvckdlbmVyYXRvci5nZXQodGhpcy5pbmRleCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICghdGhpcy5maWxsQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsQWxwaGEpIHtcbiAgICAgICAgICAgIHZhciBjb21wID0gJC5qcXBsb3Qubm9ybWFsaXplMnJnYih0aGlzLmZpbGxDb2xvcik7XG4gICAgICAgICAgICB2YXIgY29tcCA9ICQuanFwbG90LmdldENvbG9yQ29tcG9uZW50cyhjb21wKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbENvbG9yID0gJ3JnYmEoJytjb21wWzBdKycsJytjb21wWzFdKycsJytjb21wWzJdKycsJyt0aGlzLmZpbGxBbHBoYSsnKSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyB0aGlzLnJlbmRlcmVyKCk7ICBcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXQuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyT3B0aW9ucywgcGxvdCk7XG4gICAgICAgIHRoaXMubWFya2VyUmVuZGVyZXIgPSBuZXcgdGhpcy5tYXJrZXJSZW5kZXJlcigpO1xuICAgICAgICBpZiAoIXRoaXMubWFya2VyT3B0aW9ucy5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJPcHRpb25zLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXJrZXJPcHRpb25zLnNob3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJPcHRpb25zLnNob3cgPSB0aGlzLnNob3dNYXJrZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93TWFya2VyID0gdGhpcy5tYXJrZXJPcHRpb25zLnNob3c7XG4gICAgICAgIC8vIHRoZSBtYXJrZXJSZW5kZXJlciBpcyBjYWxsZWQgd2l0aGluIGl0cyBvd24gc2NvcGUsIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIHNlcmllcyBvcHRpb25zISFcbiAgICAgICAgdGhpcy5tYXJrZXJSZW5kZXJlci5pbml0KHRoaXMubWFya2VyT3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBkYXRhIC0gb3B0aW9uYWwgZGF0YSBwb2ludCBhcnJheSB0byBkcmF3IHVzaW5nIHRoaXMgc2VyaWVzIHJlbmRlcmVyXG4gICAgLy8gZ3JpZERhdGEgLSBvcHRpb25hbCBncmlkIGRhdGEgcG9pbnQgYXJyYXkgdG8gZHJhdyB1c2luZyB0aGlzIHNlcmllcyByZW5kZXJlclxuICAgIC8vIHN0YWNrRGF0YSAtIGFycmF5IG9mIGN1bXVsYXRpdmUgZGF0YSBmb3Igc3RhY2tlZCBwbG90cy5cbiAgICBTZXJpZXMucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihzY3R4LCBvcHRzLCBwbG90KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gKG9wdHMgPT0gdW5kZWZpbmVkKSA/IHt9IDogb3B0cztcbiAgICAgICAgc2N0eCA9IChzY3R4ID09IHVuZGVmaW5lZCkgPyB0aGlzLmNhbnZhcy5fY3R4IDogc2N0eDtcbiAgICAgICAgXG4gICAgICAgIHZhciBqLCBkYXRhLCBncmlkRGF0YTtcbiAgICAgICAgXG4gICAgICAgIC8vIGhvb2tzIGdldCBjYWxsZWQgZXZlbiBpZiBzZXJpZXMgbm90IHNob3duXG4gICAgICAgIC8vIHdlIGRvbid0IGNsZWFyIGNhbnZhcyBoZXJlLCBpdCB3b3VsZCB3aXBlIG91dCBhbGwgb3RoZXIgc2VyaWVzIGFzIHdlbGwuXG4gICAgICAgIGZvciAoaj0wOyBqPCQuanFwbG90LnByZURyYXdTZXJpZXNIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgJC5qcXBsb3QucHJlRHJhd1Nlcmllc0hvb2tzW2pdLmNhbGwodGhpcywgc2N0eCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRHcmlkRGF0YS5jYWxsKHRoaXMsIHBsb3QpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByZXZlbnRKcVBsb3RTZXJpZXNEcmF3VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICQoc2N0eC5jYW52YXMpLnRyaWdnZXIoJ2pxcGxvdFNlcmllc0RyYXcnLCBbdGhpcy5kYXRhLCB0aGlzLmdyaWREYXRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9zdGFjaykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fcGxvdERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkRGF0YSA9IG9wdGlvbnMuZ3JpZERhdGEgfHwgdGhpcy5yZW5kZXJlci5tYWtlR3JpZERhdGEuY2FsbCh0aGlzLCBkYXRhLCBwbG90KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdsaW5lJyAmJiB0aGlzLnJlbmRlcmVyLnNtb290aCAmJiB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ3JpZERhdGEgPSB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZERhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZHJhdy5jYWxsKHRoaXMsIHNjdHgsIGdyaWREYXRhLCBvcHRpb25zLCBwbG90KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yIChqPTA7IGo8JC5qcXBsb3QucG9zdERyYXdTZXJpZXNIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgJC5qcXBsb3QucG9zdERyYXdTZXJpZXNIb29rc1tqXS5jYWxsKHRoaXMsIHNjdHgsIG9wdGlvbnMsIHBsb3QpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzY3R4ID0gb3B0cyA9IHBsb3QgPSBqID0gZGF0YSA9IGdyaWREYXRhID0gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIFNlcmllcy5wcm90b3R5cGUuZHJhd1NoYWRvdyA9IGZ1bmN0aW9uKHNjdHgsIG9wdHMsIHBsb3QpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSAob3B0cyA9PSB1bmRlZmluZWQpID8ge30gOiBvcHRzO1xuICAgICAgICBzY3R4ID0gKHNjdHggPT0gdW5kZWZpbmVkKSA/IHRoaXMuc2hhZG93Q2FudmFzLl9jdHggOiBzY3R4O1xuICAgICAgICBcbiAgICAgICAgdmFyIGosIGRhdGEsIGdyaWREYXRhO1xuICAgICAgICBcbiAgICAgICAgLy8gaG9va3MgZ2V0IGNhbGxlZCBldmVuIGlmIHNlcmllcyBub3Qgc2hvd25cbiAgICAgICAgLy8gd2UgZG9uJ3QgY2xlYXIgY2FudmFzIGhlcmUsIGl0IHdvdWxkIHdpcGUgb3V0IGFsbCBvdGhlciBzZXJpZXMgYXMgd2VsbC5cbiAgICAgICAgZm9yIChqPTA7IGo8JC5qcXBsb3QucHJlRHJhd1Nlcmllc1NoYWRvd0hvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAkLmpxcGxvdC5wcmVEcmF3U2VyaWVzU2hhZG93SG9va3Nbal0uY2FsbCh0aGlzLCBzY3R4LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0R3JpZERhdGEuY2FsbCh0aGlzLCBwbG90KTtcblxuICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fc3RhY2spIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX3Bsb3REYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZERhdGEgPSBvcHRpb25zLmdyaWREYXRhIHx8IHRoaXMucmVuZGVyZXIubWFrZUdyaWREYXRhLmNhbGwodGhpcywgZGF0YSwgcGxvdCk7XG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kcmF3U2hhZG93LmNhbGwodGhpcywgc2N0eCwgZ3JpZERhdGEsIG9wdGlvbnMsIHBsb3QpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKGo9MDsgajwkLmpxcGxvdC5wb3N0RHJhd1Nlcmllc1NoYWRvd0hvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAkLmpxcGxvdC5wb3N0RHJhd1Nlcmllc1NoYWRvd0hvb2tzW2pdLmNhbGwodGhpcywgc2N0eCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNjdHggPSBvcHRzID0gcGxvdCA9IGogPSBkYXRhID0gZ3JpZERhdGEgPSBudWxsO1xuICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgIC8vIHRvZ2dsZXMgc2VyaWVzIGRpc3BsYXkgb24gcGxvdCwgZS5nLiBzaG93L2hpZGUgc2VyaWVzXG4gICAgU2VyaWVzLnByb3RvdHlwZS50b2dnbGVEaXNwbGF5ID0gZnVuY3Rpb24oZXYsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzLCBzcGVlZDtcbiAgICAgICAgaWYgKGV2LmRhdGEuc2VyaWVzKSB7XG4gICAgICAgICAgICBzID0gZXYuZGF0YS5zZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldi5kYXRhLnNwZWVkKSB7XG4gICAgICAgICAgICBzcGVlZCA9IGV2LmRhdGEuc3BlZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB0cmlja3kgYmVjYXVzZSBzZXJpZXMgbWF5IG5vdCBoYXZlIGEgY2FudmFzIGVsZW1lbnQgaWYgcmVwbG90dGluZy5cbiAgICAgICAgICAgIGlmIChzLmNhbnZhcy5fZWxlbS5pcygnOmhpZGRlbicpIHx8ICFzLnNob3cpIHtcbiAgICAgICAgICAgICAgICBzLnNob3cgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcy5jYW52YXMuX2VsZW0ucmVtb3ZlQ2xhc3MoJ2pxcGxvdC1zZXJpZXMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHMuc2hhZG93Q2FudmFzLl9lbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuc2hhZG93Q2FudmFzLl9lbGVtLmZhZGVJbihzcGVlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLmZhZGVJbihzcGVlZCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLm5leHRBbGwoJy5qcXBsb3QtcG9pbnQtbGFiZWwuanFwbG90LXNlcmllcy0nK3MuaW5kZXgpLmZhZGVJbihzcGVlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzLnNob3cgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLmFkZENsYXNzKCdqcXBsb3Qtc2VyaWVzLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGlmIChzLnNoYWRvd0NhbnZhcy5fZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBzLnNoYWRvd0NhbnZhcy5fZWxlbS5mYWRlT3V0KHNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcy5jYW52YXMuX2VsZW0uZmFkZU91dChzcGVlZCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLm5leHRBbGwoJy5qcXBsb3QtcG9pbnQtbGFiZWwuanFwbG90LXNlcmllcy0nK3MuaW5kZXgpLmZhZGVPdXQoc3BlZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBjYW4gYmUgdHJpY2t5IGJlY2F1c2Ugc2VyaWVzIG1heSBub3QgaGF2ZSBhIGNhbnZhcyBlbGVtZW50IGlmIHJlcGxvdHRpbmcuXG4gICAgICAgICAgICBpZiAocy5jYW52YXMuX2VsZW0uaXMoJzpoaWRkZW4nKSB8fCAhcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgcy5zaG93ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLnJlbW92ZUNsYXNzKCdqcXBsb3Qtc2VyaWVzLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGlmIChzLnNoYWRvd0NhbnZhcy5fZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBzLnNoYWRvd0NhbnZhcy5fZWxlbS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLnNob3coMCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHMuY2FudmFzLl9lbGVtLm5leHRBbGwoJy5qcXBsb3QtcG9pbnQtbGFiZWwuanFwbG90LXNlcmllcy0nK3MuaW5kZXgpLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMuc2hvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcy5jYW52YXMuX2VsZW0uYWRkQ2xhc3MoJ2pxcGxvdC1zZXJpZXMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHMuc2hhZG93Q2FudmFzLl9lbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuc2hhZG93Q2FudmFzLl9lbGVtLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcy5jYW52YXMuX2VsZW0uaGlkZSgwLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcy5jYW52YXMuX2VsZW0ubmV4dEFsbCgnLmpxcGxvdC1wb2ludC1sYWJlbC5qcXBsb3Qtc2VyaWVzLScrcy5pbmRleCkuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcblxuXG4gICAgLyoqXG4gICAgICogQ2xhc3M6IEdyaWRcbiAgICAgKiBcbiAgICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBncmlkIG9uIHdoaWNoIHRoZSBwbG90IGlzIGRyYXduLiAgVGhlIGdyaWQgaW4gdGhpc1xuICAgICAqIGNvbnRleHQgaXMgdGhlIGFyZWEgYm91bmRlZCBieSB0aGUgYXhlcywgdGhlIGFyZWEgd2hpY2ggd2lsbCBjb250YWluIHRoZSBzZXJpZXMuXG4gICAgICogTm90ZSwgdGhlIHNlcmllcyBhcmUgZHJhd24gb24gdGhlaXIgb3duIGNhbnZhcy5cbiAgICAgKiBUaGUgR3JpZCBvYmplY3QgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseSwgYnV0IGlzIGNyZWF0ZWQgYnkgdGhlIFBsb3Qgb2JqZWN0LiAgXG4gICAgICogR3JpZCBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgb3Igb3ZlcnJpZGRlbiBieSB0aGUgb3B0aW9ucyBwYXNzZWQgaW4gZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHcmlkKCkge1xuICAgICAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIEdyb3VwOiBQcm9wZXJ0aWVzXG4gICAgICAgIFxuICAgICAgICAvLyBwcm9wOiBkcmF3R3JpZGxpbmVzXG4gICAgICAgIC8vIHdoZXRoZXIgdG8gZHJhdyB0aGUgZ3JpZGxpbmVzIG9uIHRoZSBwbG90LlxuICAgICAgICB0aGlzLmRyYXdHcmlkbGluZXMgPSB0cnVlO1xuICAgICAgICAvLyBwcm9wOiBncmlkTGluZUNvbG9yXG4gICAgICAgIC8vIGNvbG9yIG9mIHRoZSBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLmdyaWRMaW5lQ29sb3IgPSAnI2NjY2NjYyc7XG4gICAgICAgIC8vIHByb3A6IGdyaWRMaW5lV2lkdGhcbiAgICAgICAgLy8gd2lkdGggb2YgdGhlIGdyaWQgbGluZXMuXG4gICAgICAgIHRoaXMuZ3JpZExpbmVXaWR0aCA9IDEuMDtcbiAgICAgICAgLy8gcHJvcDogYmFja2dyb3VuZFxuICAgICAgICAvLyBjc3Mgc3BlYyBmb3IgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICcjZmZmZGY2JztcbiAgICAgICAgLy8gcHJvcDogYm9yZGVyQ29sb3JcbiAgICAgICAgLy8gY3NzIHNwZWMgZm9yIHRoZSBjb2xvciBvZiB0aGUgZ3JpZCBib3JkZXIuXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAnIzk5OTk5OSc7XG4gICAgICAgIC8vIHByb3A6IGJvcmRlcldpZHRoXG4gICAgICAgIC8vIHdpZHRoIG9mIHRoZSBib3JkZXIgaW4gcGl4ZWxzLlxuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gMi4wO1xuICAgICAgICAvLyBwcm9wOiBkcmF3Qm9yZGVyXG4gICAgICAgIC8vIFRydWUgdG8gZHJhdyBib3JkZXIgYXJvdW5kIGdyaWQuXG4gICAgICAgIHRoaXMuZHJhd0JvcmRlciA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd1xuICAgICAgICAvLyB3aGV0aGVyIHRvIHNob3cgYSBzaGFkb3cgYmVoaW5kIHRoZSBncmlkLlxuICAgICAgICB0aGlzLnNoYWRvdyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd0FuZ2xlXG4gICAgICAgIC8vIHNoYWRvdyBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICAgIHRoaXMuc2hhZG93QW5nbGUgPSA0NTtcbiAgICAgICAgLy8gcHJvcDogc2hhZG93T2Zmc2V0XG4gICAgICAgIC8vIE9mZnNldCBvZiBlYWNoIHNoYWRvdyBzdHJva2UgZnJvbSB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAgICB0aGlzLnNoYWRvd09mZnNldCA9IDEuNTtcbiAgICAgICAgLy8gcHJvcDogc2hhZG93V2lkdGhcbiAgICAgICAgLy8gd2lkdGggb2YgdGhlIHN0b2tlIGZvciB0aGUgc2hhZG93XG4gICAgICAgIHRoaXMuc2hhZG93V2lkdGggPSAzO1xuICAgICAgICAvLyBwcm9wOiBzaGFkb3dEZXB0aFxuICAgICAgICAvLyBOdW1iZXIgb2YgdGltZXMgc2hhZG93IGlzIHN0cm9rZWQsIGVhY2ggc3Ryb2tlIG9mZnNldCBzaGFkb3dPZmZzZXQgZnJvbSB0aGUgbGFzdC5cbiAgICAgICAgdGhpcy5zaGFkb3dEZXB0aCA9IDM7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd0NvbG9yXG4gICAgICAgIC8vIGFuIG9wdGlvbmFsIGNzcyBjb2xvciBzcGVjIGZvciB0aGUgc2hhZG93IGluICdyZ2JhKG4sIG4sIG4sIG4pJyBmb3JtXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBzaGFkb3dBbHBoYVxuICAgICAgICAvLyBBbHBoYSBjaGFubmVsIHRyYW5zcGFyZW5jeSBvZiBzaGFkb3cuICAwID0gdHJhbnNwYXJlbnQuXG4gICAgICAgIHRoaXMuc2hhZG93QWxwaGEgPSAnMC4wNyc7XG4gICAgICAgIHRoaXMuX2xlZnQ7XG4gICAgICAgIHRoaXMuX3RvcDtcbiAgICAgICAgdGhpcy5fcmlnaHQ7XG4gICAgICAgIHRoaXMuX2JvdHRvbTtcbiAgICAgICAgdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5fYXhlcyA9IFtdO1xuICAgICAgICAvLyBwcm9wOiByZW5kZXJlclxuICAgICAgICAvLyBJbnN0YW5jZSBvZiBhIHJlbmRlcmVyIHdoaWNoIHdpbGwgYWN0dWFsbHkgcmVuZGVyIHRoZSBncmlkLFxuICAgICAgICAvLyBzZWUgPCQuanFwbG90LkNhbnZhc0dyaWRSZW5kZXJlcj4uXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSAkLmpxcGxvdC5DYW52YXNHcmlkUmVuZGVyZXI7XG4gICAgICAgIC8vIHByb3A6IHJlbmRlcmVyT3B0aW9uc1xuICAgICAgICAvLyBPcHRpb25zIHRvIHBhc3Mgb24gdG8gdGhlIHJlbmRlcmVyLFxuICAgICAgICAvLyBzZWUgPCQuanFwbG90LkNhbnZhc0dyaWRSZW5kZXJlcj4uXG4gICAgICAgIHRoaXMucmVuZGVyZXJPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuX29mZnNldHMgPSB7dG9wOm51bGwsIGJvdHRvbTpudWxsLCBsZWZ0Om51bGwsIHJpZ2h0Om51bGx9O1xuICAgIH1cbiAgICBcbiAgICBHcmlkLnByb3RvdHlwZSA9IG5ldyAkLmpxcGxvdC5FbGVtQ29udGFpbmVyKCk7XG4gICAgR3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkO1xuICAgIFxuICAgIEdyaWQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyB0aGlzLnJlbmRlcmVyKCk7ICBcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXQuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyT3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICBHcmlkLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24ob2Zmc2V0cyxwbG90KSB7XG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBvZmZzZXRzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgcGxvdCk7XG4gICAgfTtcbiAgICBcbiAgICBHcmlkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZHJhdy5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuR2VuZXJpY0NhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2N0eDsgIFxuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuR2VuZXJpY0NhbnZhcy5wcm90b3R5cGUgPSBuZXcgJC5qcXBsb3QuRWxlbUNvbnRhaW5lcigpO1xuICAgICQuanFwbG90LkdlbmVyaWNDYW52YXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gJC5qcXBsb3QuR2VuZXJpY0NhbnZhcztcbiAgICBcbiAgICAkLmpxcGxvdC5HZW5lcmljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24ob2Zmc2V0cywgY2xzcywgcGxvdERpbWVuc2lvbnMsIHBsb3QpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgICAgIHZhciBrbGFzcyA9ICdqcXBsb3QnO1xuICAgICAgICBpZiAoY2xzcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtsYXNzID0gY2xzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbTtcblxuICAgICAgICBlbGVtID0gcGxvdC5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gaWYgbmV3IHBsb3REaW1lbnNpb25zIHN1cHBsaWVkLCB1c2UgdGhlbS5cbiAgICAgICAgaWYgKHBsb3REaW1lbnNpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bsb3REaW1lbnNpb25zID0gcGxvdERpbWVuc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVsZW0ud2lkdGggPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIHRoaXMuX29mZnNldHMubGVmdCAtIHRoaXMuX29mZnNldHMucmlnaHQ7XG4gICAgICAgIGVsZW0uaGVpZ2h0ID0gdGhpcy5fcGxvdERpbWVuc2lvbnMuaGVpZ2h0IC0gdGhpcy5fb2Zmc2V0cy50b3AgLSB0aGlzLl9vZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgdGhpcy5fZWxlbSA9ICQoZWxlbSk7XG4gICAgICAgIHRoaXMuX2VsZW0uY3NzKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHRoaXMuX29mZnNldHMubGVmdCwgdG9wOiB0aGlzLl9vZmZzZXRzLnRvcCB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2VsZW0uYWRkQ2xhc3Moa2xhc3MpO1xuICAgICAgICBcbiAgICAgICAgZWxlbSA9IHBsb3QuY2FudmFzTWFuYWdlci5pbml0Q2FudmFzKGVsZW0pO1xuICAgICAgICBcbiAgICAgICAgZWxlbSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuR2VuZXJpY0NhbnZhcy5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9lbGVtLmdldCgwKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgfTtcbiAgICBcbiAgICAvLyBNZW1vcnkgTGVha3MgcGF0Y2hcbiAgICAkLmpxcGxvdC5HZW5lcmljQ2FudmFzLnByb3RvdHlwZS5yZXNldENhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2VsZW0pIHtcbiAgICAgICAgaWYgKCQuanFwbG90LnVzZV9leGNhbnZhcyAmJiB3aW5kb3cuR192bWxDYW52YXNNYW5hZ2VyLnVuaW5pdEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICB3aW5kb3cuR192bWxDYW52YXNNYW5hZ2VyLnVuaW5pdEVsZW1lbnQodGhpcy5fZWxlbS5nZXQoMCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3RoaXMuX2VsZW0ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX2VsZW0uZW1wdHlGb3JjZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9jdHggPSBudWxsO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuSG9va3NNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhvb2tzID1bXTtcbiAgICAgICAgdGhpcy5hcmdzID0gW107XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5Ib29rc01hbmFnZXIucHJvdG90eXBlLmFkZE9uY2UgPSBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgdmFyIGhhdmVob29rID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGk9MCwgbD10aGlzLmhvb2tzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvb2tzW2ldID09IGZuKSB7XG4gICAgICAgICAgICAgICAgaGF2ZWhvb2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGF2ZWhvb2spIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MucHVzaChmbik7XG4gICAgICAgICAgICB0aGlzLmFyZ3MucHVzaChhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuSG9va3NNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgdGhpcy5ob29rcy5wdXNoKGZuKTtcbiAgICAgICAgdGhpcy5hcmdzLnB1c2goYXJncyk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FdmVudExpc3RlbmVyTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9W107XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5FdmVudExpc3RlbmVyTWFuYWdlci5wcm90b3R5cGUuYWRkT25jZSA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICAgICAgICB2YXIgaGF2ZWhvb2sgPSBmYWxzZSwgaCwgaTtcbiAgICAgICAgZm9yICh2YXIgaT0wLCBsPXRoaXMuaG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgaCA9IHRoaXMuaG9va3NbaV07XG4gICAgICAgICAgICBpZiAoaFswXSA9PSBldiAmJiBoWzFdID09IGZuKSB7XG4gICAgICAgICAgICAgICAgaGF2ZWhvb2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGF2ZWhvb2spIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MucHVzaChbZXYsIGZuXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkV2ZW50TGlzdGVuZXJNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgICAgICAgdGhpcy5ob29rcy5wdXNoKFtldiwgZm5dKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2F4aXNOYW1lcyA9IFsneU1pZEF4aXMnLCAneGF4aXMnLCAneWF4aXMnLCAneDJheGlzJywgJ3kyYXhpcycsICd5M2F4aXMnLCAneTRheGlzJywgJ3k1YXhpcycsICd5NmF4aXMnLCAneTdheGlzJywgJ3k4YXhpcycsICd5OWF4aXMnXTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBqcVBsb3RcbiAgICAgKiBQbG90IG9iamVjdCByZXR1cm5lZCBieSBjYWxsIHRvICQuanFwbG90LiAgSGFuZGxlcyBwYXJzaW5nIHVzZXIgb3B0aW9ucyxcbiAgICAgKiBjcmVhdGluZyBzdWIgb2JqZWN0cyAoQXhlcywgbGVnZW5kLCB0aXRsZSwgc2VyaWVzKSBhbmQgcmVuZGVyaW5nIHRoZSBwbG90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpxUGxvdCgpIHtcbiAgICAgICAgLy8gR3JvdXA6IFByb3BlcnRpZXNcbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIGF0IHRoZSB0b3Agb2YgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgIC8vIGxpa2Ugc286XG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyA+ICAgICBheGVzRGVmYXVsdHM6e21pbjowfSxcbiAgICAgICAgLy8gPiAgICAgc2VyaWVzOlt7Y29sb3I6JyM2NjMzZGQnfV0sXG4gICAgICAgIC8vID4gICAgIHRpdGxlOiAnQSBQbG90J1xuICAgICAgICAvLyA+IH1cbiAgICAgICAgLy9cblxuICAgICAgICAvLyBwcm9wOiBhbmltYXRlXG4gICAgICAgIC8vIFRydWUgdG8gYW5pbWF0ZSB0aGUgc2VyaWVzIG9uIGluaXRpYWwgcGxvdCBkcmF3IChyZW5kZXJlciBkZXBlbmRlbnQpLlxuICAgICAgICAvLyBBY3R1YWwgYW5pbWF0aW9uIGZ1bmN0aW9uYWxpdHkgbXVzdCBiZSBzdXBwb3J0ZWQgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogYW5pbWF0ZVJlcGxvdFxuICAgICAgICAvLyBUcnVlIHRvIGFuaW1hdGUgc2VyaWVzIGFmdGVyIGEgY2FsbCB0byB0aGUgcmVwbG90KCkgbWV0aG9kLlxuICAgICAgICAvLyBVc2Ugd2l0aCBjYXV0aW9uISAgUmVwbG90cyBjYW4gaGFwcGVuIHZlcnkgZnJlcXVlbnRseSB1bmRlclxuICAgICAgICAvLyBjZXJ0YWluIGNpcmN1bXN0YW5jZXMgKGUuZy4gcmVzaXppbmcsIGRyYWdnaW5nIHBvaW50cykgYW5kXG4gICAgICAgIC8vIGFuaW1hdGlvbiBpbiB0aGVzZSBzaXR1YXRpb25zIGNhbiBjYXVzZSBwcm9ibGVtcy5cbiAgICAgICAgdGhpcy5hbmltYXRlUmVwbG90ID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IGF4ZXNcbiAgICAgICAgLy8gdXAgdG8gNCBheGVzIGFyZSBzdXBwb3J0ZWQsIGVhY2ggd2l0aCBpdHMgb3duIG9wdGlvbnMsIFxuICAgICAgICAvLyBTZWUgPEF4aXM+IGZvciBheGlzIHNwZWNpZmljIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuYXhlcyA9IHt4YXhpczogbmV3IEF4aXMoJ3hheGlzJyksIHlheGlzOiBuZXcgQXhpcygneWF4aXMnKSwgeDJheGlzOiBuZXcgQXhpcygneDJheGlzJyksIHkyYXhpczogbmV3IEF4aXMoJ3kyYXhpcycpLCB5M2F4aXM6IG5ldyBBeGlzKCd5M2F4aXMnKSwgeTRheGlzOiBuZXcgQXhpcygneTRheGlzJyksIHk1YXhpczogbmV3IEF4aXMoJ3k1YXhpcycpLCB5NmF4aXM6IG5ldyBBeGlzKCd5NmF4aXMnKSwgeTdheGlzOiBuZXcgQXhpcygneTdheGlzJyksIHk4YXhpczogbmV3IEF4aXMoJ3k4YXhpcycpLCB5OWF4aXM6IG5ldyBBeGlzKCd5OWF4aXMnKSwgeU1pZEF4aXM6IG5ldyBBeGlzKCd5TWlkQXhpcycpfTtcbiAgICAgICAgdGhpcy5iYXNlQ2FudmFzID0gbmV3ICQuanFwbG90LkdlbmVyaWNDYW52YXMoKTtcbiAgICAgICAgLy8gdHJ1ZSB0byBpbnRlcmNlcHQgcmlnaHQgY2xpY2sgZXZlbnRzIGFuZCBmaXJlIGEgJ2pxcGxvdFJpZ2h0Q2xpY2snIGV2ZW50LlxuICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyBibG9jayB0aGUgY29udGV4dCBtZW51LlxuICAgICAgICB0aGlzLmNhcHR1cmVSaWdodENsaWNrID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IGRhdGFcbiAgICAgICAgLy8gdXNlcidzIGRhdGEuICBEYXRhIHNob3VsZCAqTk9UKiBiZSBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LFxuICAgICAgICAvLyBidXQgYmUgcGFzc2VkIGluIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlICQuanFwbG90KCkgZnVuY3Rpb24uXG4gICAgICAgIC8vIFRoZSBkYXRhIHByb3BlcnR5IGlzIGRlc2NyaWJlZCBoZXJlIHNvbGV5IGZvciByZWZlcmVuY2UuIFxuICAgICAgICAvLyBUaGUgZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvcm0gb2YgYW4gYXJyYXkgb2YgMkQgb3IgMUQgYXJyYXlzIGxpa2VcbiAgICAgICAgLy8gPiBbIFtbeDEsIHkxXSwgW3gyLCB5Ml0sLi4uXSwgW3kxLCB5MiwgLi4uXSBdLlxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgLy8gcHJvcDogZGF0YVJlbmRlcmVyXG4gICAgICAgIC8vIEEgY2FsbGFibGUgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcHJlcHJvY2VzcyBkYXRhIHBhc3NlZCBpbnRvIHRoZSBwbG90LlxuICAgICAgICAvLyBXaWxsIGJlIGNhbGxlZCB3aXRoIDMgYXJndW1lbnRzOiB0aGUgcGxvdCBkYXRhLCBhIHJlZmVyZW5jZSB0byB0aGUgcGxvdCxcbiAgICAgICAgLy8gYW5kIHRoZSB2YWx1ZSBvZiBkYXRhUmVuZGVyZXJPcHRpb25zLlxuICAgICAgICB0aGlzLmRhdGFSZW5kZXJlcjtcbiAgICAgICAgLy8gcHJvcDogZGF0YVJlbmRlcmVyT3B0aW9uc1xuICAgICAgICAvLyBPcHRpb25zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGRhdGFSZW5kZXJlci5cbiAgICAgICAgLy8gQ2FuIGJlIG9mIGFueSB0eXBlLlxuICAgICAgICB0aGlzLmRhdGFSZW5kZXJlck9wdGlvbnM7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAvLyBwcm9wOiBheGVzRGVmYXVsdHNcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgb3B0aW9ucyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbGwgYXhlcy5cbiAgICAgICAgICAgIC8vIHNlZSA8QXhpcz4gZm9yIGF4ZXMgb3B0aW9ucy5cbiAgICAgICAgICAgIGF4ZXNEZWZhdWx0czoge30sXG4gICAgICAgICAgICBheGVzOiB7eGF4aXM6e30sIHlheGlzOnt9LCB4MmF4aXM6e30sIHkyYXhpczp7fSwgeTNheGlzOnt9LCB5NGF4aXM6e30sIHk1YXhpczp7fSwgeTZheGlzOnt9LCB5N2F4aXM6e30sIHk4YXhpczp7fSwgeTlheGlzOnt9LCB5TWlkQXhpczp7fX0sXG4gICAgICAgICAgICAvLyBwcm9wOiBzZXJpZXNEZWZhdWx0c1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBzZXJpZXMuXG4gICAgICAgICAgICAvLyBzZWUgPFNlcmllcz4gZm9yIHNlcmllcyBvcHRpb25zLlxuICAgICAgICAgICAgc2VyaWVzRGVmYXVsdHM6IHt9LFxuICAgICAgICAgICAgc2VyaWVzOltdXG4gICAgICAgIH07XG4gICAgICAgIC8vIHByb3A6IGRlZmF1bHRBeGlzU3RhcnRcbiAgICAgICAgLy8gMS1EIGRhdGEgc2VyaWVzIGFyZSBpbnRlcm5hbGx5IGNvbnZlcnRlZCBpbnRvIDItRCBbeCx5XSBkYXRhIHBvaW50IGFycmF5c1xuICAgICAgICAvLyBieSBqcVBsb3QuICBUaGlzIGlzIHRoZSBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgbWlzc2luZyB4IG9yIHkgdmFsdWUuXG4gICAgICAgIC8vIFRoZSBhZGRlZCBkYXRhIHdpbGwgYmUgYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgc2VyaWVzIChlLmcuIFsxLCAyLCAzLCAuLi5dKVxuICAgICAgICAvLyBzdGFydGluZyBhdCB0aGlzIHZhbHVlLlxuICAgICAgICB0aGlzLmRlZmF1bHRBeGlzU3RhcnQgPSAxO1xuICAgICAgICAvLyB0aGlzLmRvQ3VzdG9tRXZlbnRCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogZHJhd0lmSGlkZGVuXG4gICAgICAgIC8vIFRydWUgdG8gZXhlY3V0ZSB0aGUgZHJhdyBtZXRob2QgZXZlbiBpZiB0aGUgcGxvdCB0YXJnZXQgaXMgaGlkZGVuLlxuICAgICAgICAvLyBHZW5lcmFsbHksIHRoaXMgc2hvdWxkIGJlIGZhbHNlLiAgTW9zdCBwbG90IGVsZW1lbnRzIHdpbGwgbm90IGJlIHNpemVkL1xuICAgICAgICAvLyBwb3NpdGlvbmVkIGNvcnJlY2x0eSBpZiByZW5kZXJlcmVkIGludG8gYSBoaWRkZW4gY29udGFpbmVyLiAgVG8gcmVuZGVyIGludG9cbiAgICAgICAgLy8gYSBoaWRkZW4gY29udGFpbmVyLCBjYWxsIHRoZSByZXBsb3QgbWV0aG9kIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBzaG93bi5cbiAgICAgICAgdGhpcy5kcmF3SWZIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudENhbnZhcyA9IG5ldyAkLmpxcGxvdC5HZW5lcmljQ2FudmFzKCk7XG4gICAgICAgIC8vIHByb3A6IGZpbGxCZXR3ZWVuXG4gICAgICAgIC8vIEZpbGwgYmV0d2VlbiAyIGxpbmUgc2VyaWVzIGluIGEgcGxvdC5cbiAgICAgICAgLy8gT3B0aW9ucyBvYmplY3Q6XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgc2VyaWVzMTogZmlyc3QgaW5kZXggKDAgYmFzZWQpIG9mIHNlcmllcyBpbiBmaWxsXG4gICAgICAgIC8vICAgIHNlcmllczI6IHNlY29uZCBpbmRleCAoMCBiYXNlZCkgb2Ygc2VyaWVzIGluIGZpbGxcbiAgICAgICAgLy8gICAgY29sb3I6IGNvbG9yIG9mIGZpbGwgW2RlZmF1bHQgZmlsbENvbG9yIG9mIHNlcmllczFdXG4gICAgICAgIC8vICAgIGJhc2VTZXJpZXM6ICBmaWxsIHdpbGwgYmUgZHJhd24gYmVsb3cgdGhpcyBzZXJpZXMgKDAgYmFzZWQgaW5kZXgpXG4gICAgICAgIC8vICAgIGZpbGw6IGZhbHNlIHRvIHR1cm4gb2ZmIGZpbGwgW2RlZmF1bHQgdHJ1ZV0uXG4gICAgICAgIC8vICB9XG4gICAgICAgIHRoaXMuZmlsbEJldHdlZW4gPSB7XG4gICAgICAgICAgICBzZXJpZXMxOiBudWxsLFxuICAgICAgICAgICAgc2VyaWVzMjogbnVsbCxcbiAgICAgICAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgICAgICAgYmFzZVNlcmllczogMCxcbiAgICAgICAgICAgIGZpbGw6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJvcDsgZm9udEZhbWlseVxuICAgICAgICAvLyBjc3Mgc3BlYyBmb3IgdGhlIGZvbnQtZmFtaWx5IGF0dHJpYnV0ZS4gIERlZmF1bHQgZm9yIHRoZSBlbnRpcmUgcGxvdC5cbiAgICAgICAgdGhpcy5mb250RmFtaWx5O1xuICAgICAgICAvLyBwcm9wOiBmb250U2l6ZVxuICAgICAgICAvLyBjc3Mgc3BlYyBmb3IgdGhlIGZvbnQtc2l6ZSBhdHRyaWJ1dGUuICBEZWZhdWx0IGZvciB0aGUgZW50aXJlIHBsb3QuXG4gICAgICAgIHRoaXMuZm9udFNpemU7XG4gICAgICAgIC8vIHByb3A6IGdyaWRcbiAgICAgICAgLy8gU2VlIDxHcmlkPiBmb3IgZ3JpZCBzcGVjaWZpYyBvcHRpb25zLlxuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZCgpO1xuICAgICAgICAvLyBwcm9wOiBsZWdlbmRcbiAgICAgICAgLy8gc2VlIDwkLmpxcGxvdC5UYWJsZUxlZ2VuZFJlbmRlcmVyPlxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQoKTtcbiAgICAgICAgLy8gcHJvcDogbm9EYXRhSW5kaWNhdG9yXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gc2V0IHVwIGEgbW9jayBwbG90IHdpdGggYSBkYXRhIGxvYWRpbmcgaW5kaWNhdG9yIGlmIG5vIGRhdGEgaXMgc3BlY2lmaWVkLlxuICAgICAgICB0aGlzLm5vRGF0YUluZGljYXRvciA9IHsgICAgXG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGluZGljYXRvcjogJ0xvYWRpbmcgRGF0YS4uLicsXG4gICAgICAgICAgICBheGVzOiB7XG4gICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IDEwLFxuICAgICAgICAgICAgICAgICAgICB0aWNrSW50ZXJ2YWw6IDIsXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAxMixcbiAgICAgICAgICAgICAgICAgICAgdGlja0ludGVydmFsOiAzLFxuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwcm9wOiBuZWdhdGl2ZVNlcmllc0NvbG9ycyBcbiAgICAgICAgLy8gY29sb3JzIHRvIHVzZSBmb3IgcG9ydGlvbnMgb2YgdGhlIGxpbmUgYmVsb3cgemVyby5cbiAgICAgICAgdGhpcy5uZWdhdGl2ZVNlcmllc0NvbG9ycyA9ICQuanFwbG90LmNvbmZpZy5kZWZhdWx0TmVnYXRpdmVDb2xvcnM7XG4gICAgICAgIC8vIGNvbnRhaW5lciB0byBob2xkIGFsbCBvZiB0aGUgbWVyZ2VkIG9wdGlvbnMuICBDb252aWVuZW5jZSBmb3IgcGx1Z2lucy5cbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMucHJldmlvdXNTZXJpZXNTdGFjayA9IFtdO1xuICAgICAgICAvLyBOYW1lc3BhY2UgdG8gaG9sZCBwbHVnaW5zLiAgR2VuZXJhbGx5IG5vbi1yZW5kZXJlciBwbHVnaW5zIGFkZCB0aGVtc2VsdmVzIHRvIGhlcmUuXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgICAgICAvLyBwcm9wOiBzZXJpZXNcbiAgICAgICAgLy8gQXJyYXkgb2Ygc2VyaWVzIG9iamVjdCBvcHRpb25zLlxuICAgICAgICAvLyBzZWUgPFNlcmllcz4gZm9yIHNlcmllcyBzcGVjaWZpYyBvcHRpb25zLlxuICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgICAgICAvLyBhcnJheSBvZiBzZXJpZXMgaW5kaWNlcy4gS2VlcCB0cmFjayBvZiBvcmRlclxuICAgICAgICAvLyB3aGljaCBzZXJpZXMgY2FudmFzZXMgYXJlIGRpc3BsYXllZCwgbG93ZXN0XG4gICAgICAgIC8vIHRvIGhpZ2hlc3QsIGJhY2sgdG8gZnJvbnQuXG4gICAgICAgIHRoaXMuc2VyaWVzU3RhY2sgPSBbXTtcbiAgICAgICAgLy8gcHJvcDogc2VyaWVzQ29sb3JzXG4gICAgICAgIC8vIEFubiBhcnJheSBvZiBDU1MgY29sb3Igc3BlY2lmaWNhdGlvbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQsIGluIG9yZGVyLFxuICAgICAgICAvLyB0byB0aGUgc2VyaWVzIGluIHRoZSBwbG90LiAgQ29sb3JzIHdpbGwgd3JhcCBhcm91bmQgc28sIGlmIHRoZWlyXG4gICAgICAgIC8vIGFyZSBtb3JlIHNlcmllcyB0aGFuIGNvbG9ycywgY29sb3JzIHdpbGwgYmUgcmV1c2VkIHN0YXJ0aW5nIGF0IHRoZVxuICAgICAgICAvLyBiZWdpbm5pbmcuICBGb3IgcGllIGNoYXJ0cywgdGhpcyBzcGVjaWZpZXMgdGhlIGNvbG9ycyBvZiB0aGUgc2xpY2VzLlxuICAgICAgICB0aGlzLnNlcmllc0NvbG9ycyA9ICQuanFwbG90LmNvbmZpZy5kZWZhdWx0Q29sb3JzO1xuICAgICAgICAvLyBwcm9wOiBzb3J0RGF0YVxuICAgICAgICAvLyBmYWxzZSB0byBub3Qgc29ydCB0aGUgZGF0YSBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuXG4gICAgICAgIC8vIE1hbnkgYmFyLCBzdGFja2VkIGFuZCBvdGhlciBncmFwaHMgYXMgd2VsbCBhcyBtYW55IHBsdWdpbnMgZGVwZW5kIG9uXG4gICAgICAgIC8vIGhhdmluZyBzb3J0ZWQgZGF0YS5cbiAgICAgICAgdGhpcy5zb3J0RGF0YSA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHN0YWNrU2VyaWVzXG4gICAgICAgIC8vIHRydWUgb3IgZmFsc2UsIGNyZWF0ZXMgYSBzdGFjayBvciBcIm1vdW50YWluXCIgcGxvdC5cbiAgICAgICAgLy8gTm90IGFsbCBzZXJpZXMgcmVuZGVyZXJzIG1heSBpbXBsZW1lbnQgdGhpcyBvcHRpb24uXG4gICAgICAgIHRoaXMuc3RhY2tTZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gYSBzaG9ydGN1dCBmb3IgYXhpcyBzeW5jVGlja3Mgb3B0aW9ucy4gIE5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICAgIHRoaXMuc3luY1hUaWNrcyA9IHRydWU7XG4gICAgICAgIC8vIGEgc2hvcnRjdXQgZm9yIGF4aXMgc3luY1RpY2tzIG9wdGlvbnMuICBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAgICB0aGlzLnN5bmNZVGlja3MgPSB0cnVlO1xuICAgICAgICAvLyB0aGUganF1ZXJ5IG9iamVjdCBmb3IgdGhlIGRvbSB0YXJnZXQuXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDsgXG4gICAgICAgIC8vIFRoZSBpZCBvZiB0aGUgZG9tIGVsZW1lbnQgdG8gcmVuZGVyIHRoZSBwbG90IGludG9cbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IG51bGw7XG4gICAgICAgIC8vIHByb3AgdGV4dENvbG9yXG4gICAgICAgIC8vIGNzcyBzcGVjIGZvciB0aGUgY3NzIGNvbG9yIGF0dHJpYnV0ZS4gIERlZmF1bHQgZm9yIHRoZSBlbnRpcmUgcGxvdC5cbiAgICAgICAgdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIC8vIHByb3A6IHRpdGxlXG4gICAgICAgIC8vIFRpdGxlIG9iamVjdC4gIFNlZSA8VGl0bGU+IGZvciBzcGVjaWZpYyBvcHRpb25zLiAgQXMgYSBzaG9ydGN1dCwgeW91XG4gICAgICAgIC8vIGNhbiBzcGVjaWZ5IHRoZSB0aXRsZSBvcHRpb24gYXMganVzdCBhIHN0cmluZyBsaWtlOiB0aXRsZTogJ015IFBsb3QnXG4gICAgICAgIC8vIGFuZCB0aGlzIHdpbGwgY3JlYXRlIGEgbmV3IHRpdGxlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy50aXRsZSA9IG5ldyBUaXRsZSgpO1xuICAgICAgICAvLyBDb3VudCBob3cgbWFueSB0aW1lcyB0aGUgZHJhdyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIHdoaWxlIHRoZSBwbG90IGlzIHZpc2libGUuXG4gICAgICAgIC8vIE1vc3RseSB1c2VkIHRvIHRlc3QgaWYgcGxvdCBoYXMgbmV2ZXIgYmVlbiBkcmFuICg9MCksIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBkcmF3blxuICAgICAgICAvLyBpbnRvIGEgdmlzaWJsZSBjb250YWluZXIgb25jZSAoPTEpIG9yIGRyYXcgbW9yZSB0aGFuIG9uY2UgaW50byBhIHZpc2libGUgY29udGFpbmVyLlxuICAgICAgICAvLyBDYW4gdXNlIHRoaXMgaW4gdGVzdHMgdG8gc2VlIGlmIHBsb3QgaGFzIGJlZW4gdmlzaWJseSBkcmF3biBhdCBsZWFzdCBvbmUgdGltZS5cbiAgICAgICAgLy8gQWZ0ZXIgcGxvdCBoYXMgYmVlbiB2aXNpYmx5IGRyYXduIG9uY2UsIGl0IGdlbmVyYWxseSBkb2Vzbid0IG5lZWQgcmVkcmF3aW5nIGlmIGl0c1xuICAgICAgICAvLyBjb250YWluZXIgaXMgaGlkZGVuIGFuZCBzaG93bi5cbiAgICAgICAgdGhpcy5fZHJhd0NvdW50ID0gMDtcbiAgICAgICAgLy8gc3VtIG9mIHkgdmFsdWVzIGZvciBhbGwgc2VyaWVzIGluIHBsb3QuXG4gICAgICAgIC8vIHVzZWQgaW4gbWVra28gY2hhcnQuXG4gICAgICAgIHRoaXMuX3N1bXkgPSAwO1xuICAgICAgICB0aGlzLl9zdW14ID0gMDtcbiAgICAgICAgLy8gYXJyYXkgdG8gaG9sZCB0aGUgY3VtdWxhdGl2ZSBzdGFja2VkIHNlcmllcyBkYXRhLlxuICAgICAgICAvLyB1c2VkIHRvIGFqdXN0IHRoZSBpbmRpdmlkdWFsIHNlcmllcyBkYXRhLCB3aGljaCB3b24ndCBoYXZlIGFjY2VzcyB0byBvdGhlclxuICAgICAgICAvLyBzZXJpZXMgZGF0YS5cbiAgICAgICAgdGhpcy5fc3RhY2tEYXRhID0gW107XG4gICAgICAgIC8vIGFycmF5IHRoYXQgaG9sZHMgdGhlIGRhdGEgdG8gYmUgcGxvdHRlZC4gVGhpcyB3aWxsIGJlIHRoZSBzZXJpZXMgZGF0YVxuICAgICAgICAvLyBtZXJnZWQgd2l0aCB0aGUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgZnJvbSBfc3RhY2tEYXRhIGFjY29yZGluZyB0byB0aGUgc3RhY2tBeGlzLlxuICAgICAgICB0aGlzLl9wbG90RGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl93aWR0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IG51bGw7IFxuICAgICAgICB0aGlzLl9wbG90RGltZW5zaW9ucyA9IHtoZWlnaHQ6bnVsbCwgd2lkdGg6bnVsbH07XG4gICAgICAgIHRoaXMuX2dyaWRQYWRkaW5nID0ge3RvcDpudWxsLCByaWdodDpudWxsLCBib3R0b206bnVsbCwgbGVmdDpudWxsfTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEdyaWRQYWRkaW5nID0ge3RvcDoxMCwgcmlnaHQ6MTAsIGJvdHRvbToyMywgbGVmdDoxMH07XG5cbiAgICAgICAgdGhpcy5fYWRkRG9tUmVmZXJlbmNlID0gJC5qcXBsb3QuY29uZmlnLmFkZERvbVJlZmVyZW5jZTtcblxuICAgICAgICB0aGlzLnByZUluaXRIb29rcyA9IG5ldyAkLmpxcGxvdC5Ib29rc01hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5wb3N0SW5pdEhvb2tzID0gbmV3ICQuanFwbG90Lkhvb2tzTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnByZVBhcnNlT3B0aW9uc0hvb2tzID0gbmV3ICQuanFwbG90Lkhvb2tzTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnBvc3RQYXJzZU9wdGlvbnNIb29rcyA9IG5ldyAkLmpxcGxvdC5Ib29rc01hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5wcmVEcmF3SG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucG9zdERyYXdIb29rcyA9IG5ldyAkLmpxcGxvdC5Ib29rc01hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5wcmVEcmF3U2VyaWVzSG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucG9zdERyYXdTZXJpZXNIb29rcyA9IG5ldyAkLmpxcGxvdC5Ib29rc01hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5wcmVEcmF3TGVnZW5kSG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuYWRkTGVnZW5kUm93SG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucHJlU2VyaWVzSW5pdEhvb2tzID0gbmV3ICQuanFwbG90Lkhvb2tzTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnBvc3RTZXJpZXNJbml0SG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucHJlUGFyc2VTZXJpZXNPcHRpb25zSG9va3MgPSBuZXcgJC5qcXBsb3QuSG9va3NNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucG9zdFBhcnNlU2VyaWVzT3B0aW9uc0hvb2tzID0gbmV3ICQuanFwbG90Lkhvb2tzTWFuYWdlcigpO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJIb29rcyA9IG5ldyAkLmpxcGxvdC5FdmVudExpc3RlbmVyTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnByZURyYXdTZXJpZXNTaGFkb3dIb29rcyA9IG5ldyAkLmpxcGxvdC5Ib29rc01hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5wb3N0RHJhd1Nlcmllc1NoYWRvd0hvb2tzID0gbmV3ICQuanFwbG90Lkhvb2tzTWFuYWdlcigpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jb2xvckdlbmVyYXRvciA9IG5ldyAkLmpxcGxvdC5Db2xvckdlbmVyYXRvcigpO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlQ29sb3JHZW5lcmF0b3IgPSBuZXcgJC5qcXBsb3QuQ29sb3JHZW5lcmF0b3IoKTtcblxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSBuZXcgJC5qcXBsb3QuQ2FudmFzTWFuYWdlcigpO1xuXG4gICAgICAgIHRoaXMudGhlbWVFbmdpbmUgPSBuZXcgJC5qcXBsb3QuVGhlbWVFbmdpbmUoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZXJpZXNDb2xvcnNJbmRleCA9IDA7XG5cbiAgICAgICAgLy8gR3JvdXA6IG1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gbWV0aG9kOiBpbml0XG4gICAgICAgIC8vIHNldHMgdGhlIHBsb3QgdGFyZ2V0LCBjaGVja3MgZGF0YSBhbmQgYXBwbGllcyB1c2VyXG4gICAgICAgIC8vIG9wdGlvbnMgdG8gcGxvdC5cbiAgICAgICAgdGhpcy5pbml0ID0gZnVuY3Rpb24odGFyZ2V0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTwkLmpxcGxvdC5wcmVJbml0SG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkLmpxcGxvdC5wcmVJbml0SG9va3NbaV0uY2FsbCh0aGlzLCB0YXJnZXQsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5wcmVJbml0SG9va3MuaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZUluaXRIb29rcy5ob29rc1tpXS5jYWxsKHRoaXMsIHRhcmdldCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0SWQgPSAnIycrdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSAkKCcjJyt0YXJnZXQpO1xuXG4gICAgICAgICAgICAvLy8vLy9cbiAgICAgICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSB0byBwbG90XG4gICAgICAgICAgICAvLy8vLy9cbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGREb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kYXRhKCdqcXBsb3QnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXJyb3IgY2xhc3MgdGhhdCBtYXkgYmUgc3R1Y2sgb24gdGFyZ2V0LlxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQ2xhc3MoJ2pxcGxvdC1lcnJvcicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldC5nZXQoMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwbG90IHRhcmdldCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IGlzIHBvc2l0aW9uZWQgYnkgc29tZSBtZWFucyBhbmQgc2V0IGNzc1xuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQuaGFzQ2xhc3MoJ2pxcGxvdC10YXJnZXQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZENsYXNzKCdqcXBsb3QtdGFyZ2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGlmIG5vIGhlaWdodCBvciB3aWR0aCBzcGVjaWZpZWQsIHVzZSBhIGRlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0LmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGg7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHBhcnNlSW50KG9wdGlvbnMuaGVpZ2h0LCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0LmF0dHIoJ2RhdGEtaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHBhcnNlSW50KHRoaXMudGFyZ2V0LmF0dHIoJ2RhdGEtaGVpZ2h0JyksIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSBwYXJzZUludCgkLmpxcGxvdC5jb25maWcuZGVmYXVsdEhlaWdodCwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygnaGVpZ2h0JywgaCsncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGggPSB0aGlzLnRhcmdldC5oZWlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQud2lkdGgoKSkge1xuICAgICAgICAgICAgICAgIHZhciB3O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHBhcnNlSW50KG9wdGlvbnMud2lkdGgsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXQuYXR0cignZGF0YS13aWR0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBwYXJzZUludCh0aGlzLnRhcmdldC5hdHRyKCdkYXRhLXdpZHRoJyksIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBwYXJzZUludCgkLmpxcGxvdC5jb25maWcuZGVmYXVsdFdpZHRoLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdztcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5jc3MoJ3dpZHRoJywgdysncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdyA9IHRoaXMudGFyZ2V0LndpZHRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbD1fYXhpc05hbWVzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbX2F4aXNOYW1lc1tpXV0gPSBuZXcgQXhpcyhfYXhpc05hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fcGxvdERpbWVuc2lvbnMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMudGl0bGUuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmJhc2VDYW52YXMuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmQuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVpZ2h0IDw9MCB8fCB0aGlzLl93aWR0aCA8PTAgfHwgIXRoaXMuX2hlaWdodCB8fCAhdGhpcy5fd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgZGltZW5zaW9uIG5vdCBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGFSZW5kZXJlciAmJiAkLmlzRnVuY3Rpb24ob3B0aW9ucy5kYXRhUmVuZGVyZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YVJlbmRlcmVyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFSZW5kZXJlck9wdGlvbnMgPSBvcHRpb25zLmRhdGFSZW5kZXJlck9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVJlbmRlcmVyID0gb3B0aW9ucy5kYXRhUmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YVJlbmRlcmVyKGRhdGEsIHRoaXMsIHRoaXMuZGF0YVJlbmRlcmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vRGF0YUluZGljYXRvciAmJiAkLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5ub0RhdGFJbmRpY2F0b3IpKSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcy5ub0RhdGFJbmRpY2F0b3IsIG9wdGlvbnMubm9EYXRhSW5kaWNhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCAkLmlzQXJyYXkoZGF0YSkgPT0gZmFsc2UgfHwgZGF0YS5sZW5ndGggPT0gMCB8fCAkLmlzQXJyYXkoZGF0YVswXSkgPT0gZmFsc2UgfHwgZGF0YVswXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRGF0YUluZGljYXRvci5zaG93ID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGEgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBiZSBkZXNjcnVjdGl2ZSBoZXJlIGluIG9yZGVyIGZvciBwbG90IHRvIG5vdCB0cnkgYW5kIHJlbmRlciBzZXJpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCAkLmpxcGxvdCgpIHdpbGwgaGF2ZSB0byBiZSBjYWxsZWQgYWdhaW4gd2hlbiB0aGVyZSBpcyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAvL2RlbGV0ZSBvcHRpb25zLnNlcmllcztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGF4IGluIHRoaXMubm9EYXRhSW5kaWNhdG9yLmF4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5ub0RhdGFJbmRpY2F0b3IuYXhlc1theF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbYXhdW3Byb3BdID0gdGhpcy5ub0RhdGFJbmRpY2F0b3IuYXhlc1theF1bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdERyYXdIb29rcy5hZGQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWggPSB0aGlzLmV2ZW50Q2FudmFzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV3ID0gdGhpcy5ldmVudENhbnZhcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSAkKCc8ZGl2IGNsYXNzPVwianFwbG90LW5vRGF0YS1jb250YWluZXJcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO1wiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKHRlbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5oZWlnaHQoZWgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC53aWR0aChldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmNzcygndG9wJywgdGhpcy5ldmVudENhbnZhcy5fb2Zmc2V0cy50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jc3MoJ2xlZnQnLCB0aGlzLmV2ZW50Q2FudmFzLl9vZmZzZXRzLmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcDIgPSAkKCc8ZGl2IGNsYXNzPVwianFwbG90LW5vRGF0YS1jb250ZW50c1wiIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7IHBvc2l0aW9uOnJlbGF0aXZlOyBtYXJnaW4tbGVmdDphdXRvOyBtYXJnaW4tcmlnaHQ6YXV0bztcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuYXBwZW5kKHRlbXAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAyLmh0bWwodGhpcy5ub0RhdGFJbmRpY2F0b3IuaW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aCA9IHRlbXAyLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR3ID0gdGVtcDIud2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAyLmhlaWdodCh0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wMi53aWR0aCh0dyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wMi5jc3MoJ3RvcCcsIChlaCAtIHRoKS8yICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gJC5leHRlbmQodHJ1ZSwgW10sIGRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuY3NzKCdjb2xvcicsIHRoaXMudGV4dENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5jc3MoJ2ZvbnQtZmFtaWx5JywgdGhpcy5mb250RmFtaWx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuY3NzKCdmb250LXNpemUnLCB0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50aXRsZS5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9zdW15ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3N1bXggPSAwO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlUGxvdERhdGEoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YWNraW5nIG9yZGVyIGZvciBzZXJpZXMgY2FudmFzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc1N0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Nlcmllc1N0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaV0uc2hhZG93Q2FudmFzLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmNhbnZhcy5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8JC5qcXBsb3QucHJlU2VyaWVzSW5pdEhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICQuanFwbG90LnByZVNlcmllc0luaXRIb29rc1tqXS5jYWxsKHRoaXMuc2VyaWVzW2ldLCB0YXJnZXQsIHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHRoaXMucHJlU2VyaWVzSW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlU2VyaWVzSW5pdEhvb2tzLmhvb2tzW2pdLmNhbGwodGhpcy5zZXJpZXNbaV0sIHRhcmdldCwgdGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMuc2VyaWVzRGVmYXVsdHMsIHRoaXMub3B0aW9ucy5zZXJpZXNbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcHVsYXRlUGxvdERhdGEodGhpcy5zZXJpZXNbaV0sIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmluaXQoaSwgdGhpcy5ncmlkLmJvcmRlcldpZHRoLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8JC5qcXBsb3QucG9zdFNlcmllc0luaXRIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAkLmpxcGxvdC5wb3N0U2VyaWVzSW5pdEhvb2tzW2pdLmNhbGwodGhpcy5zZXJpZXNbaV0sIHRhcmdldCwgdGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMuc2VyaWVzRGVmYXVsdHMsIHRoaXMub3B0aW9ucy5zZXJpZXNbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8dGhpcy5wb3N0U2VyaWVzSW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdFNlcmllc0luaXRIb29rcy5ob29rc1tqXS5jYWxsKHRoaXMuc2VyaWVzW2ldLCB0YXJnZXQsIHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VteSArPSB0aGlzLnNlcmllc1tpXS5fc3VteTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW14ICs9IHRoaXMuc2VyaWVzW2ldLl9zdW14O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZSxcbiAgICAgICAgICAgICAgICBheGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsPV9heGlzTmFtZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBfYXhpc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGF4aXMgPSB0aGlzLmF4ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgYXhpcy5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICBheGlzLmluaXQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5heGVzW25hbWVdLmJvcmRlckNvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAneCcgJiYgYXhpcy51c2VTZXJpZXNDb2xvciA9PT0gdHJ1ZSAmJiBheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuYm9yZGVyQ29sb3IgPSBheGlzLl9zZXJpZXNbMF0uY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLmJvcmRlckNvbG9yID0gdGhpcy5ncmlkLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0RGF0YSkge1xuICAgICAgICAgICAgICAgIHNvcnREYXRhKHRoaXMuc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmdyaWQuX2F4ZXMgPSB0aGlzLmF4ZXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubGVnZW5kLl9zZXJpZXMgPSB0aGlzLnNlcmllcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPCQuanFwbG90LnBvc3RJbml0SG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkLmpxcGxvdC5wb3N0SW5pdEhvb2tzW2ldLmNhbGwodGhpcywgdGFyZ2V0LCB0aGlzLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5wb3N0SW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0SW5pdEhvb2tzLmhvb2tzW2ldLmNhbGwodGhpcywgdGFyZ2V0LCB0aGlzLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyAgXG4gICAgICAgIFxuICAgICAgICAvLyBtZXRob2Q6IHJlc2V0QXhlc1NjYWxlXG4gICAgICAgIC8vIFJlc2V0IHRoZSBzcGVjaWZpZWQgYXhlcyBtaW4sIG1heCwgbnVtYmVyVGlja3MgYW5kIHRpY2tJbnRlcnZhbCBwcm9wZXJ0aWVzIHRvIG51bGxcbiAgICAgICAgLy8gb3IgcmVzZXQgdGhlc2UgcHJvcGVydGllcyBvbiBhbGwgYXhlcyBpZiBubyBsaXN0IG9mIGF4ZXMgaXMgcHJvdmlkZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcmFtZXRlcnM6XG4gICAgICAgIC8vIGF4ZXMgLSBCb29sZWFuIHRvIHJlc2V0IG9yIG5vdCByZXNldCBhbGwgYXhlcyBvciBhbiBhcnJheSBvciBvYmplY3Qgb2YgYXhpcyBuYW1lcyB0byByZXNldC5cbiAgICAgICAgdGhpcy5yZXNldEF4ZXNTY2FsZSA9IGZ1bmN0aW9uKGF4ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBheCA9IGF4ZXMgfHwgdGhpcy5heGVzO1xuICAgICAgICAgICAgaWYgKGF4ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYXggPSB0aGlzLmF4ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KGF4KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5heGVzW2F4W2ldXS5yZXNldFNjYWxlKG9wdHNbYXhbaV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoYXgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5heGVzW25hbWVdLnJlc2V0U2NhbGUob3B0c1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBtZXRob2Q6IHJlSW5pdGlhbGl6ZVxuICAgICAgICAvLyByZWluaXRpYWxpemUgcGxvdCBmb3IgcmVwbG90dGluZy5cbiAgICAgICAgLy8gbm90IGNhbGxlZCBkaXJlY3RseS5cbiAgICAgICAgdGhpcy5yZUluaXRpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0cykge1xuICAgICAgICAgICAgLy8gUGxvdCBzaG91bGQgYmUgdmlzaWJsZSBhbmQgaGF2ZSBhIGhlaWdodCBhbmQgd2lkdGguXG4gICAgICAgICAgICAvLyBJZiBwbG90IGRvZXNuJ3QgaGF2ZSBoZWlnaHQgYW5kIHdpZHRoIGZvciBzb21lXG4gICAgICAgICAgICAvLyByZWFzb24sIHNldCBpdCBieSBvdGhlciBtZWFucy4gIFBsb3QgbXVzdCBub3QgaGF2ZVxuICAgICAgICAgICAgLy8gYSBkaXNwbGF5Om5vbmUgYXR0cmlidXRlLCBob3dldmVyLlxuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLm9wdGlvbnMsIG9wdHMpO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRJZC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB2YXIgdGRhdGEgPSAoZGF0YSA9PSBudWxsKSA/IHRoaXMuZGF0YSA6IGRhdGE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTwkLmpxcGxvdC5wcmVJbml0SG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkLmpxcGxvdC5wcmVJbml0SG9va3NbaV0uY2FsbCh0aGlzLCB0YXJnZXQsIHRkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucHJlSW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVJbml0SG9va3MuaG9va3NbaV0uY2FsbCh0aGlzLCB0YXJnZXQsIHRkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy50YXJnZXQuaGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMudGFyZ2V0LndpZHRoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWlnaHQgPD0wIHx8IHRoaXMuX3dpZHRoIDw9MCB8fCAhdGhpcy5faGVpZ2h0IHx8ICF0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBkaW1lbnNpb24gbm90IHNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fcGxvdERpbWVuc2lvbnMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMudGl0bGUuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmJhc2VDYW52YXMuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmQuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG5cbiAgICAgICAgICAgIHZhciBuYW1lLFxuICAgICAgICAgICAgICAgIHQsIFxuICAgICAgICAgICAgICAgIGosIFxuICAgICAgICAgICAgICAgIGF4aXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbD1fYXhpc05hbWVzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gX2F4aXNOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBheGlzID0gdGhpcy5heGVzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgLy8gTWVtb3J5IExlYWtzIHBhdGNoIDogY2xlYXIgdGlja3MgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB0ID0gYXhpcy5fdGlja3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIHRsZW4gPSB0Lmxlbmd0aDsgaiA8IHRsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdFtqXS5fZWxlbTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjYW52YXMgcmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuanFwbG90LnVzZV9leGNhbnZhcyAmJiB3aW5kb3cuR192bWxDYW52YXNNYW5hZ2VyLnVuaW5pdEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5HX3ZtbENhbnZhc01hbmFnZXIudW5pbml0RWxlbWVudChlbC5nZXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsLmVtcHR5Rm9yY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0Ll9lbGVtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgYXhpcy50aWNrcztcbiAgICAgICAgICAgICAgICBkZWxldGUgYXhpcy5fdGlja3M7XG4gICAgICAgICAgICAgICAgdGhpcy5heGVzW25hbWVdID0gbmV3IEF4aXMobmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5heGVzW25hbWVdLl9wbG90V2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbbmFtZV0uX3Bsb3RIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YVJlbmRlcmVyICYmICQuaXNGdW5jdGlvbihvcHRpb25zLmRhdGFSZW5kZXJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YVJlbmRlcmVyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhUmVuZGVyZXJPcHRpb25zID0gb3B0aW9ucy5kYXRhUmVuZGVyZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVJlbmRlcmVyID0gb3B0aW9ucy5kYXRhUmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGFSZW5kZXJlcihkYXRhLCB0aGlzLCB0aGlzLmRhdGFSZW5kZXJlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9ICQuZXh0ZW5kKHRydWUsIFtdLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50aXRsZS5fcGxvdFdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygnY29sb3InLCB0aGlzLnRleHRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuY3NzKCdmb250LWZhbWlseScsIHRoaXMuZm9udEZhbWlseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb250U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGl0bGUuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5fc3VteSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zdW14ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5zZXJpZXNTdGFjayA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Nlcmllc1N0YWNrID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVBsb3REYXRhKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9dGhpcy5zZXJpZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YWNraW5nIG9yZGVyIGZvciBzZXJpZXMgY2FudmFzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc1N0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Nlcmllc1N0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaV0uc2hhZG93Q2FudmFzLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmNhbnZhcy5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8JC5qcXBsb3QucHJlU2VyaWVzSW5pdEhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICQuanFwbG90LnByZVNlcmllc0luaXRIb29rc1tqXS5jYWxsKHRoaXMuc2VyaWVzW2ldLCB0YXJnZXQsIHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHRoaXMucHJlU2VyaWVzSW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlU2VyaWVzSW5pdEhvb2tzLmhvb2tzW2pdLmNhbGwodGhpcy5zZXJpZXNbaV0sIHRhcmdldCwgdGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMuc2VyaWVzRGVmYXVsdHMsIHRoaXMub3B0aW9ucy5zZXJpZXNbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcHVsYXRlUGxvdERhdGEodGhpcy5zZXJpZXNbaV0sIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmluaXQoaSwgdGhpcy5ncmlkLmJvcmRlcldpZHRoLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8JC5qcXBsb3QucG9zdFNlcmllc0luaXRIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAkLmpxcGxvdC5wb3N0U2VyaWVzSW5pdEhvb2tzW2pdLmNhbGwodGhpcy5zZXJpZXNbaV0sIHRhcmdldCwgdGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMuc2VyaWVzRGVmYXVsdHMsIHRoaXMub3B0aW9ucy5zZXJpZXNbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8dGhpcy5wb3N0U2VyaWVzSW5pdEhvb2tzLmhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdFNlcmllc0luaXRIb29rcy5ob29rc1tqXS5jYWxsKHRoaXMuc2VyaWVzW2ldLCB0YXJnZXQsIHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VteSArPSB0aGlzLnNlcmllc1tpXS5fc3VteTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW14ICs9IHRoaXMuc2VyaWVzW2ldLl9zdW14O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9X2F4aXNOYW1lcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IF9heGlzTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgYXhpcyA9IHRoaXMuYXhlc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgIGF4aXMuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgYXhpcy5pbml0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuYm9yZGVyQ29sb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICd4JyAmJiBheGlzLnVzZVNlcmllc0NvbG9yID09PSB0cnVlICYmIGF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5ib3JkZXJDb2xvciA9IGF4aXMuX3Nlcmllc1swXS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuYm9yZGVyQ29sb3IgPSB0aGlzLmdyaWQuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgc29ydERhdGEodGhpcy5zZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5fYXhlcyA9IHRoaXMuYXhlcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuX3NlcmllcyA9IHRoaXMuc2VyaWVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9JC5qcXBsb3QucG9zdEluaXRIb29rcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJC5qcXBsb3QucG9zdEluaXRIb29rc1tpXS5jYWxsKHRoaXMsIHRhcmdldCwgdGhpcy5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsPXRoaXMucG9zdEluaXRIb29rcy5ob29rcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0SW5pdEhvb2tzLmhvb2tzW2ldLmNhbGwodGhpcywgdGFyZ2V0LCB0aGlzLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cblxuICAgICAgICAvLyBtZXRob2Q6IHF1aWNrSW5pdFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUXVpY2sgcmVpbml0aWFsaXphdGlvbiBwbG90IGZvciByZXBsb3R0aW5nLlxuICAgICAgICAvLyBEb2VzIG5vdCBwYXJzZSBvcHRpb25zIG9yZSByZWNyZWF0ZSBheGVzIGFuZCBzZXJpZXMuXG4gICAgICAgIC8vIG5vdCBjYWxsZWQgZGlyZWN0bHkuXG4gICAgICAgIHRoaXMucXVpY2tJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUGxvdCBzaG91bGQgYmUgdmlzaWJsZSBhbmQgaGF2ZSBhIGhlaWdodCBhbmQgd2lkdGguXG4gICAgICAgICAgICAvLyBJZiBwbG90IGRvZXNuJ3QgaGF2ZSBoZWlnaHQgYW5kIHdpZHRoIGZvciBzb21lXG4gICAgICAgICAgICAvLyByZWFzb24sIHNldCBpdCBieSBvdGhlciBtZWFucy4gIFBsb3QgbXVzdCBub3QgaGF2ZVxuICAgICAgICAgICAgLy8gYSBkaXNwbGF5Om5vbmUgYXR0cmlidXRlLCBob3dldmVyLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLnRhcmdldC5oZWlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy50YXJnZXQud2lkdGgoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlaWdodCA8PTAgfHwgdGhpcy5fd2lkdGggPD0wIHx8ICF0aGlzLl9oZWlnaHQgfHwgIXRoaXMuX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGRpbWVuc2lvbiBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5ncmlkLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgdGhpcy50aXRsZS5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMuYmFzZUNhbnZhcy5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5fcGxvdERpbWVuc2lvbnMgPSB0aGlzLl9wbG90RGltZW5zaW9ucztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmF4ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbbl0uX3Bsb3RXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuYXhlc1tuXS5fcGxvdEhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50aXRsZS5fcGxvdFdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygnY29sb3InLCB0aGlzLnRleHRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuY3NzKCdmb250LWZhbWlseScsIHRoaXMuZm9udEZhbWlseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb250U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNzcygnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX3N1bXkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc3VteCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVQbG90RGF0YSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5wb3B1bGF0ZVBsb3REYXRhKHRoaXMuc2VyaWVzW2ldLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXJpZXNbaV0uX3R5cGUgPT09ICdsaW5lJyAmJiB0aGlzLnNlcmllc1tpXS5yZW5kZXJlci5iYW5kcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLnJlbmRlcmVyLmluaXRCYW5kcy5jYWxsKHRoaXMuc2VyaWVzW2ldLCB0aGlzLnNlcmllc1tpXS5yZW5kZXJlci5vcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaV0uX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaV0uY2FudmFzLl9wbG90RGltZW5zaW9ucyA9IHRoaXMuX3Bsb3REaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5zZXJpZXNbaV0uaW5pdChpLCB0aGlzLmdyaWQuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1bXkgKz0gdGhpcy5zZXJpZXNbaV0uX3N1bXk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VteCArPSB0aGlzLnNlcmllc1tpXS5fc3VteDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajwxMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IF9heGlzTmFtZXNbal07XG4gICAgICAgICAgICAgICAgLy8gTWVtb3J5IExlYWtzIHBhdGNoIDogY2xlYXIgdGlja3MgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuYXhlc1tuYW1lXS5fdGlja3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0W2ldLl9lbGVtO1xuICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNhbnZhcyByZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5qcXBsb3QudXNlX2V4Y2FudmFzICYmIHdpbmRvdy5HX3ZtbENhbnZhc01hbmFnZXIudW5pbml0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2luZG93Lkdfdm1sQ2FudmFzTWFuYWdlci51bmluaXRFbGVtZW50KGVsLmdldCgwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwuZW1wdHlGb3JjZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHQuX2VsZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbbmFtZV0uX3Bsb3REaW1lbnNpb25zID0gdGhpcy5fcGxvdERpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgdGhpcy5heGVzW25hbWVdLl90aWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuYXhlc1tuYW1lXS5yZW5kZXJlci5pbml0LmNhbGwodGhpcy5heGVzW25hbWVdLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgc29ydERhdGEodGhpcy5zZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdyaWQuX2F4ZXMgPSB0aGlzLmF4ZXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubGVnZW5kLl9zZXJpZXMgPSB0aGlzLnNlcmllcztcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIHNvcnQgdGhlIHNlcmllcyBkYXRhIGluIGluY3JlYXNpbmcgb3JkZXIuXG4gICAgICAgIGZ1bmN0aW9uIHNvcnREYXRhKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIGQsIHNkLCBwZCwgcHBkLCByZXQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrO1xuICAgICAgICAgICAgICAgIHZhciBiYXQgPSBbc2VyaWVzW2ldLmRhdGEsIHNlcmllc1tpXS5fc3RhY2tEYXRhLCBzZXJpZXNbaV0uX3Bsb3REYXRhLCBzZXJpZXNbaV0uX3ByZXZQbG90RGF0YV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbj0wOyBuPDQ7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBjaGVjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBiYXRbbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXNbaV0uX3N0YWNrQXhpcyA9PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZFtqXVsxXSkgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGRbal1bMF0pICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcGxvdERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrRGF0YSA9IFtdO1xuICAgICAgICAgICAgdmFyIHNlcmllcyxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBsO1xuXG5cbiAgICAgICAgICAgIGZvciAoaW5kZXg9MCwgbD10aGlzLnNlcmllcy5sZW5ndGg7IGluZGV4PGw7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMgPSB0aGlzLnNlcmllc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxvdERhdGEucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tEYXRhLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIHZhciBjZCA9IHNlcmllcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bsb3REYXRhW2luZGV4XSA9ICQuZXh0ZW5kKHRydWUsIFtdLCBjZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tEYXRhW2luZGV4XSA9ICQuZXh0ZW5kKHRydWUsIFtdLCBjZCk7XG4gICAgICAgICAgICAgICAgc2VyaWVzLl9wbG90RGF0YSA9IHRoaXMuX3Bsb3REYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuX3N0YWNrRGF0YSA9IHRoaXMuX3N0YWNrRGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHBsb3RWYWx1ZXMgPSB7eDpbXSwgeTpbXX07XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFja1NlcmllcyAmJiAhc2VyaWVzLmRpc2FibGVTdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuX3N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gY2hlY2sgZm9yIG51bGxzXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkeCA9IChzZXJpZXMuX3N0YWNrQXhpcyA9PT0gJ3gnKSA/IDAgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGs9MCwgY2RsPWNkLmxlbmd0aDsgazxjZGw7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBjZFtrXVtzaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bsb3REYXRhW2luZGV4XVtrXVtzaWR4XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFja0RhdGFbaW5kZXhdW2tdW3NpZHhdID0gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9aW5kZXg7IGotLTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZ2YWwgPSB0aGlzLl9wbG90RGF0YVtqXVtrXVtzaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIHN1bSB1cCB0aGUgc3RhY2sgYXhpcyBjb2x1bW4gb2YgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgb25seSBzdW0gaWYgaXQgaXMgb2Ygc2FtZSBzaWduLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBwcmV2aW91cyBzZXJpZXMgaXNuJ3Qgc2FtZSBzaWduLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgZWFybGllciBzZXJpZXMgdW50aWxsIHdlIGZpbmQgb25lIG9mIHNhbWUgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAgKiBwcmV2dmFsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bsb3REYXRhW2luZGV4XVtrXVtzaWR4XSArPSBwcmV2dmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tEYXRhW2luZGV4XVtrXVtzaWR4XSArPSBwcmV2dmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZXJpZXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdFZhbHVlcy54LnB1c2goc2VyaWVzLmRhdGFbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdFZhbHVlcy55LnB1c2goc2VyaWVzLmRhdGFbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrRGF0YS5wdXNoKHNlcmllcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaW5kZXhdLl9zdGFja0RhdGEgPSBzZXJpZXMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxvdERhdGEucHVzaChzZXJpZXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5fcGxvdERhdGEgPSBzZXJpZXMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLl9wbG90VmFsdWVzID0gcGxvdFZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4PjApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLl9wcmV2UGxvdERhdGEgPSB0aGlzLnNlcmllc1tpbmRleC0xXS5fcGxvdERhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcmllcy5fc3VteSA9IDA7XG4gICAgICAgICAgICAgICAgc2VyaWVzLl9zdW14ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGk9c2VyaWVzLmRhdGEubGVuZ3RoLTE7IGk+LTE7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuX3N1bXkgKz0gc2VyaWVzLmRhdGFbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5fc3VteCArPSBzZXJpZXMuZGF0YVtpXVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIHBvcHVsYXRlIHRoZSBfc3RhY2tEYXRhIGFuZCBfcGxvdERhdGEgYXJyYXlzIGZvciB0aGUgcGxvdCBhbmQgdGhlIHNlcmllcy5cbiAgICAgICAgdGhpcy5wb3B1bGF0ZVBsb3REYXRhID0gZnVuY3Rpb24oc2VyaWVzLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gaWYgYSBzdGFja2VkIGNoYXJ0LCBjb21wdXRlIHRoZSBzdGFja2VkIGRhdGFcbiAgICAgICAgICAgIHRoaXMuX3Bsb3REYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFja0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHNlcmllcy5fc3RhY2tEYXRhID0gW107XG4gICAgICAgICAgICBzZXJpZXMuX3Bsb3REYXRhID0gW107XG4gICAgICAgICAgICB2YXIgcGxvdFZhbHVlcyA9IHt4OltdLCB5OltdfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrU2VyaWVzICYmICFzZXJpZXMuZGlzYWJsZVN0YWNrKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLl9zdGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHNpZHggPSAoc2VyaWVzLl9zdGFja0F4aXMgPT09ICd4JykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgaWR4ID0gc2lkeCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIGN1cnJlbnQgZGF0YSBpbnRvIHN0YWNrRGF0YVxuICAgICAgICAgICAgICAgIC8vdGhpcy5fc3RhY2tEYXRhLnB1c2godGhpcy5zZXJpZXNbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSAkLmV4dGVuZCh0cnVlLCBbXSwgc2VyaWVzLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgcGxvdHRlZCBmb3IgdGhpcyBzZXJpZXNcbiAgICAgICAgICAgICAgICB2YXIgcGxvdGRhdGEgPSAkLmV4dGVuZCh0cnVlLCBbXSwgc2VyaWVzLmRhdGEpO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1weCwgdGVtcHksIGR2YWwsIHN0YWNrdmFsLCBjb21wYXJhdG9yO1xuICAgICAgICAgICAgICAgIC8vIGZvciBmaXJzdCBzZXJpZXMsIG5vdGhpbmcgdG8gYWRkIHRvIHN0YWNrRGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aW5kZXg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2QgPSB0aGlzLnNlcmllc1tqXS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrPTA7IGs8Y2QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR2YWwgPSBjZFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB4ID0gKGR2YWxbMF0gIT0gbnVsbCkgPyBkdmFsWzBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXB5ID0gKGR2YWxbMV0gIT0gbnVsbCkgPyBkdmFsWzFdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBba11bMF0gKz0gdGVtcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wW2tdWzFdICs9IHRlbXB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2t2YWwgPSAoc2lkeCkgPyB0ZW1weSA6IHRlbXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIHN1bSB1cCB0aGUgc3RhY2sgYXhpcyBjb2x1bW4gb2YgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG9ubHkgc3VtIGlmIGl0IGlzIG9mIHNhbWUgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuZGF0YVtrXVtzaWR4XSAqIHN0YWNrdmFsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90ZGF0YVtrXVtzaWR4XSArPSBzdGFja3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGxvdGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdFZhbHVlcy54LnB1c2gocGxvdGRhdGFbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBwbG90VmFsdWVzLnkucHVzaChwbG90ZGF0YVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Bsb3REYXRhLnB1c2gocGxvdGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrRGF0YS5wdXNoKHRlbXApO1xuICAgICAgICAgICAgICAgIHNlcmllcy5fc3RhY2tEYXRhID0gdGVtcDtcbiAgICAgICAgICAgICAgICBzZXJpZXMuX3Bsb3REYXRhID0gcGxvdGRhdGE7XG4gICAgICAgICAgICAgICAgc2VyaWVzLl9wbG90VmFsdWVzID0gcGxvdFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZXJpZXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwbG90VmFsdWVzLngucHVzaChzZXJpZXMuZGF0YVtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RWYWx1ZXMueS5wdXNoKHNlcmllcy5kYXRhW2ldWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tEYXRhLnB1c2goc2VyaWVzLmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2luZGV4XS5fc3RhY2tEYXRhID0gc2VyaWVzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxvdERhdGEucHVzaChzZXJpZXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VyaWVzLl9wbG90RGF0YSA9IHNlcmllcy5kYXRhO1xuICAgICAgICAgICAgICAgIHNlcmllcy5fcGxvdFZhbHVlcyA9IHBsb3RWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXg+MCkge1xuICAgICAgICAgICAgICAgIHNlcmllcy5fcHJldlBsb3REYXRhID0gdGhpcy5zZXJpZXNbaW5kZXgtMV0uX3Bsb3REYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VyaWVzLl9zdW15ID0gMDtcbiAgICAgICAgICAgIHNlcmllcy5fc3VteCA9IDA7XG4gICAgICAgICAgICBmb3IgKGk9c2VyaWVzLmRhdGEubGVuZ3RoLTE7IGk+LTE7IGktLSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy5fc3VteSArPSBzZXJpZXMuZGF0YVtpXVsxXTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuX3N1bXggKz0gc2VyaWVzLmRhdGFbaV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBmdW5jdGlvbiB0byBzYWZlbHkgcmV0dXJuIGNvbG9ycyBmcm9tIHRoZSBjb2xvciBhcnJheSBhbmQgd3JhcCBhcm91bmQgYXQgdGhlIGVuZC5cbiAgICAgICAgdGhpcy5nZXROZXh0U2VyaWVzQ29sb3IgPSAoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgc2MgPSB0LnNlcmllc0NvbG9ycztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA8IHNjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NbaWR4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjW2lkeCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICBcbiAgICAgICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKXtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnByZVBhcnNlT3B0aW9uc0hvb2tzLmhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVQYXJzZU9wdGlvbnNIb29rcy5ob29rc1tpXS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPCQuanFwbG90LnByZVBhcnNlT3B0aW9uc0hvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJC5qcXBsb3QucHJlUGFyc2VPcHRpb25zSG9va3NbaV0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlID0gb3B0cy5hbmltYXRlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlUmVwbG90ID0gb3B0cy5hbmltYXRlUmVwbG90O1xuICAgICAgICAgICAgdGhpcy5zdGFja1NlcmllcyA9IG9wdHMuc3RhY2tTZXJpZXM7XG4gICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KG9wdHMuZmlsbEJldHdlZW4pKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IFsnc2VyaWVzMScsICdzZXJpZXMyJywgJ2NvbG9yJywgJ2Jhc2VTZXJpZXMnLCAnZmlsbCddLCBcbiAgICAgICAgICAgICAgICAgICAgdGVtcGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9dGVtcC5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBpID0gdGVtcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZmlsbEJldHdlZW5bdGVtcGldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbEJldHdlZW5bdGVtcGldID0gb3B0cy5maWxsQmV0d2Vlblt0ZW1waV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLnNlcmllc0NvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzQ29sb3JzID0gb3B0cy5zZXJpZXNDb2xvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5uZWdhdGl2ZVNlcmllc0NvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMubmVnYXRpdmVTZXJpZXNDb2xvcnMgPSBvcHRzLm5lZ2F0aXZlU2VyaWVzQ29sb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuY2FwdHVyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVSaWdodENsaWNrID0gb3B0cy5jYXB0dXJlUmlnaHRDbGljaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF4aXNTdGFydCA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdEF4aXNTdGFydCAhPSBudWxsKSA/IG9wdGlvbnMuZGVmYXVsdEF4aXNTdGFydCA6IHRoaXMuZGVmYXVsdEF4aXNTdGFydDtcbiAgICAgICAgICAgIHRoaXMuY29sb3JHZW5lcmF0b3Iuc2V0Q29sb3JzKHRoaXMuc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVDb2xvckdlbmVyYXRvci5zZXRDb2xvcnModGhpcy5uZWdhdGl2ZVNlcmllc0NvbG9ycyk7XG4gICAgICAgICAgICAvLyB2YXIgY2cgPSBuZXcgdGhpcy5jb2xvckdlbmVyYXRvcih0aGlzLnNlcmllc0NvbG9ycyk7XG4gICAgICAgICAgICAvLyB2YXIgbmNnID0gbmV3IHRoaXMuY29sb3JHZW5lcmF0b3IodGhpcy5uZWdhdGl2ZVNlcmllc0NvbG9ycyk7XG4gICAgICAgICAgICAvLyB0aGlzLl9ncmlkUGFkZGluZyA9IHRoaXMub3B0aW9ucy5ncmlkUGFkZGluZztcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMuX2dyaWRQYWRkaW5nLCBvcHRzLmdyaWRQYWRkaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc29ydERhdGEgPSAob3B0cy5zb3J0RGF0YSAhPSBudWxsKSA/IG9wdHMuc29ydERhdGEgOiB0aGlzLnNvcnREYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IF9heGlzTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNbbl07XG4gICAgICAgICAgICAgICAgYXhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRzLmF4ZXNEZWZhdWx0cywgb3B0cy5heGVzW25dKTtcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBheGlzLCBvcHRzLmF4ZXNEZWZhdWx0cywgb3B0cy5heGVzW25dKTtcbiAgICAgICAgICAgICAgICBheGlzLl9wbG90V2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgICAgICBheGlzLl9wbG90SGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgICAgLy8gICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLm9wdGlvbnMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHRoaXMub3B0aW9ucy5zZXJpZXMuZGF0YSk7XG4gICAgICAgICAgICAvLyAgICAgfSAgICBcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVEYXRhID0gZnVuY3Rpb24oZGF0YSwgZGlyLCBzdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBkYXRhIGFzIGFuIGFycmF5IG9mIHBvaW50IGFycmF5cyxcbiAgICAgICAgICAgICAgICAvLyBpbiBmb3JtIFtbeDEseTEuLi5dLCBbeDIseTIuLi5dLCAuLi5dXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgICAgICAgICBkaXIgPSBkaXIgfHwgJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgc2VyaWVzIG9mIHNjYWxhcnMuICBPbmUgbGluZSB3aXRoIGp1c3QgeSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHR1cm4gdGhlIHNjYWxhciBsaXN0IG9mIGRhdGEgaW50byBhIGRhdGEgYXJyYXkgb2YgZm9ybTpcbiAgICAgICAgICAgICAgICAgICAgLy8gW1sxLCBkYXRhWzBdXSwgWzIsIGRhdGFbMV1dLCAuLi5dXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wLCBsPWRhdGEubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKFtzdGFydCArIGksIGRhdGFbaV1dKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaChbZGF0YVtpXSwgc3RhcnQraV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJvcGVybHkgZm9ybWF0dGVkIGRhdGEgc2VyaWVzLCBjb3B5IGl0LlxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0ZW1wLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzb3B0cyA9ICQuZXh0ZW5kKHRydWUsIHtpbmRleDogaX0sIHtzZXJpZXNDb2xvcnM6dGhpcy5zZXJpZXNDb2xvcnMsIG5lZ2F0aXZlU2VyaWVzQ29sb3JzOnRoaXMubmVnYXRpdmVTZXJpZXNDb2xvcnN9LCB0aGlzLm9wdGlvbnMuc2VyaWVzRGVmYXVsdHMsIHRoaXMub3B0aW9ucy5zZXJpZXNbaV0sIHtyZW5kZXJlck9wdGlvbnM6e2FuaW1hdGlvbjp7c2hvdzogdGhpcy5hbmltYXRlfX19KTtcbiAgICAgICAgICAgICAgICAvLyBwYXNzIGluIG9wdGlvbnMgaW4gY2FzZSBzb21ldGhpbmcgbmVlZHMgc2V0IHByaW9yIHRvIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IFNlcmllcyhzb3B0cyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPCQuanFwbG90LnByZVBhcnNlU2VyaWVzT3B0aW9uc0hvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICQuanFwbG90LnByZVBhcnNlU2VyaWVzT3B0aW9uc0hvb2tzW2pdLmNhbGwodGVtcCwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHRoaXMucHJlUGFyc2VTZXJpZXNPcHRpb25zSG9va3MuaG9va3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVQYXJzZVNlcmllc09wdGlvbnNIb29rcy5ob29rc1tqXS5jYWxsKHRlbXAsIHRoaXMub3B0aW9ucy5zZXJpZXNEZWZhdWx0cywgdGhpcy5vcHRpb25zLnNlcmllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdyBnbyBiYWNrIGFuZCBhcHBseSB0aGUgb3B0aW9ucyB0byB0aGUgc2VyaWVzLiAgUmVhbGx5IHNob3VsZCBqdXN0IGRvIHRoaXMgZHVyaW5nIGluaXRpYWxpemFpdG9uLCBidXQgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgIC8vIG1lc3MgdXAgcHJlUGFyc2VTZXJpZXNPcHRpb25zSG9va3MgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0ZW1wLCBzb3B0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAucmVuZGVyZXIgPT09ICQuanFwbG90LkJhclJlbmRlcmVyICYmIHRlbXAucmVuZGVyZXJPcHRpb25zICYmIHRlbXAucmVuZGVyZXJPcHRpb25zLmJhckRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLl9zdGFja0F4aXMgPSAneCc7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAuX3ByaW1hcnlBeGlzID0gJ195YXhpcyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXAuZGF0YSA9IG5vcm1hbGl6ZURhdGEodGhpcy5kYXRhW2ldLCBkaXIsIHRoaXMuZGVmYXVsdEF4aXNTdGFydCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZW1wLnhheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3hheGlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuX3hheGlzID0gdGhpcy5heGVzLnhheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gyYXhpcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLl94YXhpcyA9IHRoaXMuYXhlcy54MmF4aXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wLl95YXhpcyA9IHRoaXMuYXhlc1t0ZW1wLnlheGlzXTtcbiAgICAgICAgICAgICAgICB0ZW1wLl94YXhpcy5fc2VyaWVzLnB1c2godGVtcCk7XG4gICAgICAgICAgICAgICAgdGVtcC5feWF4aXMuX3Nlcmllcy5wdXNoKHRlbXApO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5feGF4aXMuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAuX3lheGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAuX3hheGlzLnNjYWxlVG9IaWRkZW5TZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuX3hheGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wLl95YXhpcy5zY2FsZVRvSGlkZGVuU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLl95YXhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC8vIHBhcnNlIHRoZSByZW5kZXJlciBvcHRpb25zIGFuZCBhcHBseSBkZWZhdWx0IGNvbG9ycyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXRlbXAuY29sb3IgJiYgdGVtcC5zaG93ICE9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRlbXAuY29sb3IgPSBjZy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbG9ySW5kZXggPSBjZy5nZXRJbmRleCgpIC0gMTs7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGlmICghdGVtcC5uZWdhdGl2ZUNvbG9yICYmIHRlbXAuc2hvdyAhPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICB0ZW1wLm5lZ2F0aXZlQ29sb3IgPSBuY2cuZ2V0KGNvbG9ySW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vICAgICBuY2cuc2V0SW5kZXgoY29sb3JJbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICghdGVtcC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLmxhYmVsID0gJ1NlcmllcyAnKyAoaSsxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0ZW1wLnJlbmRlcmVyT3B0aW9ucy5zaG93ID0gdGVtcC5zaG93O1xuICAgICAgICAgICAgICAgIC8vICQuZXh0ZW5kKHRydWUsIHRlbXAucmVuZGVyZXIsIHtjb2xvcjp0aGlzLnNlcmllc0NvbG9yc1tpXX0sIHRoaXMucmVuZGVyZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllcy5wdXNoKHRlbXApOyAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPCQuanFwbG90LnBvc3RQYXJzZVNlcmllc09wdGlvbnNIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAkLmpxcGxvdC5wb3N0UGFyc2VTZXJpZXNPcHRpb25zSG9va3Nbal0uY2FsbCh0aGlzLnNlcmllc1tpXSwgdGhpcy5vcHRpb25zLnNlcmllc0RlZmF1bHRzLCB0aGlzLm9wdGlvbnMuc2VyaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHRoaXMucG9zdFBhcnNlU2VyaWVzT3B0aW9uc0hvb2tzLmhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdFBhcnNlU2VyaWVzT3B0aW9uc0hvb2tzLmhvb2tzW2pdLmNhbGwodGhpcy5zZXJpZXNbaV0sIHRoaXMub3B0aW9ucy5zZXJpZXNEZWZhdWx0cywgdGhpcy5vcHRpb25zLnNlcmllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb3B5IHRoZSBncmlkIGFuZCB0aXRsZSBvcHRpb25zIGludG8gdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLmdyaWQsIHRoaXMub3B0aW9ucy5ncmlkKTtcbiAgICAgICAgICAgIC8vIGlmIGF4aXMgYm9yZGVyIHByb3BlcnRpZXMgYXJlbid0IHNldCwgc2V0IGRlZmF1bHQuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9X2F4aXNOYW1lcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBfYXhpc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5heGVzW25dO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLmJvcmRlcldpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5ib3JkZXJXaWR0aCA9dGhpcy5ncmlkLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudGl0bGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlLnRleHQgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRpdGxlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcy50aXRsZSwgdGhpcy5vcHRpb25zLnRpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGl0bGUuX3Bsb3RXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmQuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMubGVnZW5kKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPCQuanFwbG90LnBvc3RQYXJzZU9wdGlvbnNIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICQuanFwbG90LnBvc3RQYXJzZU9wdGlvbnNIb29rc1tpXS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucG9zdFBhcnNlT3B0aW9uc0hvb2tzLmhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0UGFyc2VPcHRpb25zSG9va3MuaG9va3NbaV0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1ldGhvZDogZGVzdHJveVxuICAgICAgICAvLyBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIG9jY3VwaWVkIGJ5IHRoZSBwbG90XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWVBbGxDYW52YXNlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRDYW52YXMgJiYgdGhpcy5ldmVudENhbnZhcy5fZWxlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX2VsZW0udW5iaW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3VwbGUgb2YgcG9zdHMgb24gU3RhY2sgT3ZlcmZsb3cgaW5kaWNhdGUgdGhhdCBlbXB0eSgpIGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGFsd2F5cyBjZWFyIHVwIHRoZSBkb20gYW5kIHJlbGVhc2UgbWVtb3J5LiAgU29tZXRpbWVzIHNldHRpbmdcbiAgICAgICAgICAgIC8vIGlubmVySFRNTCBwcm9wZXJ0eSB0byBudWxsIGlzIG5lZWRlZC4gIFBhcnRpY3VsYXJseSBvbiBJRSwgbWF5IFxuICAgICAgICAgICAgLy8gaGF2ZSB0byBkaXJlY3RseSBzZXQgaXQgdG8gbnVsbCwgYnlwYXNzaW5nICQuXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5lbXB0eSgpO1xuXG4gICAgICAgICAgICB0aGlzLnRhcmdldFswXS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1ldGhvZDogcmVwbG90XG4gICAgICAgIC8vIERvZXMgYSByZWluaXRpYWxpemF0aW9uIG9mIHRoZSBwbG90IGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vIGEgcmVkcmF3LiAgTWV0aG9kIGNvdWxkIGJlIHVzZWQgdG8gaW50ZXJhY3RpdmVseVxuICAgICAgICAvLyBjaGFuZ2UgcGxvdCBjaGFyYWN0ZXJpc3RpY3MgYW5kIHRoZW4gcmVwbG90LlxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJhbWV0ZXJzOlxuICAgICAgICAvLyBvcHRpb25zIC0gT3B0aW9ucyB1c2VkIGZvciByZXBsb3R0aW5nLlxuICAgICAgICAvL1xuICAgICAgICAvLyBQcm9wZXJ0aWVzOlxuICAgICAgICAvLyBjbGVhciAtIGZhbHNlIHRvIG5vdCBjbGVhciAoZW1wdHkpIHRoZSBwbG90IGNvbnRhaW5lciBiZWZvcmUgcmVwbG90dGluZyAoZGVmYXVsdDogdHJ1ZSkuXG4gICAgICAgIC8vIHJlc2V0QXhlcyAtIHRydWUgdG8gcmVzZXQgYWxsIGF4ZXMgbWluLCBtYXgsIG51bWJlclRpY2tzIGFuZCB0aWNrSW50ZXJ2YWwgc2V0dGluZyBzbyBheGVzIHdpbGwgcmVzY2FsZSB0aGVtc2VsdmVzLlxuICAgICAgICAvLyAgICAgICAgICAgICBvcHRpb25hbGx5IHBhc3MgaW4gbGlzdCBvZiBheGVzIHRvIHJlc2V0IChlLmcuIFsneGF4aXMnLCAneTJheGlzJ10pIChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICAgIHRoaXMucmVwbG90ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSAgb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gb3B0cy5kYXRhIHx8IG51bGw7XG4gICAgICAgICAgICB2YXIgY2xlYXIgPSAob3B0cy5jbGVhciA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHJlc2V0QXhlcyA9IG9wdHMucmVzZXRBeGVzIHx8IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdHMuZGF0YTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmNsZWFyO1xuICAgICAgICAgICAgZGVsZXRlIG9wdHMucmVzZXRBeGVzO1xuXG4gICAgICAgICAgICB0aGlzLnRhcmdldC50cmlnZ2VyKCdqcXBsb3RQcmVSZXBsb3QnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBoYXZlIGRhdGEgb3Igb3RoZXIgb3B0aW9ucywgZnVsbCByZWluaXQuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHF1aWNraW5pdC5cbiAgICAgICAgICAgIGlmIChkYXRhIHx8ICEkLmlzRW1wdHlPYmplY3Qob3B0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlSW5pdGlhbGl6ZShkYXRhLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucXVpY2tJbml0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNldEF4ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QXhlc1NjYWxlKHJlc2V0QXhlcywgb3B0cy5heGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQudHJpZ2dlcignanFwbG90UG9zdFJlcGxvdCcpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gbWV0aG9kOiByZWRyYXdcbiAgICAgICAgLy8gRW1wdGllcyB0aGUgcGxvdCB0YXJnZXQgZGl2IGFuZCByZWRyYXdzIHRoZSBwbG90LlxuICAgICAgICAvLyBUaGlzIGVuYWJsZXMgcGxvdCBkYXRhIGFuZCBwcm9wZXJ0aWVzIHRvIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gYW5kIHRoZW4gdG8gY29tbGV0ZWx5IGNsZWFyIHRoZSBwbG90IGFuZCByZWRyYXcuXG4gICAgICAgIC8vIHJlZHJhdyAqd2lsbCBub3QqIHJlaW5pdGlhbGl6ZSBhbnkgcGxvdCBlbGVtZW50cy5cbiAgICAgICAgLy8gVGhhdCBpcywgYXhlcyB3aWxsIG5vdCBiZSBhdXRvc2NhbGVkIGFuZCBkZWZhdWx0c1xuICAgICAgICAvLyB3aWxsIG5vdCBiZSByZWFwcGxpZWQgdG8gYW55IHBsb3QgZWxlbWVudHMuICByZWRyYXdcbiAgICAgICAgLy8gaXMgdXNlZCBwcmltYXJpbHkgd2l0aCB6b29taW5nLiBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFyYW1ldGVyczpcbiAgICAgICAgLy8gY2xlYXIgLSBmYWxzZSB0byBub3QgY2xlYXIgKGVtcHR5KSB0aGUgcGxvdCBjb250YWluZXIgYmVmb3JlIHJlZHJhd2luZyAoZGVmYXVsdDogdHJ1ZSkuXG4gICAgICAgIHRoaXMucmVkcmF3ID0gZnVuY3Rpb24oY2xlYXIpIHtcbiAgICAgICAgICAgIGNsZWFyID0gKGNsZWFyICE9IG51bGwpID8gY2xlYXIgOiB0cnVlO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQudHJpZ2dlcignanFwbG90UHJlUmVkcmF3Jyk7XG4gICAgICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZUFsbENhbnZhc2VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fZWxlbS51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICAvLyBEb250IHRoaW5rIEkgYmluZCBhbnkgZXZlbnRzIHRvIHRoZSB0YXJnZXQsIHRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAvLyBJdCB3aWxsIHJlbW92ZSB1c2VyJ3MgZXZlbnRzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMudGFyZ2V0LnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmVtcHR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgZm9yICh2YXIgYXggaW4gdGhpcy5heGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5heGVzW2F4XS5fdGlja3MgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVBsb3REYXRhKCk7XG4gICAgICAgICAgICAvLyBmb3IgKHZhciBpPTA7IGk8dGhpcy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnBvcHVsYXRlUGxvdERhdGEodGhpcy5zZXJpZXNbaV0sIGkpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgdGhpcy5fc3VteSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zdW14ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgdHNsID0gdGhpcy5zZXJpZXMubGVuZ3RoOyBpPHRzbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VteSArPSB0aGlzLnNlcmllc1tpXS5fc3VteTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW14ICs9IHRoaXMuc2VyaWVzW2ldLl9zdW14O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC50cmlnZ2VyKCdqcXBsb3RQb3N0UmVkcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBtZXRob2Q6IGRyYXdcbiAgICAgICAgLy8gRHJhd3MgYWxsIGVsZW1lbnRzIG9mIHRoZSBwbG90IGludG8gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgLy8gRG9lcyBub3QgY2xlYXIgdGhlIGNvbnRhaW5lciBiZWZvcmUgZHJhd2luZy5cbiAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdJZkhpZGRlbiB8fCB0aGlzLnRhcmdldC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnRyaWdnZXIoJ2pxcGxvdFByZURyYXcnKTtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICAgICAgdGVtcHNlcmllcztcbiAgICAgICAgICAgICAgICBmb3IgKGk9MCwgbD0kLmpxcGxvdC5wcmVEcmF3SG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAkLmpxcGxvdC5wcmVEcmF3SG9va3NbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpPTAsIGw9dGhpcy5wcmVEcmF3SG9va3MuaG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZURyYXdIb29rcy5ob29rc1tpXS5hcHBseSh0aGlzLCB0aGlzLnByZURyYXdTZXJpZXNIb29rcy5hcmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIHVuZGVybHlpbmcgY2FudmFzIHRvIGJlIHVzZWQgZm9yIHNwZWNpYWwgZmVhdHVyZXMuXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKHRoaXMuYmFzZUNhbnZhcy5jcmVhdGVFbGVtZW50KHtsZWZ0OjAsIHJpZ2h0OjAsIHRvcDowLCBib3R0b206MH0sICdqcXBsb3QtYmFzZS1jYW52YXMnLCBudWxsLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlQ2FudmFzLnNldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5hcHBlbmQodGhpcy50aXRsZS5kcmF3KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudGl0bGUucGFjayh7dG9wOjAsIGxlZnQ6MH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugcm9vbSAgZm9yIHRoZSBsZWdlbmQgYmV0d2VlbiB0aGUgZ3JpZCBhbmQgdGhlIGVkZ2UuXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBhIGR1bW15IG9mZnNldHMgb2JqZWN0IGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgcGxvdC5cbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kRWxlbSA9IHRoaXMubGVnZW5kLmRyYXcoe30sIHRoaXMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBncmlkUGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVnZW5kLnBsYWNlbWVudCA9PSBcIm91dHNpZGVHcmlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgYXBwZW5kIHRoZSBsZWdlbmQgdG8gZ2V0IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKGxlZ2VuZEVsZW0pO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubGVnZW5kLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUGFkZGluZy50b3AgKz0gdGhpcy5sZWdlbmQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUGFkZGluZy5ib3R0b20gKz0gdGhpcy5sZWdlbmQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUGFkZGluZy5yaWdodCArPSB0aGlzLmxlZ2VuZC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbncnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFBhZGRpbmcubGVmdCArPSB0aGlzLmxlZ2VuZC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogIC8vIHNhbWUgYXMgJ25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRQYWRkaW5nLnJpZ2h0ICs9IHRoaXMubGVnZW5kLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kRWxlbSA9IGxlZ2VuZEVsZW0uZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBheCA9IHRoaXMuYXhlcztcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSB5TWlkQXhpcyBmaXJzdCwgc28geGF4aXMgb2YgcHlyYW1pZCBjaGFydCBjYW4gYWRqdXN0IGl0c2VsZiBpZiBuZWVkZWQuXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8MTI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gX2F4aXNOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKGF4W25hbWVdLmRyYXcodGhpcy5iYXNlQ2FudmFzLl9jdHgsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgYXhbbmFtZV0uc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChheC55YXhpcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRQYWRkaW5nLmxlZnQgKz0gYXgueWF4aXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJhID0gWyd5MmF4aXMnLCAneTNheGlzJywgJ3k0YXhpcycsICd5NWF4aXMnLCAneTZheGlzJywgJ3k3YXhpcycsICd5OGF4aXMnLCAneTlheGlzJ107XG4gICAgICAgICAgICAgICAgdmFyIHJhcGFkID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgIHZhciBncHIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgICAgIGZvciAobj0wOyBuPDg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhbcmFbbl1dLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwciArPSBheFtyYVtuXV0uZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhcGFkW25dID0gZ3ByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyaWRQYWRkaW5nLnJpZ2h0ICs9IGdwcjtcbiAgICAgICAgICAgICAgICBpZiAoYXgueDJheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFBhZGRpbmcudG9wICs9IGF4LngyYXhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGl0bGUuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBncmlkUGFkZGluZy50b3AgKz0gdGhpcy50aXRsZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF4LnhheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFBhZGRpbmcuYm90dG9tICs9IGF4LnhheGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgZ3JpZFBhZGRpbmcgYWRqdXN0bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHBhc3NlZCBpbiBncmlkRGltZW5zaW9ucyBvcHRpb24sIGNoZWNrIGFnYWluc3QgY2FsY3VsYXRlZCBncmlkUGFkZGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JpZERpbWVuc2lvbnMgJiYgJC5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9ucy5ncmlkRGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdkdyA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5ncmlkRGltZW5zaW9ucy53aWR0aCwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZGggPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuZ3JpZERpbWVuc2lvbnMuaGVpZ2h0LCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQWRqID0gKHRoaXMuX3dpZHRoIC0gZ3JpZFBhZGRpbmcubGVmdCAtIGdyaWRQYWRkaW5nLnJpZ2h0IC0gZ2R3KS8yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0QWRqID0gKHRoaXMuX2hlaWdodCAtIGdyaWRQYWRkaW5nLnRvcCAtIGdyaWRQYWRkaW5nLmJvdHRvbSAtIGdkaCkvMjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QWRqID49IDAgJiYgd2lkdGhBZGogPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFBhZGRpbmcudG9wICs9IGhlaWdodEFkajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRQYWRkaW5nLmJvdHRvbSArPSBoZWlnaHRBZGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkUGFkZGluZy5sZWZ0ICs9IHdpZHRoQWRqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFBhZGRpbmcucmlnaHQgKz0gd2lkdGhBZGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dyaWRQYWRkaW5nW2FycltuXV0gPT0gbnVsbCAmJiBncmlkUGFkZGluZ1thcnJbbl1dID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JpZFBhZGRpbmdbYXJyW25dXSA9IGdyaWRQYWRkaW5nW2FycltuXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ3JpZFBhZGRpbmdbYXJyW25dXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmlkUGFkZGluZ1thcnJbbl1dID0gdGhpcy5fZGVmYXVsdEdyaWRQYWRkaW5nW2FycltuXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFBhZGRpbmcgPSB0aGlzLl9ncmlkUGFkZGluZztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWdlbmQucGxhY2VtZW50ID09PSAnb3V0c2lkZUdyaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFBhZGRpbmcgPSB7dG9wOnRoaXMudGl0bGUuZ2V0SGVpZ2h0KCksIGxlZnQ6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBheC54YXhpcy5wYWNrKHtwb3NpdGlvbjonYWJzb2x1dGUnLCBib3R0b206dGhpcy5fZ3JpZFBhZGRpbmcuYm90dG9tIC0gYXgueGF4aXMuZ2V0SGVpZ2h0KCksIGxlZnQ6MCwgd2lkdGg6dGhpcy5fd2lkdGh9LCB7bWluOnRoaXMuX2dyaWRQYWRkaW5nLmxlZnQsIG1heDp0aGlzLl93aWR0aCAtIHRoaXMuX2dyaWRQYWRkaW5nLnJpZ2h0fSk7XG4gICAgICAgICAgICAgICAgYXgueWF4aXMucGFjayh7cG9zaXRpb246J2Fic29sdXRlJywgdG9wOjAsIGxlZnQ6dGhpcy5fZ3JpZFBhZGRpbmcubGVmdCAtIGF4LnlheGlzLmdldFdpZHRoKCksIGhlaWdodDp0aGlzLl9oZWlnaHR9LCB7bWluOnRoaXMuX2hlaWdodCAtIHRoaXMuX2dyaWRQYWRkaW5nLmJvdHRvbSwgbWF4OiB0aGlzLl9ncmlkUGFkZGluZy50b3B9KTtcbiAgICAgICAgICAgICAgICBheC54MmF4aXMucGFjayh7cG9zaXRpb246J2Fic29sdXRlJywgdG9wOnRoaXMuX2dyaWRQYWRkaW5nLnRvcCAtIGF4LngyYXhpcy5nZXRIZWlnaHQoKSwgbGVmdDowLCB3aWR0aDp0aGlzLl93aWR0aH0sIHttaW46dGhpcy5fZ3JpZFBhZGRpbmcubGVmdCwgbWF4OnRoaXMuX3dpZHRoIC0gdGhpcy5fZ3JpZFBhZGRpbmcucmlnaHR9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGk9ODsgaT4wOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXhbcmFbaS0xXV0ucGFjayh7cG9zaXRpb246J2Fic29sdXRlJywgdG9wOjAsIHJpZ2h0OnRoaXMuX2dyaWRQYWRkaW5nLnJpZ2h0IC0gcmFwYWRbaS0xXX0sIHttaW46dGhpcy5faGVpZ2h0IC0gdGhpcy5fZ3JpZFBhZGRpbmcuYm90dG9tLCBtYXg6IHRoaXMuX2dyaWRQYWRkaW5nLnRvcH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbHRlbXAgPSAodGhpcy5fd2lkdGggLSB0aGlzLl9ncmlkUGFkZGluZy5sZWZ0IC0gdGhpcy5fZ3JpZFBhZGRpbmcucmlnaHQpLzIuMCArIHRoaXMuX2dyaWRQYWRkaW5nLmxlZnQgLSBheC55TWlkQXhpcy5nZXRXaWR0aCgpLzIuMDtcbiAgICAgICAgICAgICAgICBheC55TWlkQXhpcy5wYWNrKHtwb3NpdGlvbjonYWJzb2x1dGUnLCB0b3A6MCwgbGVmdDpsdGVtcCwgekluZGV4OjksIHRleHRBbGlnbjogJ2NlbnRlcid9LCB7bWluOnRoaXMuX2hlaWdodCAtIHRoaXMuX2dyaWRQYWRkaW5nLmJvdHRvbSwgbWF4OiB0aGlzLl9ncmlkUGFkZGluZy50b3B9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFwcGVuZCh0aGlzLmdyaWQuY3JlYXRlRWxlbWVudCh0aGlzLl9ncmlkUGFkZGluZywgdGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNMZW5ndGggPSBzZXJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIHB1dCB0aGUgc2hhZG93IGNhbnZhc2VzIGJlaGluZCB0aGUgc2VyaWVzIGNhbnZhc2VzIHNvIHNoYWRvd3MgZG9uJ3Qgb3ZlcmxhcCBvbiBzdGFja2VkIGJhcnMuXG4gICAgICAgICAgICAgICAgZm9yIChpPTAsIGw9c2VyaWVzTGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHNlcmllcyBpbiBvcmRlciBvZiBzdGFja2luZy4gIFRoaXMgYWZmZWN0cyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIG9yZGVyIGluIHdoaWNoIGNhbnZhc2VzIGFyZSBhZGRlZCB0byBkb20uXG4gICAgICAgICAgICAgICAgICAgIGogPSB0aGlzLnNlcmllc1N0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5hcHBlbmQoc2VyaWVzW2pdLnNoYWRvd0NhbnZhcy5jcmVhdGVFbGVtZW50KHRoaXMuX2dyaWRQYWRkaW5nLCAnanFwbG90LXNlcmllcy1zaGFkb3dDYW52YXMnLCBudWxsLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc1tqXS5zaGFkb3dDYW52YXMuc2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNbal0uc2hhZG93Q2FudmFzLl9lbGVtLmRhdGEoJ3Nlcmllc0luZGV4Jywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoaT0wLCBsPXNlcmllc0xlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyBzZXJpZXMgaW4gb3JkZXIgb2Ygc3RhY2tpbmcuICBUaGlzIGFmZmVjdHMgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBvcmRlciBpbiB3aGljaCBjYW52YXNlcyBhcmUgYWRkZWQgdG8gZG9tLlxuICAgICAgICAgICAgICAgICAgICBqID0gdGhpcy5zZXJpZXNTdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKHNlcmllc1tqXS5jYW52YXMuY3JlYXRlRWxlbWVudCh0aGlzLl9ncmlkUGFkZGluZywgJ2pxcGxvdC1zZXJpZXMtY2FudmFzJywgbnVsbCwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNbal0uY2FudmFzLnNldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzW2pdLmNhbnZhcy5fZWxlbS5kYXRhKCdzZXJpZXNJbmRleCcsIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHVzZSBmaWxsZWQgY2FudmFzIHRvIGNhcHR1cmUgZXZlbnRzIGluIElFLlxuICAgICAgICAgICAgICAgIC8vIEFsc28sIGNhbnZhcyBzZWVtcyB0byBibG9jayBzZWxlY3Rpb24gb2Ygb3RoZXIgZWxlbWVudHMgaW4gZG9jdW1lbnQgb24gRkYuXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYXBwZW5kKHRoaXMuZXZlbnRDYW52YXMuY3JlYXRlRWxlbWVudCh0aGlzLl9ncmlkUGFkZGluZywgJ2pxcGxvdC1ldmVudC1jYW52YXMnLCBudWxsLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5zZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9jdHguZmlsbFJlY3QoMCwwLHRoaXMuZXZlbnRDYW52YXMuX2N0eC5jYW52YXMud2lkdGgsIHRoaXMuZXZlbnRDYW52YXMuX2N0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGJpbmQgY3VzdG9tIGV2ZW50IGhhbmRsZXJzIHRvIHJlZ3VsYXIgZXZlbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuYmluZEN1c3RvbUV2ZW50cygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBsZWdlbmQgYmVmb3JlIHNlcmllcyBpZiB0aGUgc2VyaWVzIG5lZWRzIHRvIGtub3cgdGhlIGxlZ2VuZCBkaW1lbnNpb25zLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZ2VuZC5wcmVEcmF3KSB7ICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fZWxlbS5iZWZvcmUobGVnZW5kRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVnZW5kLnBhY2sobGVnZW5kUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZ2VuZC5fZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U2VyaWVzKHtsZWdlbmRJbmZvOntsb2NhdGlvbjp0aGlzLmxlZ2VuZC5sb2NhdGlvbiwgcGxhY2VtZW50OnRoaXMubGVnZW5kLnBsYWNlbWVudCwgd2lkdGg6dGhpcy5sZWdlbmQuZ2V0V2lkdGgoKSwgaGVpZ2h0OnRoaXMubGVnZW5kLmdldEhlaWdodCgpLCB4b2Zmc2V0OnRoaXMubGVnZW5kLnhvZmZzZXQsIHlvZmZzZXQ6dGhpcy5sZWdlbmQueW9mZnNldH19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gZHJhdyBzZXJpZXMgYmVmb3JlIGxlZ2VuZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChzZXJpZXNbc2VyaWVzTGVuZ3RoLTFdLmNhbnZhcy5fZWxlbSkuYWZ0ZXIobGVnZW5kRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWdlbmQucGFjayhsZWdlbmRQYWRkaW5nKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBvdmVybGF5IGNhbnZhc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbD0kLmpxcGxvdC5ldmVudExpc3RlbmVySG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgaGFuZGxlciwgdGhpcyB3aWxsIHJlZmVyIHRvIHRoZSBldmVudENhbnZhcyBkb20gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGFyZSByZWZlcmVuY2VzIGJhY2sgaW50byBwbG90IG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX2VsZW0uYmluZCgkLmpxcGxvdC5ldmVudExpc3RlbmVySG9va3NbaV1bMF0sIHtwbG90OnRoaXN9LCAkLmpxcGxvdC5ldmVudExpc3RlbmVySG9va3NbaV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgb3ZlcmxheSBjYW52YXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9dGhpcy5ldmVudExpc3RlbmVySG9va3MuaG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgaGFuZGxlciwgdGhpcyB3aWxsIHJlZmVyIHRvIHRoZSBldmVudENhbnZhcyBkb20gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGFyZSByZWZlcmVuY2VzIGJhY2sgaW50byBwbG90IG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX2VsZW0uYmluZCh0aGlzLmV2ZW50TGlzdGVuZXJIb29rcy5ob29rc1tpXVswXSwge3Bsb3Q6dGhpc30sIHRoaXMuZXZlbnRMaXN0ZW5lckhvb2tzLmhvb2tzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZmIgPSB0aGlzLmZpbGxCZXR3ZWVuO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBmYi5zZXJpZXMxID09ICdudW1iZXInKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmIuZmlsbCYmZmIuc2VyaWVzMSE9PWZiLnNlcmllczImJmZiLnNlcmllczE8c2VyaWVzTGVuZ3RoJiZmYi5zZXJpZXMyPHNlcmllc0xlbmd0aCYmc2VyaWVzW2ZiLnNlcmllczFdLl90eXBlPT09XCJsaW5lXCImJnNlcmllc1tmYi5zZXJpZXMyXS5fdHlwZT09PVwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvRmlsbEJldHdlZW5MaW5lcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBpZihmYi5zZXJpZXMxICE9IG51bGwgJiYgZmIuc2VyaWVzMiAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb0ZiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmYi5zZXJpZXMxLmxlbmd0aCA9PT0gZmIuc2VyaWVzMi5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wU2VyaWVzMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBTZXJpZXMyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGNudCA9IDA7IGNudCA8IGZiLnNlcmllczEubGVuZ3RoOyBjbnQrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTZXJpZXMxID0gZmIuc2VyaWVzMVtjbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU2VyaWVzMiA9IGZiLnNlcmllczJbY250XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGVtcFNlcmllczEhPT10ZW1wU2VyaWVzMiYmdGVtcFNlcmllczE8c2VyaWVzTGVuZ3RoJiZ0ZW1wU2VyaWVzMjxzZXJpZXNMZW5ndGgmJnNlcmllc1t0ZW1wU2VyaWVzMV0uX3R5cGU9PT1cImxpbmVcIiYmc2VyaWVzW3RlbXBTZXJpZXMyXS5fdHlwZT09PVwibGluZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvRmIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0ZiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZiLmZpbGwgJiYgZG9GYil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0ZpbGxCZXR3ZWVuTGluZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbD0kLmpxcGxvdC5wb3N0RHJhd0hvb2tzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJC5qcXBsb3QucG9zdERyYXdIb29rc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbD10aGlzLnBvc3REcmF3SG9va3MuaG9va3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3REcmF3SG9va3MuaG9va3NbaV0uYXBwbHkodGhpcywgdGhpcy5wb3N0RHJhd0hvb2tzLmFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcHMsIFxuICAgICAgICAgICAgICAgICAgICB0ZW1wcixcbiAgICAgICAgICAgICAgICAgICAgc2VsLFxuICAgICAgICAgICAgICAgICAgICBfZWxzO1xuICAgICAgICAgICAgICAgIC8vIHVnaGguICBpZGVhbGx5IHdvdWxkIGhpZGUgYWxsIHNlcmllcyB0aGVuIHNob3cgdGhlbS5cbiAgICAgICAgICAgICAgICBmb3IgKGk9MCwgbD1zZXJpZXNMZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBzID0gc2VyaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wciA9IHRlbXBzLnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgICAgICBzZWwgPSAnLmpxcGxvdC1wb2ludC1sYWJlbC5qcXBsb3Qtc2VyaWVzLScraTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXByLmFuaW1hdGlvbiAmJiB0ZW1wci5hbmltYXRpb24uX3N1cHBvcnRlZCAmJiB0ZW1wci5hbmltYXRpb24uc2hvdyAmJiAodGhpcy5fZHJhd0NvdW50IDwgMiB8fCB0aGlzLmFuaW1hdGVSZXBsb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWxzID0gdGhpcy50YXJnZXQuZmluZChzZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vscy5zdG9wKHRydWUsIHRydWUpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBzLmNhbnZhcy5fZWxlbS5zdG9wKHRydWUsIHRydWUpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBzLnNoYWRvd0NhbnZhcy5fZWxlbS5zdG9wKHRydWUsIHRydWUpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBzLmNhbnZhcy5fZWxlbS5qcXBsb3RFZmZlY3QoJ2JsaW5kJywge21vZGU6ICdzaG93JywgZGlyZWN0aW9uOiB0ZW1wci5hbmltYXRpb24uZGlyZWN0aW9ufSwgdGVtcHIuYW5pbWF0aW9uLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBzLnNoYWRvd0NhbnZhcy5fZWxlbS5qcXBsb3RFZmZlY3QoJ2JsaW5kJywge21vZGU6ICdzaG93JywgZGlyZWN0aW9uOiB0ZW1wci5hbmltYXRpb24uZGlyZWN0aW9ufSwgdGVtcHIuYW5pbWF0aW9uLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lbHMuZmFkZUluKHRlbXByLmFuaW1hdGlvbi5zcGVlZCowLjgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lbHMgPSBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQudHJpZ2dlcignanFwbG90UG9zdERyYXcnLCBbdGhpc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGpxUGxvdC5wcm90b3R5cGUuZG9GaWxsQmV0d2VlbkxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZiID0gdGhpcy5maWxsQmV0d2VlbjtcbiAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcztcbiAgICAgICAgICAgIHZhciBzaWQxID0gZmIuc2VyaWVzMTtcbiAgICAgICAgICAgIHZhciBzaWQyID0gZmIuc2VyaWVzMjtcbiAgICAgICAgICAgIHZhciBpZDEgPSAwLCBpZDIgPSAwO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaWxsKGlkMSwgaWQyKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzMSA9IHNlcmllc1tpZDFdO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMyID0gc2VyaWVzW2lkMl07XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllczIucmVuZGVyZXIuc21vb3RoKVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGdkID0gc2VyaWVzMi5yZW5kZXJlci5fc21vb3RoZWREYXRhLnNsaWNlKDApLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wZ2QgPSBzZXJpZXMyLmdyaWREYXRhLnNsaWNlKDApLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzMS5yZW5kZXJlci5zbW9vdGgpXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZCA9IHNlcmllczEucmVuZGVyZXIuX3Ntb290aGVkRGF0YS5jb25jYXQodGVtcGdkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZCA9IHNlcmllczEuZ3JpZERhdGEuY29uY2F0KHRlbXBnZCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZmIuY29sb3IgIT09IG51bGwgPyBmYi5jb2xvciA6IHNlcmllc1tpZDFdLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVNlcmllcyA9IGZiLmJhc2VTZXJpZXMgIT09IG51bGwgPyBmYi5iYXNlU2VyaWVzIDogaWQxO1xuICAgICAgICAgICAgICAgIHZhciBzciA9XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc1tiYXNlU2VyaWVzXS5yZW5kZXJlci5zaGFwZVJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZSA6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmaWxsIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VQYXRoIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3IuZHJhdyhzZXJpZXMxLnNoYWRvd0NhbnZhcy5fY3R4LCBnZCwgb3B0cylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodHlwZW9mIHNpZDEgPT0gJ251bWJlcicgJiYgdHlwZW9mIHNpZDIgPT0gJ251bWJlcicpe1xuICAgICAgICAgICAgICAgIGlkMSA9IHNpZDEgPCBzaWQyID8gc2lkMSA6IHNpZDI7XG4gICAgICAgICAgICAgICAgaWQyID0gc2lkMiA+IHNpZDEgPyBzaWQyIDogc2lkMTtcbiAgICAgICAgICAgICAgICBmaWxsKGlkMSwgaWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBjbnQgPSAwOyBjbnQgPCBzaWQxLmxlbmd0aCA7IGNudCsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWQxID0gc2lkMVtjbnRdIDwgc2lkMltjbnRdID8gc2lkMVtjbnRdIDogc2lkMltjbnRdO1xuICAgICAgICAgICAgICAgICAgICBpZDIgPSBzaWQyW2NudF0gPiBzaWQxW2NudF0gPyBzaWQyW2NudF0gOiBzaWQxW2NudF07XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoaWQxLCBpZDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYmluZEN1c3RvbUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fZWxlbS5iaW5kKCdjbGljaycsIHtwbG90OnRoaXN9LCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fZWxlbS5iaW5kKCdkYmxjbGljaycsIHtwbG90OnRoaXN9LCB0aGlzLm9uRGJsQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5ldmVudENhbnZhcy5fZWxlbS5iaW5kKCdtb3VzZWRvd24nLCB7cGxvdDp0aGlzfSwgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJpbmQoJ21vdXNlbW92ZScsIHtwbG90OnRoaXN9LCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX2VsZW0uYmluZCgnbW91c2VlbnRlcicsIHtwbG90OnRoaXN9LCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJpbmQoJ21vdXNlbGVhdmUnLCB7cGxvdDp0aGlzfSwgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJpbmQoJ21vdXNldXAnLCB7cGxvdDp0aGlzfSwgdGhpcy5vblJpZ2h0Q2xpY2spO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRDYW52YXMuX2VsZW0uZ2V0KDApLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJpbmQoJ21vdXNldXAnLCB7cGxvdDp0aGlzfSwgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gZ2V0RXZlbnRQb3NpdGlvbihldikge1xuICAgICAgICAgICAgdmFyIHBsb3QgPSBldi5kYXRhLnBsb3Q7XG4gICAgICAgICAgICB2YXIgZ28gPSBwbG90LmV2ZW50Q2FudmFzLl9lbGVtLm9mZnNldCgpO1xuICAgICAgICAgICAgdmFyIGdyaWRQb3MgPSB7eDpldi5wYWdlWCAtIGdvLmxlZnQsIHk6ZXYucGFnZVkgLSBnby50b3B9O1xuICAgICAgICAgICAgdmFyIGRhdGFQb3MgPSB7eGF4aXM6bnVsbCwgeWF4aXM6bnVsbCwgeDJheGlzOm51bGwsIHkyYXhpczpudWxsLCB5M2F4aXM6bnVsbCwgeTRheGlzOm51bGwsIHk1YXhpczpudWxsLCB5NmF4aXM6bnVsbCwgeTdheGlzOm51bGwsIHk4YXhpczpudWxsLCB5OWF4aXM6bnVsbCwgeU1pZEF4aXM6bnVsbH07XG4gICAgICAgICAgICB2YXIgYW4gPSBbJ3hheGlzJywgJ3lheGlzJywgJ3gyYXhpcycsICd5MmF4aXMnLCAneTNheGlzJywgJ3k0YXhpcycsICd5NWF4aXMnLCAneTZheGlzJywgJ3k3YXhpcycsICd5OGF4aXMnLCAneTlheGlzJywgJ3lNaWRBeGlzJ107XG4gICAgICAgICAgICB2YXIgYXggPSBwbG90LmF4ZXM7XG4gICAgICAgICAgICB2YXIgbiwgYXhpcztcbiAgICAgICAgICAgIGZvciAobj0xMTsgbj4wOyBuLS0pIHtcbiAgICAgICAgICAgICAgICBheGlzID0gYW5bbi0xXTtcbiAgICAgICAgICAgICAgICBpZiAoYXhbYXhpc10uc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUG9zW2F4aXNdID0gYXhbYXhpc10uc2VyaWVzX3AydShncmlkUG9zW2F4aXMuY2hhckF0KDApXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge29mZnNldHM6Z28sIGdyaWRQb3M6Z3JpZFBvcywgZGF0YVBvczpkYXRhUG9zfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGV2ZW50IGxvY2F0aW9uIGlzIG92ZXIgYSBhcmVhIGFyZWFcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oZ3JpZHBvcywgcGxvdCkge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IHBsb3Quc2VyaWVzO1xuICAgICAgICAgICAgdmFyIGksIGosIGssIHMsIHIsIHgsIHksIHRoZXRhLCBzbSwgc2EsIG1pbmFuZywgbWF4YW5nO1xuICAgICAgICAgICAgdmFyIGQwLCBkLCBwLCBwcCwgcG9pbnRzLCBidywgaHA7XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkLCB0O1xuICAgICAgICAgICAgZm9yIChrPXBsb3Quc2VyaWVzU3RhY2subGVuZ3RoLTE7IGs+PTA7IGstLSkge1xuICAgICAgICAgICAgICAgIGkgPSBwbG90LnNlcmllc1N0YWNrW2tdO1xuICAgICAgICAgICAgICAgIHMgPSBzZXJpZXNbaV07XG4gICAgICAgICAgICAgICAgaHAgPSBzLl9oaWdobGlnaHRUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzLnJlbmRlcmVyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJC5qcXBsb3QuQmFyUmVuZGVyZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZ3JpZHBvcy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGdyaWRwb3MueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqPHMuX2JhclBvaW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHMuX2JhclBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcy5ncmlkRGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeD5wb2ludHNbMF1bMF0gJiYgeDxwb2ludHNbMl1bMF0gJiYgKHk+cG9pbnRzWzJdWzFdICYmIHk8cG9pbnRzWzBdWzFdIHx8IHk8cG9pbnRzWzJdWzFdICYmIHk+cG9pbnRzWzBdWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OnMuaW5kZXgsIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6cCwgZGF0YTpzLmRhdGFbal0sIHBvaW50czpzLl9iYXJQb2ludHNbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICQuanFwbG90LlB5cmFtaWRSZW5kZXJlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBncmlkcG9zLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZHBvcy55O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8cy5fYmFyUG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gcy5fYmFyUG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzLmdyaWREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID4gcG9pbnRzWzBdWzBdICsgaHBbMF1bMF0gJiYgeCA8IHBvaW50c1syXVswXSArIGhwWzJdWzBdICYmIHkgPiBwb2ludHNbMl1bMV0gJiYgeSA8IHBvaW50c1swXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OnMuaW5kZXgsIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6cCwgZGF0YTpzLmRhdGFbal0sIHBvaW50czpzLl9iYXJQb2ludHNbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAkLmpxcGxvdC5Eb251dFJlbmRlcmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2EgPSBzLnN0YXJ0QW5nbGUvMTgwKk1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZ3JpZHBvcy54IC0gcy5fY2VudGVyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGdyaWRwb3MueSAtIHMuX2NlbnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IDAgJiYgLXkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhID0gMipNYXRoLlBJIC0gTWF0aC5hdGFuKC15L3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA+IDAgJiYgLXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgPSAtTWF0aC5hdGFuKC15L3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IE1hdGguUEkgLSBNYXRoLmF0YW4oLXkveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID09IDAgJiYgLXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgPSAzKk1hdGguUEkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT0gMCAmJiAteSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IE1hdGguUEkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT0gMCAmJiB5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSAtPSBzYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhICs9IDIqTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhldGEgPiAyKk1hdGguUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgLT0gMipNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgc20gPSBzLnNsaWNlTWFyZ2luLzE4MCpNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCBzLl9yYWRpdXMgJiYgciA+IHMuX2lubmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8cy5ncmlkRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5hbmcgPSAoaj4wKSA/IHMuZ3JpZERhdGFbai0xXVsxXStzbSA6IHNtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhhbmcgPSBzLmdyaWREYXRhW2pdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhldGEgPiBtaW5hbmcgJiYgdGhldGEgPCBtYXhhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c2VyaWVzSW5kZXg6cy5pbmRleCwgcG9pbnRJbmRleDpqLCBncmlkRGF0YTpbZ3JpZHBvcy54LGdyaWRwb3MueV0sIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJC5qcXBsb3QuUGllUmVuZGVyZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzYSA9IHMuc3RhcnRBbmdsZS8xODAqTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBncmlkcG9zLnggLSBzLl9jZW50ZXJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZHBvcy55IC0gcy5fY2VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID4gMCAmJiAteSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgPSAyKk1hdGguUEkgLSBNYXRoLmF0YW4oLXkveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID4gMCAmJiAteSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IC1NYXRoLmF0YW4oLXkveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhID0gTWF0aC5QSSAtIE1hdGguYXRhbigteS94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT0gMCAmJiAteSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IDMqTWF0aC5QSS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA9PSAwICYmIC15IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhID0gTWF0aC5QSS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA9PSAwICYmIHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhIC09IHNhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgKz0gMipNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGV0YSA+IDIqTWF0aC5QSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSAtPSAyKk1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzbSA9IHMuc2xpY2VNYXJnaW4vMTgwKk1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA8IHMuX3JhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqPHMuZ3JpZERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluYW5nID0gKGo+MCkgPyBzLmdyaWREYXRhW2otMV1bMV0rc20gOiBzbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4YW5nID0gcy5ncmlkRGF0YVtqXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoZXRhID4gbWluYW5nICYmIHRoZXRhIDwgbWF4YW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OnMuaW5kZXgsIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6W2dyaWRwb3MueCxncmlkcG9zLnldLCBkYXRhOnMuZGF0YVtqXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlICQuanFwbG90LkJ1YmJsZVJlbmRlcmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGdyaWRwb3MueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBncmlkcG9zLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxzLmdyaWREYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzLmdyaWREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5zcXJ0KCAoeC1wWzBdKSAqICh4LXBbMF0pICsgKHktcFsxXSkgKiAoeS1wWzFdKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8PSBwWzJdICYmIChkIDw9IGQwIHx8IGQwID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0ge3Nlcmllc0luZGV4OiBpLCBwb2ludEluZGV4OmosIGdyaWREYXRhOnAsIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlICQuanFwbG90LkZ1bm5lbFJlbmRlcmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGdyaWRwb3MueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBncmlkcG9zLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHMuX3ZlcnRpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZmaXJzdCA9IHZbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmxhc3QgPSB2W3YubGVuZ3RoLTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Y7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcXVhdGlvbnMgb2YgcmlnaHQgYW5kIGxlZnQgc2lkZXMsIHJldHVybnMgeCwgeSB2YWx1ZXMgZ2l2ZW4gaGVpZ2h0IG9mIHNlY3Rpb24gKHkgdmFsdWUgYW5kIDIgcG9pbnRzKVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZGVkZ2UgKGwsIHAxICwgcDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IChwMVsxXSAtIHAyWzFdKS8ocDFbMF0gLSBwMlswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBwMVsxXSAtIG0qcDFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBsICsgcDFbMV07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbKHkgLSBiKS9tLCB5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV4ID0gZmluZGVkZ2UoeSwgdmZpcnN0WzBdLCB2bGFzdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXggPSBmaW5kZWRnZSh5LCB2Zmlyc3RbMV0sIHZsYXN0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqPHYubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdiA9IHZbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPj0gY3ZbMF1bMV0gJiYgeSA8PSBjdlszXVsxXSAmJiB4ID49IGxleFswXSAmJiB4IDw9IHJleFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OnMuaW5kZXgsIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6bnVsbCwgZGF0YTpzLmRhdGFbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlICQuanFwbG90LkxpbmVSZW5kZXJlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBncmlkcG9zLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZHBvcy55O1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzLmZpbGwgfHwgKHMucmVuZGVyZXIuYmFuZHMuc2hvdyAmJiBzLnJlbmRlcmVyLmJhbmRzLmZpbGwpKSAmJiAoIXBsb3QucGx1Z2lucy5oaWdobGlnaHRlciB8fCAhcGxvdC5wbHVnaW5zLmhpZ2hsaWdodGVyLnNob3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIGl0IGlzIGluIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4PnMuX2JvdW5kaW5nQm94WzBdWzBdICYmIHg8cy5fYm91bmRpbmdCb3hbMV1bMF0gJiYgeT5zLl9ib3VuZGluZ0JveFsxXVsxXSAmJiB5PHMuX2JvdW5kaW5nQm94WzBdWzFdKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGNoZWNrIHRoZSBjcm9zc2luZyBudW1iZXIgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bVBvaW50cyA9IHMuX2FyZWFQb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBudW1Qb2ludHMtMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpaT0wOyBpaSA8IG51bVBvaW50czsgaWkrKykgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4MSA9IFtzLl9hcmVhUG9pbnRzW2lpXVswXSwgcy5fYXJlYVBvaW50c1tpaV1bMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXgyID0gW3MuX2FyZWFQb2ludHNbal1bMF0sIHMuX2FyZWFQb2ludHNbal1bMV1dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleDFbMV0gPCB5ICYmIHZlcnRleDJbMV0gPj0geSB8fCB2ZXJ0ZXgyWzFdIDwgeSAmJiB2ZXJ0ZXgxWzFdID49IHkpICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXgxWzBdICsgKHkgLSB2ZXJ0ZXgxWzFdKSAvICh2ZXJ0ZXgyWzFdIC0gdmVydGV4MVsxXSkgKiAodmVydGV4MlswXSAtIHZlcnRleDFbMF0pIDwgeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c2VyaWVzSW5kZXg6aSwgcG9pbnRJbmRleDpudWxsLCBncmlkRGF0YTpzLmdyaWREYXRhLCBkYXRhOnMuZGF0YSwgcG9pbnRzOnMuX2FyZWFQb2ludHN9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHMubWFya2VyUmVuZGVyZXIuc2l6ZS8yK3MubmVpZ2hib3JUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9ICh0ID4gMCkgPyB0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHMuZ3JpZERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzLmdyaWREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVpZ2hib3IgbG9va3MgZGlmZmVyZW50IHRvIE9ITEMgY2hhcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb25zdHJ1Y3RvciA9PSAkLmpxcGxvdC5PSExDUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jYW5kbGVTdGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeXAgPSBzLl95YXhpcy5zZXJpZXNfdTJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSBwWzBdLXIuX2JvZHlXaWR0aC8yICYmIHggPD0gcFswXStyLl9ib2R5V2lkdGgvMiAmJiB5ID49IHlwKHMuZGF0YVtqXVsyXSkgJiYgeSA8PSB5cChzLmRhdGFbal1bM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OiBpLCBwb2ludEluZGV4OmosIGdyaWREYXRhOnAsIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbiBvcGVuIGhpIGxvdyBjbG9zZSBjaGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyLmhsYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5cCA9IHMuX3lheGlzLnNlcmllc191MnA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IHBbMF0tci5fdGlja0xlbmd0aCAmJiB4IDw9IHBbMF0rci5fdGlja0xlbmd0aCAmJiB5ID49IHlwKHMuZGF0YVtqXVsyXSkgJiYgeSA8PSB5cChzLmRhdGFbal1bM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OiBpLCBwb2ludEluZGV4OmosIGdyaWREYXRhOnAsIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhpIGxvdyBjbG9zZSBjaGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeXAgPSBzLl95YXhpcy5zZXJpZXNfdTJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSBwWzBdLXIuX3RpY2tMZW5ndGggJiYgeCA8PSBwWzBdK3IuX3RpY2tMZW5ndGggJiYgeSA+PSB5cChzLmRhdGFbal1bMV0pICYmIHkgPD0geXAocy5kYXRhW2pdWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzZXJpZXNJbmRleDogaSwgcG9pbnRJbmRleDpqLCBncmlkRGF0YTpwLCBkYXRhOnMuZGF0YVtqXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwWzBdICE9IG51bGwgJiYgcFsxXSAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5zcXJ0KCAoeC1wWzBdKSAqICh4LXBbMF0pICsgKHktcFsxXSkgKiAoeS1wWzFdKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDw9IHRocmVzaG9sZCAmJiAoZCA8PSBkMCB8fCBkMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OiBpLCBwb2ludEluZGV4OmosIGdyaWREYXRhOnAsIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBncmlkcG9zLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZHBvcy55O1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHMubWFya2VyUmVuZGVyZXIuc2l6ZS8yK3MubmVpZ2hib3JUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gKHQgPiAwKSA/IHQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxzLmdyaWREYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzLmdyaWREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWlnaGJvciBsb29rcyBkaWZmZXJlbnQgdG8gT0hMQyBjaGFydC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuT0hMQ1JlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jYW5kbGVTdGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5cCA9IHMuX3lheGlzLnNlcmllc191MnA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gcFswXS1yLl9ib2R5V2lkdGgvMiAmJiB4IDw9IHBbMF0rci5fYm9keVdpZHRoLzIgJiYgeSA+PSB5cChzLmRhdGFbal1bMl0pICYmIHkgPD0geXAocy5kYXRhW2pdWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Nlcmllc0luZGV4OiBpLCBwb2ludEluZGV4OmosIGdyaWREYXRhOnAsIGRhdGE6cy5kYXRhW2pdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbiBvcGVuIGhpIGxvdyBjbG9zZSBjaGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXIuaGxjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeXAgPSBzLl95YXhpcy5zZXJpZXNfdTJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IHBbMF0tci5fdGlja0xlbmd0aCAmJiB4IDw9IHBbMF0rci5fdGlja0xlbmd0aCAmJiB5ID49IHlwKHMuZGF0YVtqXVsyXSkgJiYgeSA8PSB5cChzLmRhdGFbal1bM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c2VyaWVzSW5kZXg6IGksIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6cCwgZGF0YTpzLmRhdGFbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgaGkgbG93IGNsb3NlIGNoYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeXAgPSBzLl95YXhpcy5zZXJpZXNfdTJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IHBbMF0tci5fdGlja0xlbmd0aCAmJiB4IDw9IHBbMF0rci5fdGlja0xlbmd0aCAmJiB5ID49IHlwKHMuZGF0YVtqXVsxXSkgJiYgeSA8PSB5cChzLmRhdGFbal1bMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c2VyaWVzSW5kZXg6IGksIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6cCwgZGF0YTpzLmRhdGFbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBNYXRoLnNxcnQoICh4LXBbMF0pICogKHgtcFswXSkgKyAoeS1wWzFdKSAqICh5LXBbMV0pICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8PSB0aHJlc2hvbGQgJiYgKGQgPD0gZDAgfHwgZDAgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c2VyaWVzSW5kZXg6IGksIHBvaW50SW5kZXg6aiwgZ3JpZERhdGE6cCwgZGF0YTpzLmRhdGFbal19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IHBhc3NlZCBpbiBpcyBub3JtYWxpemVkIGFuZCB3aWxsIGhhdmUgZGF0YSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAvLyBFdmVudCBwYXNzZWQgb3V0IGlzIHVubm9ybWFsaXplZC5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZXRFdmVudFBvc2l0aW9uKGV2KTtcbiAgICAgICAgICAgIHZhciBwID0gZXYuZGF0YS5wbG90O1xuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gY2hlY2tJbnRlcnNlY3Rpb24ocG9zaXRpb25zLmdyaWRQb3MsIHApO1xuICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoJ2pxcGxvdENsaWNrJyk7XG4gICAgICAgICAgICBldnQucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIGV2dC5wYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKGV2dCwgW3Bvc2l0aW9ucy5ncmlkUG9zLCBwb3NpdGlvbnMuZGF0YVBvcywgbmVpZ2hib3IsIHBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub25EYmxDbGljayA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAvLyBFdmVudCBwYXNzZWQgaW4gaXMgbm9ybWFsaXplZCBhbmQgd2lsbCBoYXZlIGRhdGEgYXR0cmlidXRlLlxuICAgICAgICAgICAgLy8gRXZlbnQgcGFzc2VkIG91dCBpcyB1bm5vcm1hbGl6ZWQuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2V0RXZlbnRQb3NpdGlvbihldik7XG4gICAgICAgICAgICB2YXIgcCA9IGV2LmRhdGEucGxvdDtcbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IGNoZWNrSW50ZXJzZWN0aW9uKHBvc2l0aW9ucy5ncmlkUG9zLCBwKTtcbiAgICAgICAgICAgIHZhciBldnQgPSAkLkV2ZW50KCdqcXBsb3REYmxDbGljaycpO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcihldnQsIFtwb3NpdGlvbnMuZ3JpZFBvcywgcG9zaXRpb25zLmRhdGFQb3MsIG5laWdoYm9yLCBwXSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZXRFdmVudFBvc2l0aW9uKGV2KTtcbiAgICAgICAgICAgIHZhciBwID0gZXYuZGF0YS5wbG90O1xuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gY2hlY2tJbnRlcnNlY3Rpb24ocG9zaXRpb25zLmdyaWRQb3MsIHApO1xuICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoJ2pxcGxvdE1vdXNlRG93bicpO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcihldnQsIFtwb3NpdGlvbnMuZ3JpZFBvcywgcG9zaXRpb25zLmRhdGFQb3MsIG5laWdoYm9yLCBwXSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2V0RXZlbnRQb3NpdGlvbihldik7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gJC5FdmVudCgnanFwbG90TW91c2VVcCcpO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcihldnQsIFtwb3NpdGlvbnMuZ3JpZFBvcywgcG9zaXRpb25zLmRhdGFQb3MsIG51bGwsIGV2LmRhdGEucGxvdF0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vblJpZ2h0Q2xpY2sgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdldEV2ZW50UG9zaXRpb24oZXYpO1xuICAgICAgICAgICAgdmFyIHAgPSBldi5kYXRhLnBsb3Q7XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3IgPSBjaGVja0ludGVyc2VjdGlvbihwb3NpdGlvbnMuZ3JpZFBvcywgcCk7XG4gICAgICAgICAgICBpZiAocC5jYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgICAgICAgICAgIGlmIChldi53aGljaCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoJ2pxcGxvdFJpZ2h0Q2xpY2snKTtcbiAgICAgICAgICAgICAgICBldnQucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKGV2dCwgW3Bvc2l0aW9ucy5ncmlkUG9zLCBwb3NpdGlvbnMuZGF0YVBvcywgbmVpZ2hib3IsIHBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoJ2pxcGxvdE1vdXNlVXAnKTtcbiAgICAgICAgICAgICAgICBldnQucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKGV2dCwgW3Bvc2l0aW9ucy5ncmlkUG9zLCBwb3NpdGlvbnMuZGF0YVBvcywgbmVpZ2hib3IsIHBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZXRFdmVudFBvc2l0aW9uKGV2KTtcbiAgICAgICAgICAgIHZhciBwID0gZXYuZGF0YS5wbG90O1xuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gY2hlY2tJbnRlcnNlY3Rpb24ocG9zaXRpb25zLmdyaWRQb3MsIHApO1xuICAgICAgICAgICAgdmFyIGV2dCA9ICQuRXZlbnQoJ2pxcGxvdE1vdXNlTW92ZScpO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcihldnQsIFtwb3NpdGlvbnMuZ3JpZFBvcywgcG9zaXRpb25zLmRhdGFQb3MsIG5laWdoYm9yLCBwXSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2V0RXZlbnRQb3NpdGlvbihldik7XG4gICAgICAgICAgICB2YXIgcCA9IGV2LmRhdGEucGxvdDtcbiAgICAgICAgICAgIHZhciBldnQgPSAkLkV2ZW50KCdqcXBsb3RNb3VzZUVudGVyJyk7XG4gICAgICAgICAgICBldnQucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIGV2dC5wYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICAgICAgZXZ0LnJlbGF0ZWRUYXJnZXQgPSBldi5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKGV2dCwgW3Bvc2l0aW9ucy5ncmlkUG9zLCBwb3NpdGlvbnMuZGF0YVBvcywgbnVsbCwgcF0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdldEV2ZW50UG9zaXRpb24oZXYpO1xuICAgICAgICAgICAgdmFyIHAgPSBldi5kYXRhLnBsb3Q7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gJC5FdmVudCgnanFwbG90TW91c2VMZWF2ZScpO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIGV2dC5yZWxhdGVkVGFyZ2V0ID0gZXYucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcihldnQsIFtwb3NpdGlvbnMuZ3JpZFBvcywgcG9zaXRpb25zLmRhdGFQb3MsIG51bGwsIHBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1ldGhvZDogZHJhd1Nlcmllc1xuICAgICAgICAvLyBSZWRyYXdzIGFsbCBvciBqdXN0IG9uZSBzZXJpZXMgb24gdGhlIHBsb3QuICBObyBheGlzIHNjYWxpbmdcbiAgICAgICAgLy8gaXMgcGVyZm9ybWVkIGFuZCBubyBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGxvdCBhcmUgcmVkcmF3bi5cbiAgICAgICAgLy8gb3B0aW9ucyBpcyBhbiBvcHRpb25zIG9iamVjdCB0byBwYXNzIG9uIHRvIHRoZSBzZXJpZXMgcmVuZGVyZXJzLlxuICAgICAgICAvLyBJdCBjYW4gYmUgYW4gZW1wdHkgb2JqZWN0IHt9LiAgaWR4IGlzIHRoZSBzZXJpZXMgaW5kZXhcbiAgICAgICAgLy8gdG8gcmVkcmF3IGlmIG9ubHkgb25lIHNlcmllcyBpcyB0byBiZSByZWRyYXduLlxuICAgICAgICB0aGlzLmRyYXdTZXJpZXMgPSBmdW5jdGlvbihvcHRpb25zLCBpZHgpe1xuICAgICAgICAgICAgdmFyIGksIHNlcmllcywgY3R4O1xuICAgICAgICAgICAgLy8gaWYgb25seSBvbmUgYXJndW1lbnQgcGFzc2VkIGluIGFuZCBpdCBpcyBhIG51bWJlciwgdXNlIGl0IGFkIGlkeC5cbiAgICAgICAgICAgIGlkeCA9ICh0eXBlb2Yob3B0aW9ucykgPT09IFwibnVtYmVyXCIgJiYgaWR4ID09IG51bGwpID8gb3B0aW9ucyA6IGlkeDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSAodHlwZW9mKG9wdGlvbnMpID09PSBcIm9iamVjdFwiKSA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIC8vIGRyYXcgc3BlY2lmaWVkIHNlcmllc1xuICAgICAgICAgICAgaWYgKGlkeCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMgPSB0aGlzLnNlcmllc1tpZHhdO1xuICAgICAgICAgICAgICAgIGN0eCA9IHNlcmllcy5zaGFkb3dDYW52YXMuX2N0eDtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuZHJhd1NoYWRvdyhjdHgsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGN0eCA9IHNlcmllcy5jYW52YXMuX2N0eDtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuZHJhdyhjdHgsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMucmVuZGVyZXIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuQmV6aWVyQ3VydmVSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgdGhpcy5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U2VyaWVzKGlkeCsxKTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIGNhbGwgc2VyaWVzIGRyYXdTaGFkb3cgbWV0aG9kIGZpcnN0LCBpbiBjYXNlIGFsbCBzZXJpZXMgc2hhZG93c1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBkcmF3biBiZWZvcmUgYW55IHNlcmllcy4gIFRoaXMgd2lsbCBlbnN1cmUsIGxpa2UgZm9yIFxuICAgICAgICAgICAgICAgIC8vIHN0YWNrZWQgYmFyIHBsb3RzLCB0aGF0IHNoYWRvd3MgZG9uJ3Qgb3ZlcmxhcCBzZXJpZXMuXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dGhpcy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMgPSB0aGlzLnNlcmllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gc2VyaWVzLnNoYWRvd0NhbnZhcy5fY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRyYXdTaGFkb3coY3R4LCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gc2VyaWVzLmNhbnZhcy5fY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRyYXcoY3R4LCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gaWR4ID0gaSA9IHNlcmllcyA9IGN0eCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBtZXRob2Q6IG1vdmVTZXJpZXNUb0Zyb250XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGpRdWVyeSAxLjQrXG4gICAgICAgIC8vIE1vdmVzIHRoZSBzcGVjaWZpZWQgc2VyaWVzIGNhbnZhcyBpbiBmcm9udCBvZiBhbGwgb3RoZXIgc2VyaWVzIGNhbnZhc2VzLlxuICAgICAgICAvLyBUaGlzIGVmZmVjdGl2ZWx5IFwiZHJhd3NcIiB0aGUgc3BlY2lmaWVkIHNlcmllcyBvbiB0b3Agb2YgYWxsIG90aGVyIHNlcmllcyxcbiAgICAgICAgLy8gYWx0aG91Z2ggaXQgaXMgcGVyZm9ybWVkIHRocm91Z2ggRE9NIG1hbmlwdWxhdGlvbiwgbm8gcmVkcmF3aW5nIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFyYW1ldGVyczpcbiAgICAgICAgLy8gaWR4IC0gMCBiYXNlZCBpbmRleCBvZiB0aGUgc2VyaWVzIHRvIG1vdmUuICBUaGlzIHdpbGwgYmUgdGhlIGluZGV4IG9mIHRoZSBzZXJpZXNcbiAgICAgICAgLy8gYXMgaXQgd2FzIGZpcnN0IHBhc3NlZCBpbnRvIHRoZSBqcXBsb3QgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMubW92ZVNlcmllc1RvRnJvbnQgPSBmdW5jdGlvbiAoaWR4KSB7IFxuICAgICAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4LCAxMCk7XG4gICAgICAgICAgICB2YXIgc3RhY2tJbmRleCA9ICQuaW5BcnJheShpZHgsIHRoaXMuc2VyaWVzU3RhY2spO1xuICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBpbiBmcm9udCwgcmV0dXJuXG4gICAgICAgICAgICBpZiAoc3RhY2tJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja0luZGV4ID09IHRoaXMuc2VyaWVzU3RhY2subGVuZ3RoIC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Nlcmllc1N0YWNrID0gdGhpcy5zZXJpZXNTdGFjay5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3BpZHggPSB0aGlzLnNlcmllc1N0YWNrW3RoaXMuc2VyaWVzU3RhY2subGVuZ3RoIC0xXTtcbiAgICAgICAgICAgIHZhciBzZXJlbGVtID0gdGhpcy5zZXJpZXNbaWR4XS5jYW52YXMuX2VsZW0uZGV0YWNoKCk7XG4gICAgICAgICAgICB2YXIgc2hhZGVsZW0gPSB0aGlzLnNlcmllc1tpZHhdLnNoYWRvd0NhbnZhcy5fZWxlbS5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzW29waWR4XS5zaGFkb3dDYW52YXMuX2VsZW0uYWZ0ZXIoc2hhZGVsZW0pO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNbb3BpZHhdLmNhbnZhcy5fZWxlbS5hZnRlcihzZXJlbGVtKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJpZXNTdGFjayA9IHRoaXMuc2VyaWVzU3RhY2suc2xpY2UoMCk7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1N0YWNrLnNwbGljZShzdGFja0luZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzU3RhY2sucHVzaChpZHgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gbWV0aG9kOiBtb3ZlU2VyaWVzVG9CYWNrXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGpRdWVyeSAxLjQrXG4gICAgICAgIC8vIE1vdmVzIHRoZSBzcGVjaWZpZWQgc2VyaWVzIGNhbnZhcyBiZWhpbmQgYWxsIG90aGVyIHNlcmllcyBjYW52YXNlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFyYW1ldGVyczpcbiAgICAgICAgLy8gaWR4IC0gMCBiYXNlZCBpbmRleCBvZiB0aGUgc2VyaWVzIHRvIG1vdmUuICBUaGlzIHdpbGwgYmUgdGhlIGluZGV4IG9mIHRoZSBzZXJpZXNcbiAgICAgICAgLy8gYXMgaXQgd2FzIGZpcnN0IHBhc3NlZCBpbnRvIHRoZSBqcXBsb3QgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMubW92ZVNlcmllc1RvQmFjayA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCwgMTApO1xuICAgICAgICAgICAgdmFyIHN0YWNrSW5kZXggPSAkLmluQXJyYXkoaWR4LCB0aGlzLnNlcmllc1N0YWNrKTtcbiAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgaW4gYmFjaywgcmV0dXJuXG4gICAgICAgICAgICBpZiAoc3RhY2tJbmRleCA9PSAwIHx8IHN0YWNrSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3BpZHggPSB0aGlzLnNlcmllc1N0YWNrWzBdO1xuICAgICAgICAgICAgdmFyIHNlcmVsZW0gPSB0aGlzLnNlcmllc1tpZHhdLmNhbnZhcy5fZWxlbS5kZXRhY2goKTtcbiAgICAgICAgICAgIHZhciBzaGFkZWxlbSA9IHRoaXMuc2VyaWVzW2lkeF0uc2hhZG93Q2FudmFzLl9lbGVtLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNbb3BpZHhdLnNoYWRvd0NhbnZhcy5fZWxlbS5iZWZvcmUoc2hhZGVsZW0pO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNbb3BpZHhdLmNhbnZhcy5fZWxlbS5iZWZvcmUoc2VyZWxlbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VyaWVzU3RhY2sgPSB0aGlzLnNlcmllc1N0YWNrLnNsaWNlKDApO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNTdGFjay5zcGxpY2Uoc3RhY2tJbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1N0YWNrLnVuc2hpZnQoaWR4KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1ldGhvZDogcmVzdG9yZVByZXZpb3VzU2VyaWVzT3JkZXJcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgcmVxdWlyZXMgalF1ZXJ5IDEuNCtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgc2VyaWVzIGNhbnZhcyBvcmRlciB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgIC8vIFVzZWZ1bCB0byBwdXQgYSBzZXJpZXMgYmFjayB3aGVyZSBpdCBiZWxvbmdzIGFmdGVyIG1vdmluZ1xuICAgICAgICAvLyBpdCB0byB0aGUgZnJvbnQuXG4gICAgICAgIHRoaXMucmVzdG9yZVByZXZpb3VzU2VyaWVzT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgc2VyZWxlbSwgc2hhZGVsZW0sIHRlbXAsIG1vdmUsIGtlZXA7XG4gICAgICAgICAgICAvLyBpZiBubyBjaGFuZ2UsIHJldHVybi5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcmllc1N0YWNrID09IHRoaXMucHJldmlvdXNTZXJpZXNTdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaT0xOyBpPHRoaXMucHJldmlvdXNTZXJpZXNTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmUgPSB0aGlzLnByZXZpb3VzU2VyaWVzU3RhY2tbaV07XG4gICAgICAgICAgICAgICAga2VlcCA9IHRoaXMucHJldmlvdXNTZXJpZXNTdGFja1tpLTFdO1xuICAgICAgICAgICAgICAgIHNlcmVsZW0gPSB0aGlzLnNlcmllc1ttb3ZlXS5jYW52YXMuX2VsZW0uZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgc2hhZGVsZW0gPSB0aGlzLnNlcmllc1ttb3ZlXS5zaGFkb3dDYW52YXMuX2VsZW0uZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNba2VlcF0uc2hhZG93Q2FudmFzLl9lbGVtLmFmdGVyKHNoYWRlbGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc1trZWVwXS5jYW52YXMuX2VsZW0uYWZ0ZXIoc2VyZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wID0gdGhpcy5zZXJpZXNTdGFjay5zbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzU3RhY2sgPSB0aGlzLnByZXZpb3VzU2VyaWVzU3RhY2suc2xpY2UoMCk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VyaWVzU3RhY2sgPSB0ZW1wO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gbWV0aG9kOiByZXN0b3JlT3JpZ2luYWxTZXJpZXNPcmRlclxuICAgICAgICAvLyBUaGlzIG1ldGhvZCByZXF1aXJlcyBqUXVlcnkgMS40K1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBzZXJpZXMgY2FudmFzIG9yZGVyIHRvIGl0cyBvcmlnaW5hbCBvcmRlclxuICAgICAgICAvLyB3aGVuIHRoZSBwbG90IHdhcyBjcmVhdGVkLlxuICAgICAgICB0aGlzLnJlc3RvcmVPcmlnaW5hbFNlcmllc09yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGosIGFycj1bXSwgc2VyZWxlbSwgc2hhZGVsZW07XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWVzU3RhY2sgPT0gYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Nlcmllc1N0YWNrID0gdGhpcy5zZXJpZXNTdGFjay5zbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzU3RhY2sgPSBhcnI7XG4gICAgICAgICAgICBmb3IgKGk9MTsgaTx0aGlzLnNlcmllc1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VyZWxlbSA9IHRoaXMuc2VyaWVzW2ldLmNhbnZhcy5fZWxlbS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICBzaGFkZWxlbSA9IHRoaXMuc2VyaWVzW2ldLnNoYWRvd0NhbnZhcy5fZWxlbS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc1tpLTFdLnNoYWRvd0NhbnZhcy5fZWxlbS5hZnRlcihzaGFkZWxlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNbaS0xXS5jYW52YXMuX2VsZW0uYWZ0ZXIoc2VyZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmFjdGl2YXRlVGhlbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50aGVtZUVuZ2luZS5hY3RpdmF0ZSh0aGlzLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gY29ucHV0ZSBhIGhpZ2hsaWdodCBjb2xvciBvciBhcnJheSBvZiBoaWdobGlnaHQgY29sb3JzIGZyb20gZ2l2ZW4gY29sb3JzLlxuICAgICQuanFwbG90LmNvbXB1dGVIaWdobGlnaHRDb2xvcnMgID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmICgkLmlzQXJyYXkoY29sb3JzKSkge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y29sb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgcmdiYSA9ICQuanFwbG90LmdldENvbG9yQ29tcG9uZW50cyhjb2xvcnNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdyZ2IgPSBbcmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXV07XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IG5ld3JnYlswXSArIG5ld3JnYlsxXSArIG5ld3JnYlsyXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8MzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gZGFya2VuaW5nLCBsb3dlc3QgY29sb3IgY29tcG9uZW50IGNhbiBiZSBpcyA2MC5cbiAgICAgICAgICAgICAgICAgICAgbmV3cmdiW2pdID0gKHN1bSA+IDY2MCkgPyAgbmV3cmdiW2pdICogMC44NSA6IDAuNzMgKiBuZXdyZ2Jbal0gKyA5MDtcbiAgICAgICAgICAgICAgICAgICAgbmV3cmdiW2pdID0gcGFyc2VJbnQobmV3cmdiW2pdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIChuZXdyZ2Jbal0gPiAyNTUpID8gMjU1IDogbmV3cmdiW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBuZXdyZ2JbM10gPSAocmdiYVszXSA+IDAuNCkgPyByZ2JhWzNdICogMC40IDogcmdiYVszXSAqIDEuNTtcbiAgICAgICAgICAgICAgICAvLyBuZXdyZ2JbM10gPSAocmdiYVszXSA+IDAuNSkgPyAwLjggKiByZ2JhWzNdIC0gLjEgOiByZ2JhWzNdICsgMC4yO1xuICAgICAgICAgICAgICAgIG5ld3JnYlszXSA9IDAuMyArIDAuMzUgKiByZ2JhWzNdO1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKCdyZ2JhKCcrbmV3cmdiWzBdKycsJytuZXdyZ2JbMV0rJywnK25ld3JnYlsyXSsnLCcrbmV3cmdiWzNdKycpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmdiYSA9ICQuanFwbG90LmdldENvbG9yQ29tcG9uZW50cyhjb2xvcnMpO1xuICAgICAgICAgICAgdmFyIG5ld3JnYiA9IFtyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdXTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBuZXdyZ2JbMF0gKyBuZXdyZ2JbMV0gKyBuZXdyZ2JbMl07XG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8MzsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBkYXJrZW5pbmcsIGxvd2VzdCBjb2xvciBjb21wb25lbnQgY2FuIGJlIGlzIDYwLlxuICAgICAgICAgICAgICAgIC8vIG5ld3JnYltqXSA9IChzdW0gPiA1NzApID8gIG5ld3JnYltqXSAqIDAuOCA6IG5ld3JnYltqXSArIDAuMyAqICgyNTUgLSBuZXdyZ2Jbal0pO1xuICAgICAgICAgICAgICAgIC8vIG5ld3JnYltqXSA9IHBhcnNlSW50KG5ld3JnYltqXSwgMTApO1xuICAgICAgICAgICAgICAgIG5ld3JnYltqXSA9IChzdW0gPiA2NjApID8gIG5ld3JnYltqXSAqIDAuODUgOiAwLjczICogbmV3cmdiW2pdICsgOTA7XG4gICAgICAgICAgICAgICAgbmV3cmdiW2pdID0gcGFyc2VJbnQobmV3cmdiW2pdLCAxMCk7XG4gICAgICAgICAgICAgICAgKG5ld3JnYltqXSA+IDI1NSkgPyAyNTUgOiBuZXdyZ2Jbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXdyZ2JbM10gPSAocmdiYVszXSA+IDAuNCkgPyByZ2JhWzNdICogMC40IDogcmdiYVszXSAqIDEuNTtcbiAgICAgICAgICAgIC8vIG5ld3JnYlszXSA9IChyZ2JhWzNdID4gMC41KSA/IDAuOCAqIHJnYmFbM10gLSAuMSA6IHJnYmFbM10gKyAwLjI7XG4gICAgICAgICAgICBuZXdyZ2JbM10gPSAwLjMgKyAwLjM1ICogcmdiYVszXTtcbiAgICAgICAgICAgIHJldCA9ICdyZ2JhKCcrbmV3cmdiWzBdKycsJytuZXdyZ2JbMV0rJywnK25ld3JnYlsyXSsnLCcrbmV3cmdiWzNdKycpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgICAgIFxuICAgJC5qcXBsb3QuQ29sb3JHZW5lcmF0b3IgPSBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICAgICAgY29sb3JzID0gY29sb3JzIHx8ICQuanFwbG90LmNvbmZpZy5kZWZhdWx0Q29sb3JzO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubmV4dCA9IGZ1bmN0aW9uICgpIHsgXG4gICAgICAgICAgICBpZiAoaWR4IDwgY29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcnNbaWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzW2lkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7IFxuICAgICAgICAgICAgaWYgKGlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzW2lkeC0tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkeCA9IGNvbG9ycy5sZW5ndGgtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBnZXQgYSBjb2xvciBieSBpbmRleCB3aXRob3V0IGFkdmFuY2luZyBwb2ludGVyLlxuICAgICAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBpIC0gY29sb3JzLmxlbmd0aCAqIE1hdGguZmxvb3IoaS9jb2xvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNbaWR4XTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgY29sb3JzID0gYztcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGlkeCA9IGluZGV4O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBjb252ZXJ0IGEgaGV4IGNvbG9yIHN0cmluZyB0byByZ2Igc3RyaW5nLlxuICAgIC8vIGggLSAzIG9yIDYgY2hhcmFjdGVyIGhleCBzdHJpbmcsIHdpdGggb3Igd2l0aG91dCBsZWFkaW5nICNcbiAgICAvLyBhIC0gb3B0aW9uYWwgYWxwaGFcbiAgICAkLmpxcGxvdC5oZXgycmdiID0gZnVuY3Rpb24oaCwgYSkge1xuICAgICAgICBoID0gaC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICBpZiAoaC5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgaCA9IGguY2hhckF0KDApK2guY2hhckF0KDApK2guY2hhckF0KDEpK2guY2hhckF0KDEpK2guY2hhckF0KDIpK2guY2hhckF0KDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZ2I7XG4gICAgICAgIHJnYiA9ICdyZ2JhKCcrcGFyc2VJbnQoaC5zbGljZSgwLDIpLCAxNikrJywgJytwYXJzZUludChoLnNsaWNlKDIsNCksIDE2KSsnLCAnK3BhcnNlSW50KGguc2xpY2UoNCw2KSwgMTYpO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgcmdiICs9ICcsICcrYTtcbiAgICAgICAgfVxuICAgICAgICByZ2IgKz0gJyknO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH07XG4gICAgXG4gICAgLy8gY29udmVydCBhbiByZ2IgY29sb3Igc3BlYyB0byBhIGhleCBzcGVjLiAgaWdub3JlIGFueSBhbHBoYSBzcGVjaWZpY2F0aW9uLlxuICAgICQuanFwbG90LnJnYjJoZXggPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBwYXQgPSAvcmdiYT9cXCggKihbMC05XXsxLDN9XFwuP1swLTldKiU/KSAqLCAqKFswLTldezEsM31cXC4/WzAtOV0qJT8pICosICooWzAtOV17MSwzfVxcLj9bMC05XSolPykgKig/OiwgKlswLTkuXSopP1xcKS87XG4gICAgICAgIHZhciBtID0gcy5tYXRjaChwYXQpO1xuICAgICAgICB2YXIgaCA9ICcjJztcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPDQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICBpZiAobVtpXS5zZWFyY2goLyUvKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBwYXJzZUludCgyNTUqbVtpXS8xMDAsIDEwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9ICcwJyt0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBwYXJzZUludChtW2ldLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSAnMCcrdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoICs9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBcbiAgICAvLyBnaXZlbiBhIGNzcyBjb2xvciBzcGVjLCByZXR1cm4gYW4gcmdiIGNzcyBjb2xvciBzcGVjXG4gICAgJC5qcXBsb3Qubm9ybWFsaXplMnJnYiA9IGZ1bmN0aW9uKHMsIGEpIHtcbiAgICAgICAgaWYgKHMuc2VhcmNoKC9eICpyZ2JhP1xcKC8pICE9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gczsgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5zZWFyY2goL14gKiM/WzAtOWEtZkEtRl0/WzAtOWEtZkEtRl0vKSAhPSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICQuanFwbG90LmhleDJyZ2IocywgYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3Igc3BlYycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBleHRyYWN0IHRoZSByLCBnLCBiLCBhIGNvbG9yIGNvbXBvbmVudHMgb3V0IG9mIGEgY3NzIGNvbG9yIHNwZWMuXG4gICAgJC5qcXBsb3QuZ2V0Q29sb3JDb21wb25lbnRzID0gZnVuY3Rpb24ocykge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgYSBjb2xvciBrZXl3b3JkLlxuICAgICAgICBzID0gJC5qcXBsb3QuY29sb3JLZXl3b3JkTWFwW3NdIHx8IHM7XG4gICAgICAgIHZhciByZ2IgPSAkLmpxcGxvdC5ub3JtYWxpemUycmdiKHMpO1xuICAgICAgICB2YXIgcGF0ID0gL3JnYmE/XFwoICooWzAtOV17MSwzfVxcLj9bMC05XSolPykgKiwgKihbMC05XXsxLDN9XFwuP1swLTldKiU/KSAqLCAqKFswLTldezEsM31cXC4/WzAtOV0qJT8pICosPyAqKFswLTkuXSogKik/XFwpLztcbiAgICAgICAgdmFyIG0gPSByZ2IubWF0Y2gocGF0KTtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTE7IGk8NDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobVtpXS5zZWFyY2goLyUvKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHJldFtpLTFdID0gcGFyc2VJbnQoMjU1Km1baV0vMTAwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbaS0xXSA9IHBhcnNlSW50KG1baV0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXRbM10gPSBwYXJzZUZsb2F0KG1bNF0pID8gcGFyc2VGbG9hdChtWzRdKSA6IDEuMDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LmNvbG9yS2V5d29yZE1hcCA9IHtcbiAgICAgICAgYWxpY2VibHVlOiAncmdiKDI0MCwgMjQ4LCAyNTUpJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAncmdiKDI1MCwgMjM1LCAyMTUpJyxcbiAgICAgICAgYXF1YTogJ3JnYiggMCwgMjU1LCAyNTUpJyxcbiAgICAgICAgYXF1YW1hcmluZTogJ3JnYigxMjcsIDI1NSwgMjEyKScsXG4gICAgICAgIGF6dXJlOiAncmdiKDI0MCwgMjU1LCAyNTUpJyxcbiAgICAgICAgYmVpZ2U6ICdyZ2IoMjQ1LCAyNDUsIDIyMCknLFxuICAgICAgICBiaXNxdWU6ICdyZ2IoMjU1LCAyMjgsIDE5NiknLFxuICAgICAgICBibGFjazogJ3JnYiggMCwgMCwgMCknLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJ3JnYigyNTUsIDIzNSwgMjA1KScsXG4gICAgICAgIGJsdWU6ICdyZ2IoIDAsIDAsIDI1NSknLFxuICAgICAgICBibHVldmlvbGV0OiAncmdiKDEzOCwgNDMsIDIyNiknLFxuICAgICAgICBicm93bjogJ3JnYigxNjUsIDQyLCA0MiknLFxuICAgICAgICBidXJseXdvb2Q6ICdyZ2IoMjIyLCAxODQsIDEzNSknLFxuICAgICAgICBjYWRldGJsdWU6ICdyZ2IoIDk1LCAxNTgsIDE2MCknLFxuICAgICAgICBjaGFydHJldXNlOiAncmdiKDEyNywgMjU1LCAwKScsXG4gICAgICAgIGNob2NvbGF0ZTogJ3JnYigyMTAsIDEwNSwgMzApJyxcbiAgICAgICAgY29yYWw6ICdyZ2IoMjU1LCAxMjcsIDgwKScsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAncmdiKDEwMCwgMTQ5LCAyMzcpJyxcbiAgICAgICAgY29ybnNpbGs6ICdyZ2IoMjU1LCAyNDgsIDIyMCknLFxuICAgICAgICBjcmltc29uOiAncmdiKDIyMCwgMjAsIDYwKScsXG4gICAgICAgIGN5YW46ICdyZ2IoIDAsIDI1NSwgMjU1KScsXG4gICAgICAgIGRhcmtibHVlOiAncmdiKCAwLCAwLCAxMzkpJyxcbiAgICAgICAgZGFya2N5YW46ICdyZ2IoIDAsIDEzOSwgMTM5KScsXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICdyZ2IoMTg0LCAxMzQsIDExKScsXG4gICAgICAgIGRhcmtncmF5OiAncmdiKDE2OSwgMTY5LCAxNjkpJyxcbiAgICAgICAgZGFya2dyZWVuOiAncmdiKCAwLCAxMDAsIDApJyxcbiAgICAgICAgZGFya2dyZXk6ICdyZ2IoMTY5LCAxNjksIDE2OSknLFxuICAgICAgICBkYXJra2hha2k6ICdyZ2IoMTg5LCAxODMsIDEwNyknLFxuICAgICAgICBkYXJrbWFnZW50YTogJ3JnYigxMzksIDAsIDEzOSknLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJ3JnYiggODUsIDEwNywgNDcpJyxcbiAgICAgICAgZGFya29yYW5nZTogJ3JnYigyNTUsIDE0MCwgMCknLFxuICAgICAgICBkYXJrb3JjaGlkOiAncmdiKDE1MywgNTAsIDIwNCknLFxuICAgICAgICBkYXJrcmVkOiAncmdiKDEzOSwgMCwgMCknLFxuICAgICAgICBkYXJrc2FsbW9uOiAncmdiKDIzMywgMTUwLCAxMjIpJyxcbiAgICAgICAgZGFya3NlYWdyZWVuOiAncmdiKDE0MywgMTg4LCAxNDMpJyxcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJ3JnYiggNzIsIDYxLCAxMzkpJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJ3JnYiggNDcsIDc5LCA3OSknLFxuICAgICAgICBkYXJrc2xhdGVncmV5OiAncmdiKCA0NywgNzksIDc5KScsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICdyZ2IoIDAsIDIwNiwgMjA5KScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICdyZ2IoMTQ4LCAwLCAyMTEpJyxcbiAgICAgICAgZGVlcHBpbms6ICdyZ2IoMjU1LCAyMCwgMTQ3KScsXG4gICAgICAgIGRlZXBza3libHVlOiAncmdiKCAwLCAxOTEsIDI1NSknLFxuICAgICAgICBkaW1ncmF5OiAncmdiKDEwNSwgMTA1LCAxMDUpJyxcbiAgICAgICAgZGltZ3JleTogJ3JnYigxMDUsIDEwNSwgMTA1KScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICdyZ2IoIDMwLCAxNDQsIDI1NSknLFxuICAgICAgICBmaXJlYnJpY2s6ICdyZ2IoMTc4LCAzNCwgMzQpJyxcbiAgICAgICAgZmxvcmFsd2hpdGU6ICdyZ2IoMjU1LCAyNTAsIDI0MCknLFxuICAgICAgICBmb3Jlc3RncmVlbjogJ3JnYiggMzQsIDEzOSwgMzQpJyxcbiAgICAgICAgZnVjaHNpYTogJ3JnYigyNTUsIDAsIDI1NSknLFxuICAgICAgICBnYWluc2Jvcm86ICdyZ2IoMjIwLCAyMjAsIDIyMCknLFxuICAgICAgICBnaG9zdHdoaXRlOiAncmdiKDI0OCwgMjQ4LCAyNTUpJyxcbiAgICAgICAgZ29sZDogJ3JnYigyNTUsIDIxNSwgMCknLFxuICAgICAgICBnb2xkZW5yb2Q6ICdyZ2IoMjE4LCAxNjUsIDMyKScsXG4gICAgICAgIGdyYXk6ICdyZ2IoMTI4LCAxMjgsIDEyOCknLFxuICAgICAgICBncmV5OiAncmdiKDEyOCwgMTI4LCAxMjgpJyxcbiAgICAgICAgZ3JlZW46ICdyZ2IoIDAsIDEyOCwgMCknLFxuICAgICAgICBncmVlbnllbGxvdzogJ3JnYigxNzMsIDI1NSwgNDcpJyxcbiAgICAgICAgaG9uZXlkZXc6ICdyZ2IoMjQwLCAyNTUsIDI0MCknLFxuICAgICAgICBob3RwaW5rOiAncmdiKDI1NSwgMTA1LCAxODApJyxcbiAgICAgICAgaW5kaWFucmVkOiAncmdiKDIwNSwgOTIsIDkyKScsXG4gICAgICAgIGluZGlnbzogJ3JnYiggNzUsIDAsIDEzMCknLFxuICAgICAgICBpdm9yeTogJ3JnYigyNTUsIDI1NSwgMjQwKScsXG4gICAgICAgIGtoYWtpOiAncmdiKDI0MCwgMjMwLCAxNDApJyxcbiAgICAgICAgbGF2ZW5kZXI6ICdyZ2IoMjMwLCAyMzAsIDI1MCknLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAncmdiKDI1NSwgMjQwLCAyNDUpJyxcbiAgICAgICAgbGF3bmdyZWVuOiAncmdiKDEyNCwgMjUyLCAwKScsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJ3JnYigyNTUsIDI1MCwgMjA1KScsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJ3JnYigxNzMsIDIxNiwgMjMwKScsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICdyZ2IoMjQwLCAxMjgsIDEyOCknLFxuICAgICAgICBsaWdodGN5YW46ICdyZ2IoMjI0LCAyNTUsIDI1NSknLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ3JnYigyNTAsIDI1MCwgMjEwKScsXG4gICAgICAgIGxpZ2h0Z3JheTogJ3JnYigyMTEsIDIxMSwgMjExKScsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICdyZ2IoMTQ0LCAyMzgsIDE0NCknLFxuICAgICAgICBsaWdodGdyZXk6ICdyZ2IoMjExLCAyMTEsIDIxMSknLFxuICAgICAgICBsaWdodHBpbms6ICdyZ2IoMjU1LCAxODIsIDE5MyknLFxuICAgICAgICBsaWdodHNhbG1vbjogJ3JnYigyNTUsIDE2MCwgMTIyKScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICdyZ2IoIDMyLCAxNzgsIDE3MCknLFxuICAgICAgICBsaWdodHNreWJsdWU6ICdyZ2IoMTM1LCAyMDYsIDI1MCknLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJ3JnYigxMTksIDEzNiwgMTUzKScsXG4gICAgICAgIGxpZ2h0c2xhdGVncmV5OiAncmdiKDExOSwgMTM2LCAxNTMpJyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICdyZ2IoMTc2LCAxOTYsIDIyMiknLFxuICAgICAgICBsaWdodHllbGxvdzogJ3JnYigyNTUsIDI1NSwgMjI0KScsXG4gICAgICAgIGxpbWU6ICdyZ2IoIDAsIDI1NSwgMCknLFxuICAgICAgICBsaW1lZ3JlZW46ICdyZ2IoIDUwLCAyMDUsIDUwKScsXG4gICAgICAgIGxpbmVuOiAncmdiKDI1MCwgMjQwLCAyMzApJyxcbiAgICAgICAgbWFnZW50YTogJ3JnYigyNTUsIDAsIDI1NSknLFxuICAgICAgICBtYXJvb246ICdyZ2IoMTI4LCAwLCAwKScsXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICdyZ2IoMTAyLCAyMDUsIDE3MCknLFxuICAgICAgICBtZWRpdW1ibHVlOiAncmdiKCAwLCAwLCAyMDUpJyxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAncmdiKDE4NiwgODUsIDIxMSknLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICdyZ2IoMTQ3LCAxMTIsIDIxOSknLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJ3JnYiggNjAsIDE3OSwgMTEzKScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJ3JnYigxMjMsIDEwNCwgMjM4KScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAncmdiKCAwLCAyNTAsIDE1NCknLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICdyZ2IoIDcyLCAyMDksIDIwNCknLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICdyZ2IoMTk5LCAyMSwgMTMzKScsXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJ3JnYiggMjUsIDI1LCAxMTIpJyxcbiAgICAgICAgbWludGNyZWFtOiAncmdiKDI0NSwgMjU1LCAyNTApJyxcbiAgICAgICAgbWlzdHlyb3NlOiAncmdiKDI1NSwgMjI4LCAyMjUpJyxcbiAgICAgICAgbW9jY2FzaW46ICdyZ2IoMjU1LCAyMjgsIDE4MSknLFxuICAgICAgICBuYXZham93aGl0ZTogJ3JnYigyNTUsIDIyMiwgMTczKScsXG4gICAgICAgIG5hdnk6ICdyZ2IoIDAsIDAsIDEyOCknLFxuICAgICAgICBvbGRsYWNlOiAncmdiKDI1MywgMjQ1LCAyMzApJyxcbiAgICAgICAgb2xpdmU6ICdyZ2IoMTI4LCAxMjgsIDApJyxcbiAgICAgICAgb2xpdmVkcmFiOiAncmdiKDEwNywgMTQyLCAzNSknLFxuICAgICAgICBvcmFuZ2U6ICdyZ2IoMjU1LCAxNjUsIDApJyxcbiAgICAgICAgb3JhbmdlcmVkOiAncmdiKDI1NSwgNjksIDApJyxcbiAgICAgICAgb3JjaGlkOiAncmdiKDIxOCwgMTEyLCAyMTQpJyxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJ3JnYigyMzgsIDIzMiwgMTcwKScsXG4gICAgICAgIHBhbGVncmVlbjogJ3JnYigxNTIsIDI1MSwgMTUyKScsXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICdyZ2IoMTc1LCAyMzgsIDIzOCknLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiAncmdiKDIxOSwgMTEyLCAxNDcpJyxcbiAgICAgICAgcGFwYXlhd2hpcDogJ3JnYigyNTUsIDIzOSwgMjEzKScsXG4gICAgICAgIHBlYWNocHVmZjogJ3JnYigyNTUsIDIxOCwgMTg1KScsXG4gICAgICAgIHBlcnU6ICdyZ2IoMjA1LCAxMzMsIDYzKScsXG4gICAgICAgIHBpbms6ICdyZ2IoMjU1LCAxOTIsIDIwMyknLFxuICAgICAgICBwbHVtOiAncmdiKDIyMSwgMTYwLCAyMjEpJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJ3JnYigxNzYsIDIyNCwgMjMwKScsXG4gICAgICAgIHB1cnBsZTogJ3JnYigxMjgsIDAsIDEyOCknLFxuICAgICAgICByZWQ6ICdyZ2IoMjU1LCAwLCAwKScsXG4gICAgICAgIHJvc3licm93bjogJ3JnYigxODgsIDE0MywgMTQzKScsXG4gICAgICAgIHJveWFsYmx1ZTogJ3JnYiggNjUsIDEwNSwgMjI1KScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAncmdiKDEzOSwgNjksIDE5KScsXG4gICAgICAgIHNhbG1vbjogJ3JnYigyNTAsIDEyOCwgMTE0KScsXG4gICAgICAgIHNhbmR5YnJvd246ICdyZ2IoMjQ0LCAxNjQsIDk2KScsXG4gICAgICAgIHNlYWdyZWVuOiAncmdiKCA0NiwgMTM5LCA4NyknLFxuICAgICAgICBzZWFzaGVsbDogJ3JnYigyNTUsIDI0NSwgMjM4KScsXG4gICAgICAgIHNpZW5uYTogJ3JnYigxNjAsIDgyLCA0NSknLFxuICAgICAgICBzaWx2ZXI6ICdyZ2IoMTkyLCAxOTIsIDE5MiknLFxuICAgICAgICBza3libHVlOiAncmdiKDEzNSwgMjA2LCAyMzUpJyxcbiAgICAgICAgc2xhdGVibHVlOiAncmdiKDEwNiwgOTAsIDIwNSknLFxuICAgICAgICBzbGF0ZWdyYXk6ICdyZ2IoMTEyLCAxMjgsIDE0NCknLFxuICAgICAgICBzbGF0ZWdyZXk6ICdyZ2IoMTEyLCAxMjgsIDE0NCknLFxuICAgICAgICBzbm93OiAncmdiKDI1NSwgMjUwLCAyNTApJyxcbiAgICAgICAgc3ByaW5nZ3JlZW46ICdyZ2IoIDAsIDI1NSwgMTI3KScsXG4gICAgICAgIHN0ZWVsYmx1ZTogJ3JnYiggNzAsIDEzMCwgMTgwKScsXG4gICAgICAgIHRhbjogJ3JnYigyMTAsIDE4MCwgMTQwKScsXG4gICAgICAgIHRlYWw6ICdyZ2IoIDAsIDEyOCwgMTI4KScsXG4gICAgICAgIHRoaXN0bGU6ICdyZ2IoMjE2LCAxOTEsIDIxNiknLFxuICAgICAgICB0b21hdG86ICdyZ2IoMjU1LCA5OSwgNzEpJyxcbiAgICAgICAgdHVycXVvaXNlOiAncmdiKCA2NCwgMjI0LCAyMDgpJyxcbiAgICAgICAgdmlvbGV0OiAncmdiKDIzOCwgMTMwLCAyMzgpJyxcbiAgICAgICAgd2hlYXQ6ICdyZ2IoMjQ1LCAyMjIsIDE3OSknLFxuICAgICAgICB3aGl0ZTogJ3JnYigyNTUsIDI1NSwgMjU1KScsXG4gICAgICAgIHdoaXRlc21va2U6ICdyZ2IoMjQ1LCAyNDUsIDI0NSknLFxuICAgICAgICB5ZWxsb3c6ICdyZ2IoMjU1LCAyNTUsIDApJyxcbiAgICAgICAgeWVsbG93Z3JlZW46ICdyZ2IoMTU0LCAyMDUsIDUwKSdcbiAgICB9O1xuXG4gICAgXG5cblxuICAgIC8vIGNsYXNzOiAkLmpxcGxvdC5BeGlzTGFiZWxSZW5kZXJlclxuICAgIC8vIFJlbmRlcmVyIHRvIHBsYWNlIGxhYmVscyBvbiB0aGUgYXhlcy5cbiAgICAkLmpxcGxvdC5BeGlzTGFiZWxSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gR3JvdXA6IFByb3BlcnRpZXNcbiAgICAgICAgJC5qcXBsb3QuRWxlbUNvbnRhaW5lci5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBuYW1lIG9mIHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpY2tcbiAgICAgICAgdGhpcy5heGlzO1xuICAgICAgICAvLyBwcm9wOiBzaG93XG4gICAgICAgIC8vIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIHRpY2sgKG1hcmsgYW5kIGxhYmVsKS5cbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogbGFiZWxcbiAgICAgICAgLy8gVGhlIHRleHQgb3IgaHRtbCBmb3IgdGhlIGxhYmVsLlxuICAgICAgICB0aGlzLmxhYmVsID0gJyc7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VsZW07XG4gICAgICAgIC8vIHByb3A6IGVzY2FwZUhUTUxcbiAgICAgICAgLy8gdHJ1ZSB0byBlc2NhcGUgSFRNTCBlbnRpdGllcyBpbiB0aGUgbGFiZWwuXG4gICAgICAgIHRoaXMuZXNjYXBlSFRNTCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5BeGlzTGFiZWxSZW5kZXJlci5wcm90b3R5cGUgPSBuZXcgJC5qcXBsb3QuRWxlbUNvbnRhaW5lcigpO1xuICAgICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9ICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyO1xuICAgIFxuICAgICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBwbG90KSB7XG4gICAgICAgIC8vIE1lbW9yeSBMZWFrcyBwYXRjaFxuICAgICAgICBpZiAodGhpcy5fZWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS5lbXB0eUZvcmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VsZW0gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7XCIgY2xhc3M9XCJqcXBsb3QtJyt0aGlzLmF4aXMrJy1sYWJlbFwiPjwvZGl2PicpO1xuICAgICAgICBcbiAgICAgICAgaWYgKE51bWJlcih0aGlzLmxhYmVsKSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3MoJ3doaXRlLXNwYWNlJywgJ25vd3JhcCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuZXNjYXBlSFRNTCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS5odG1sKHRoaXMubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS50ZXh0KHRoaXMubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdmb250LWZhbWlseScsIHRoaXMuZm9udEZhbWlseSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9udFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdmb250LXNpemUnLCB0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdjb2xvcicsIHRoaXMudGV4dENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW07XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5BeGlzTGFiZWxSZW5kZXJlci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG5cbiAgICAvLyBjbGFzczogJC5qcXBsb3QuQXhpc1RpY2tSZW5kZXJlclxuICAgIC8vIEEgXCJ0aWNrXCIgb2JqZWN0IHNob3dpbmcgdGhlIHZhbHVlIG9mIGEgdGljay9ncmlkbGluZSBvbiB0aGUgcGxvdC5cbiAgICAkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBHcm91cDogUHJvcGVydGllc1xuICAgICAgICAkLmpxcGxvdC5FbGVtQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIHByb3A6IG1hcmtcbiAgICAgICAgLy8gdGljayBtYXJrIG9uIHRoZSBheGlzLiAgT25lIG9mICdpbnNpZGUnLCAnb3V0c2lkZScsICdjcm9zcycsICcnIG9yIG51bGwuXG4gICAgICAgIHRoaXMubWFyayA9ICdvdXRzaWRlJztcbiAgICAgICAgLy8gbmFtZSBvZiB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWNrXG4gICAgICAgIHRoaXMuYXhpcztcbiAgICAgICAgLy8gcHJvcDogc2hvd01hcmtcbiAgICAgICAgLy8gd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgbWFyayBvbiB0aGUgYXhpcy5cbiAgICAgICAgdGhpcy5zaG93TWFyayA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNob3dHcmlkbGluZVxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBncmlkbGluZSBvbiB0aGUgZ3JpZCBhdCB0aGlzIHRpY2suXG4gICAgICAgIHRoaXMuc2hvd0dyaWRsaW5lID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogaXNNaW5vclRpY2tcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIG1pbm9yIHRpY2suXG4gICAgICAgIHRoaXMuaXNNaW5vclRpY2sgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogc2l6ZVxuICAgICAgICAvLyBMZW5ndGggb2YgdGhlIHRpY2sgYmV5b25kIHRoZSBncmlkIGluIHBpeGVscy5cbiAgICAgICAgLy8gREVQUkVDQVRFRDogVGhpcyBoYXMgYmVlbiBzdXBlcmNlZWRlZCBieSBtYXJrU2l6ZVxuICAgICAgICB0aGlzLnNpemUgPSA0O1xuICAgICAgICAvLyBwcm9wOiAgbWFya1NpemVcbiAgICAgICAgLy8gTGVuZ3RoIG9mIHRoZSB0aWNrIG1hcmtzIGluIHBpeGVscy4gIEZvciAnY3Jvc3MnIHN0eWxlLCBsZW5ndGhcbiAgICAgICAgLy8gd2lsbCBiZSBzdG9rZWQgYWJvdmUgYW5kIGJlbG93IGF4aXMsIHNvIHRvdGFsIGxlbmd0aCB3aWxsIGJlIHR3aWNlIHRoaXMuXG4gICAgICAgIHRoaXMubWFya1NpemUgPSA2O1xuICAgICAgICAvLyBwcm9wOiBzaG93XG4gICAgICAgIC8vIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIHRpY2sgKG1hcmsgYW5kIGxhYmVsKS5cbiAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGZhbHNlIHJlcXVpcmVzIG1vcmUgdGVzdGluZy4gIEl0IGlzIHJlY29tbWVuZGVkXG4gICAgICAgIC8vIHRvIHNldCBzaG93TGFiZWwgYW5kIHNob3dNYXJrIHRvIGZhbHNlIGluc3RlYWQuXG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IHNob3dMYWJlbFxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSBsYWJlbC5cbiAgICAgICAgdGhpcy5zaG93TGFiZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0eWxlcyA9IHt9O1xuICAgICAgICAvLyBwcm9wOiBmb3JtYXR0ZXJcbiAgICAgICAgLy8gQSBjbGFzcyBvZiBhIGZvcm1hdHRlciBmb3IgdGhlIHRpY2sgdGV4dC4gIHNwcmludGYgYnkgZGVmYXVsdC5cbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSAkLmpxcGxvdC5EZWZhdWx0VGlja0Zvcm1hdHRlcjtcbiAgICAgICAgLy8gcHJvcDogcHJlZml4XG4gICAgICAgIC8vIFN0cmluZyB0byBwcmVwZW5kIHRvIHRoZSB0aWNrIGxhYmVsLlxuICAgICAgICAvLyBQcmVmaXggaXMgcHJlcGVuZGVkIHRvIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbC5cbiAgICAgICAgdGhpcy5wcmVmaXggPSAnJztcbiAgICAgICAgLy8gcHJvcDogc3VmZml4XG4gICAgICAgIC8vIFN0cmluZyB0byBhcHBlbmQgdG8gdGhlIHRpY2sgbGFiZWwuXG4gICAgICAgIC8vIFN1ZmZpeCBpcyBhcHBlbmRlZCB0byB0aGUgZm9ybWF0dGVkIHRpY2sgbGFiZWwuXG4gICAgICAgIHRoaXMuc3VmZml4ID0gJyc7XG4gICAgICAgIC8vIHByb3A6IGZvcm1hdFN0cmluZ1xuICAgICAgICAvLyBzdHJpbmcgcGFzc2VkIHRvIHRoZSBmb3JtYXR0ZXIuXG4gICAgICAgIHRoaXMuZm9ybWF0U3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHByb3A6IGZvbnRGYW1pbHlcbiAgICAgICAgLy8gY3NzIHNwZWMgZm9yIHRoZSBmb250LWZhbWlseSBjc3MgYXR0cmlidXRlLlxuICAgICAgICB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgIC8vIHByb3A6IGZvbnRTaXplXG4gICAgICAgIC8vIGNzcyBzcGVjIGZvciB0aGUgZm9udC1zaXplIGNzcyBhdHRyaWJ1dGUuXG4gICAgICAgIHRoaXMuZm9udFNpemU7XG4gICAgICAgIC8vIHByb3A6IHRleHRDb2xvclxuICAgICAgICAvLyBjc3Mgc3BlYyBmb3IgdGhlIGNvbG9yIGF0dHJpYnV0ZS5cbiAgICAgICAgdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIC8vIHByb3A6IGVzY2FwZUhUTUxcbiAgICAgICAgLy8gdHJ1ZSB0byBlc2NhcGUgSFRNTCBlbnRpdGllcyBpbiB0aGUgbGFiZWwuXG4gICAgICAgIHRoaXMuZXNjYXBlSFRNTCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbGVtO1xuICAgICAgICB0aGlzLl9icmVha1RpY2sgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuQXhpc1RpY2tSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyLnByb3RvdHlwZSA9IG5ldyAkLmpxcGxvdC5FbGVtQ29udGFpbmVyKCk7XG4gICAgJC5qcXBsb3QuQXhpc1RpY2tSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSAkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyO1xuICAgIFxuICAgICQuanFwbG90LkF4aXNUaWNrUmVuZGVyZXIucHJvdG90eXBlLnNldFRpY2sgPSBmdW5jdGlvbih2YWx1ZSwgYXhpc05hbWUsIGlzTWlub3IpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmF4aXMgPSBheGlzTmFtZTtcbiAgICAgICAgaWYgKGlzTWlub3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNaW5vclRpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuQXhpc1RpY2tSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMucHJlZml4ICsgdGhpcy5mb3JtYXR0ZXIodGhpcy5mb3JtYXRTdHJpbmcsIHRoaXMudmFsdWUpICsgdGhpcy5zdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlID0ge3Bvc2l0aW9uOiAnYWJzb2x1dGUnfTtcbiAgICAgICAgaWYgKE51bWJlcih0aGlzLmxhYmVsKSkge1xuICAgICAgICAgICAgc3R5bGVbJ3doaXRTcGFjZSddID0gJ25vd3JhcCc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE1lbW9yeSBMZWFrcyBwYXRjaFxuICAgICAgICBpZiAodGhpcy5fZWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS5lbXB0eUZvcmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VsZW0gPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgdGhpcy5fZWxlbS5hZGRDbGFzcyhcImpxcGxvdC1cIit0aGlzLmF4aXMrXCItdGlja1wiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5lc2NhcGVIVE1MKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmh0bWwodGhpcy5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLnRleHQodGhpcy5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2VsZW0uY3NzKHN0eWxlKTtcblxuICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3MocywgdGhpcy5fc3R5bGVzW3NdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygnZm9udC1mYW1pbHknLCB0aGlzLmZvbnRGYW1pbHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygnY29sb3InLCB0aGlzLnRleHRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JyZWFrVGljaykge1xuICAgICAgICAgIHRoaXMuX2VsZW0uYWRkQ2xhc3MoJ2pxcGxvdC1icmVha1RpY2snKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW07XG4gICAgfTtcbiAgICAgICAgXG4gICAgJC5qcXBsb3QuRGVmYXVsdFRpY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoZm9ybWF0LCB2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gJC5qcXBsb3QuY29uZmlnLmRlZmF1bHRUaWNrRm9ybWF0U3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuanFwbG90LnNwcmludGYoZm9ybWF0LCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAgICAgXG4gICAgJC5qcXBsb3QuUGVyY2VudFRpY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoZm9ybWF0LCB2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbCA9IDEwMCAqIHZhbDtcbiAgICAgICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gJC5qcXBsb3QuY29uZmlnLmRlZmF1bHRUaWNrRm9ybWF0U3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuanFwbG90LnNwcmludGYoZm9ybWF0LCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5BeGlzVGlja1JlbmRlcmVyLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICAgXG4gICAgLy8gQ2xhc3M6ICQuanFwbG90LkNhbnZhc0dyaWRSZW5kZXJlclxuICAgIC8vIFRoZSBkZWZhdWx0IGpxUGxvdCBncmlkIHJlbmRlcmVyLCBjcmVhdGluZyBhIGdyaWQgb24gYSBjYW52YXMgZWxlbWVudC5cbiAgICAvLyBUaGUgcmVuZGVyZXIgaGFzIG5vIGFkZGl0aW9uYWwgb3B0aW9ucyBiZXlvbmQgdGhlIDxHcmlkPiBjbGFzcy5cbiAgICAkLmpxcGxvdC5DYW52YXNHcmlkUmVuZGVyZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyID0gbmV3ICQuanFwbG90LlNoYWRvd1JlbmRlcmVyKCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBjYWxsZWQgd2l0aCBjb250ZXh0IG9mIEdyaWQgb2JqZWN0XG4gICAgJC5qcXBsb3QuQ2FudmFzR3JpZFJlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jdHg7XG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBzZXQgdGhlIHNoYWRvdyByZW5kZXJlciBvcHRpb25zXG4gICAgICAgIHZhciBzb3B0cyA9IHtsaW5lSm9pbjonbWl0ZXInLCBsaW5lQ2FwOidyb3VuZCcsIGZpbGw6ZmFsc2UsIGlzYXJjOmZhbHNlLCBhbmdsZTp0aGlzLnNoYWRvd0FuZ2xlLCBvZmZzZXQ6dGhpcy5zaGFkb3dPZmZzZXQsIGFscGhhOnRoaXMuc2hhZG93QWxwaGEsIGRlcHRoOnRoaXMuc2hhZG93RGVwdGgsIGxpbmVXaWR0aDp0aGlzLnNoYWRvd1dpZHRoLCBjbG9zZVBhdGg6ZmFsc2UsIHN0cm9rZVN0eWxlOnRoaXMuc2hhZG93Q29sb3J9O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd1JlbmRlcmVyLmluaXQoc29wdHMpO1xuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggY29udGV4dCBvZiBHcmlkLlxuICAgICQuanFwbG90LkNhbnZhc0dyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgdmFyIGVsZW07XG4gICAgICAgIC8vIE1lbW9yeSBMZWFrcyBwYXRjaFxuICAgICAgICBpZiAodGhpcy5fZWxlbSkge1xuICAgICAgICAgIGlmICgkLmpxcGxvdC51c2VfZXhjYW52YXMgJiYgd2luZG93Lkdfdm1sQ2FudmFzTWFuYWdlci51bmluaXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLl9lbGVtLmdldCgwKTtcbiAgICAgICAgICAgIHdpbmRvdy5HX3ZtbENhbnZhc01hbmFnZXIudW5pbml0RWxlbWVudChlbGVtKTtcbiAgICAgICAgICAgIGVsZW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLl9lbGVtLmVtcHR5Rm9yY2UoKTtcbiAgICAgICAgICB0aGlzLl9lbGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIGVsZW0gPSBwbG90LmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIGVsZW0ud2lkdGggPSB3O1xuICAgICAgICBlbGVtLmhlaWdodCA9IGg7XG4gICAgICAgIHRoaXMuX2VsZW0gPSAkKGVsZW0pO1xuICAgICAgICB0aGlzLl9lbGVtLmFkZENsYXNzKCdqcXBsb3QtZ3JpZC1jYW52YXMnKTtcbiAgICAgICAgdGhpcy5fZWxlbS5jc3MoeyBwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogMCwgdG9wOiAwIH0pO1xuICAgICAgICBcbiAgICAgICAgZWxlbSA9IHBsb3QuY2FudmFzTWFuYWdlci5pbml0Q2FudmFzKGVsZW0pO1xuXG4gICAgICAgIHRoaXMuX3RvcCA9IHRoaXMuX29mZnNldHMudG9wO1xuICAgICAgICB0aGlzLl9ib3R0b20gPSBoIC0gdGhpcy5fb2Zmc2V0cy5ib3R0b207XG4gICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9vZmZzZXRzLmxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gdyAtIHRoaXMuX29mZnNldHMucmlnaHQ7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fcmlnaHQgLSB0aGlzLl9sZWZ0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9ib3R0b20gLSB0aGlzLl90b3A7XG4gICAgICAgIC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgICAgIGVsZW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkNhbnZhc0dyaWRSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9lbGVtLmdldCgwKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICAgICAgLy8gQWRkIHRoZSBncmlkIG9udG8gdGhlIGdyaWQgY2FudmFzLiAgVGhpcyBpcyB0aGUgYm90dG9tIG1vc3QgbGF5ZXIuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGgsIHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLmJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLl9sZWZ0LCB0aGlzLl90b3AsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmdyaWRMaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ3JpZExpbmVDb2xvcjtcbiAgICAgICAgdmFyIGIsIGUsIHMsIG07XG4gICAgICAgIHZhciBheCA9IFsneGF4aXMnLCAneWF4aXMnLCAneDJheGlzJywgJ3kyYXhpcyddO1xuICAgICAgICBmb3IgKHZhciBpPTQ7IGk+MDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGF4W2ktMV07XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLl90aWNrcztcbiAgICAgICAgICAgIHZhciBudW10aWNrcyA9IHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5kcmF3QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmJhc2VsaW5lV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcHRzLmxpbmVXaWR0aCA9IGF4aXMuYmFzZWxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5iYXNlbGluZUNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3B0cy5zdHJva2VTdHlsZSA9IGF4aXMuYmFzZWxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3hheGlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZSAodGhpcy5fbGVmdCwgdGhpcy5fYm90dG9tLCB0aGlzLl9yaWdodCwgdGhpcy5fYm90dG9tLCBib3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd5YXhpcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xpbmUgKHRoaXMuX2xlZnQsIHRoaXMuX2JvdHRvbSwgdGhpcy5fbGVmdCwgdGhpcy5fdG9wLCBib3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4MmF4aXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdMaW5lICh0aGlzLl9sZWZ0LCB0aGlzLl9ib3R0b20sIHRoaXMuX3JpZ2h0LCB0aGlzLl9ib3R0b20sIGJvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3kyYXhpcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xpbmUgKHRoaXMuX3JpZ2h0LCB0aGlzLl9ib3R0b20sIHRoaXMuX3JpZ2h0LCB0aGlzLl90b3AsIGJvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPW51bXRpY2tzOyBqPjA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRpY2tzW2otMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBNYXRoLnJvdW5kKGF4aXMudTJwKHQudmFsdWUpKSArIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3hheGlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZ3JpZCBsaW5lIGlmIHdlIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5zaG93R3JpZGxpbmUgJiYgdGhpcy5kcmF3R3JpZGxpbmVzICYmICgoIXQuaXNNaW5vclRpY2sgJiYgYXhpcy5kcmF3TWFqb3JHcmlkbGluZXMpIHx8ICh0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01pbm9yR3JpZGxpbmVzKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShwb3MsIHRoaXMuX3RvcCwgcG9zLCB0aGlzLl9ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIG1hcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuc2hvd01hcmsgJiYgdC5tYXJrICYmICgoIXQuaXNNaW5vclRpY2sgJiYgYXhpcy5kcmF3TWFqb3JUaWNrTWFya3MpIHx8ICh0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01pbm9yVGlja01hcmtzKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gdC5tYXJrU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0Lm1hcms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gTWF0aC5yb3VuZChheGlzLnUycCh0LnZhbHVlKSkgKyAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvdXRzaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuX2JvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX2JvdHRvbStzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fYm90dG9tLXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuX2JvdHRvbS1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fYm90dG9tK3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLl9ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9ib3R0b20rcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93UmVuZGVyZXIuZHJhdyhjdHgsIFtbcG9zLGJdLFtwb3MsZV1dLCB7bGluZUNhcDonYnV0dCcsIGxpbmVXaWR0aDp0aGlzLmdyaWRMaW5lV2lkdGgsIG9mZnNldDp0aGlzLmdyaWRMaW5lV2lkdGgqMC43NSwgZGVwdGg6MiwgZmlsbDpmYWxzZSwgY2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShwb3MsIGIsIHBvcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneWF4aXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBncmlkIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuc2hvd0dyaWRsaW5lICYmIHRoaXMuZHJhd0dyaWRsaW5lcyAmJiAoKCF0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01ham9yR3JpZGxpbmVzKSB8fCAodC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNaW5vckdyaWRsaW5lcykpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xpbmUodGhpcy5fcmlnaHQsIHBvcywgdGhpcy5fbGVmdCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBtYXJrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3dNYXJrICYmIHQubWFyayAmJiAoKCF0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01ham9yVGlja01hcmtzKSB8fCAodC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNaW5vclRpY2tNYXJrcykpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQubWFya1NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gdC5tYXJrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGgucm91bmQoYXhpcy51MnAodC52YWx1ZSkpICsgMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3V0c2lkZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLl9sZWZ0LXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX2xlZnQrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fbGVmdC1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fbGVmdCtzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fbGVmdC1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgW1tiLCBwb3NdLCBbZSwgcG9zXV0sIHtsaW5lQ2FwOididXR0JywgbGluZVdpZHRoOnRoaXMuZ3JpZExpbmVXaWR0aCoxLjUsIG9mZnNldDp0aGlzLmdyaWRMaW5lV2lkdGgqMC43NSwgZmlsbDpmYWxzZSwgY2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShiLCBwb3MsIGUsIHBvcywge3N0cm9rZVN0eWxlOmF4aXMuYm9yZGVyQ29sb3J9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4MmF4aXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBncmlkIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuc2hvd0dyaWRsaW5lICYmIHRoaXMuZHJhd0dyaWRsaW5lcyAmJiAoKCF0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01ham9yR3JpZGxpbmVzKSB8fCAodC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNaW5vckdyaWRsaW5lcykpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xpbmUocG9zLCB0aGlzLl9ib3R0b20sIHBvcywgdGhpcy5fdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBtYXJrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3dNYXJrICYmIHQubWFyayAmJiAoKCF0LmlzTWlub3JUaWNrICYmIGF4aXMuZHJhd01ham9yVGlja01hcmtzKSB8fCAodC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNaW5vclRpY2tNYXJrcykpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQubWFya1NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gdC5tYXJrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGgucm91bmQoYXhpcy51MnAodC52YWx1ZSkpICsgMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3V0c2lkZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLl90b3AtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX3RvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuX3RvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX3RvcCtzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjcm9zcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLl90b3AtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX3RvcCtzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fdG9wLXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl90b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93UmVuZGVyZXIuZHJhdyhjdHgsIFtbcG9zLGJdLFtwb3MsZV1dLCB7bGluZUNhcDonYnV0dCcsIGxpbmVXaWR0aDp0aGlzLmdyaWRMaW5lV2lkdGgsIG9mZnNldDp0aGlzLmdyaWRMaW5lV2lkdGgqMC43NSwgZGVwdGg6MiwgZmlsbDpmYWxzZSwgY2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShwb3MsIGIsIHBvcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneTJheGlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZ3JpZCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3dHcmlkbGluZSAmJiB0aGlzLmRyYXdHcmlkbGluZXMgJiYgKCghdC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNYWpvckdyaWRsaW5lcykgfHwgKHQuaXNNaW5vclRpY2sgJiYgYXhpcy5kcmF3TWlub3JHcmlkbGluZXMpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdMaW5lKHRoaXMuX2xlZnQsIHBvcywgdGhpcy5fcmlnaHQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgbWFya1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5zaG93TWFyayAmJiB0Lm1hcmsgJiYgKCghdC5pc01pbm9yVGljayAmJiBheGlzLmRyYXdNYWpvclRpY2tNYXJrcykgfHwgKHQuaXNNaW5vclRpY2sgJiYgYXhpcy5kcmF3TWlub3JUaWNrTWFya3MpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0Lm1hcmtTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHQubWFyaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBNYXRoLnJvdW5kKGF4aXMudTJwKHQudmFsdWUpKSArIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ291dHNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9yaWdodCtzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5fcmlnaHQtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX3JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjcm9zcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLl9yaWdodC1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fcmlnaHQrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuX3JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fcmlnaHQrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgW1tiLCBwb3NdLCBbZSwgcG9zXV0sIHtsaW5lQ2FwOididXR0JywgbGluZVdpZHRoOnRoaXMuZ3JpZExpbmVXaWR0aCoxLjUsIG9mZnNldDp0aGlzLmdyaWRMaW5lV2lkdGgqMC43NSwgZmlsbDpmYWxzZSwgY2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShiLCBwb3MsIGUsIHBvcywge3N0cm9rZVN0eWxlOmF4aXMuYm9yZGVyQ29sb3J9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXMgPSBudWxsO1xuICAgICAgICAgICAgdGlja3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBkcmF3IGdyaWQgbGluZXMgZm9yIGFkZGl0aW9uYWwgeSBheGVzXG4gICAgICAgIC8vLy8vL1xuICAgICAgICAvLyBUTyBETzogaGFuZGxlIHlNaWRBeGlzXG4gICAgICAgIC8vLy8vL1xuICAgICAgICBheCA9IFsneTNheGlzJywgJ3k0YXhpcycsICd5NWF4aXMnLCAneTZheGlzJywgJ3k3YXhpcycsICd5OGF4aXMnLCAneTlheGlzJywgJ3lNaWRBeGlzJ107XG4gICAgICAgIGZvciAodmFyIGk9NzsgaT4wOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1theFtpLTFdXTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuX3RpY2tzO1xuICAgICAgICAgICAgaWYgKGF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHZhciB0biA9IHRpY2tzW2F4aXMubnVtYmVyVGlja3MtMV07XG4gICAgICAgICAgICAgICAgdmFyIHQwID0gdGlja3NbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBheGlzLmdldExlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW1tsZWZ0LCB0bi5nZXRUb3AoKSArIHRuLmdldEhlaWdodCgpLzJdLCBbbGVmdCwgdDAuZ2V0VG9wKCkgKyB0MC5nZXRIZWlnaHQoKS8yICsgMS4wXV07XG4gICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgc2hhZG93XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93UmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50cywge2xpbmVDYXA6J2J1dHQnLCBmaWxsOmZhbHNlLCBjbG9zZVBhdGg6ZmFsc2V9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgbGluZVxuICAgICAgICAgICAgICAgIGRyYXdMaW5lKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCBwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXSwge2xpbmVDYXA6J2J1dHQnLCBzdHJva2VTdHlsZTpheGlzLmJvcmRlckNvbG9yLCBsaW5lV2lkdGg6YXhpcy5ib3JkZXJXaWR0aH0pO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIHRpY2sgbWFya3NcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPXRpY2tzLmxlbmd0aDsgaj4wOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aWNrc1tqLTFdO1xuICAgICAgICAgICAgICAgICAgICBzID0gdC5tYXJrU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHQubWFyaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGgucm91bmQoYXhpcy51MnAodC52YWx1ZSkpICsgMC41O1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5zaG93TWFyayAmJiB0Lm1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ291dHNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGxlZnQrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGxlZnQtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGxlZnQtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGxlZnQrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBsZWZ0K3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW1tiLHBvc10sIFtlLHBvc11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMsIHtsaW5lQ2FwOididXR0JywgbGluZVdpZHRoOnRoaXMuZ3JpZExpbmVXaWR0aCoxLjUsIG9mZnNldDp0aGlzLmdyaWRMaW5lV2lkdGgqMC43NSwgZmlsbDpmYWxzZSwgY2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGluZShiLCBwb3MsIGUsIHBvcywge3N0cm9rZVN0eWxlOmF4aXMuYm9yZGVyQ29sb3J9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXhpcyA9IG51bGw7XG4gICAgICAgICAgICB0aWNrcyA9ICBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gZHJhd0xpbmUoYngsIGJ5LCBleCwgZXksIG9wdHMpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChvcHRzLmxpbmVXaWR0aCA9PSBudWxsIHx8IG9wdHMubGluZVdpZHRoICE9IDApe1xuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIGN0eCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYngsIGJ5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGV4LCBleSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtbdGhpcy5fbGVmdCwgdGhpcy5fYm90dG9tXSwgW3RoaXMuX3JpZ2h0LCB0aGlzLl9ib3R0b21dLCBbdGhpcy5fcmlnaHQsIHRoaXMuX3RvcF1dO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgZHJhdyBib3JkZXIgYXJvdW5kIGdyaWQuICBVc2UgYXhpcyBib3JkZXIgZGVmaW5pdGlvbnMuIHN0YXJ0IGF0XG4gICAgICAgIC8vIHVwcGVyIGxlZnQgYW5kIGdvIGNsb2Nrd2lzZS5cbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyV2lkdGggIT0gMCAmJiB0aGlzLmRyYXdCb3JkZXIpIHtcbiAgICAgICAgICAgIGRyYXdMaW5lICh0aGlzLl9sZWZ0LCB0aGlzLl90b3AsIHRoaXMuX3JpZ2h0LCB0aGlzLl90b3AsIHtsaW5lQ2FwOidyb3VuZCcsIHN0cm9rZVN0eWxlOmF4ZXMueDJheGlzLmJvcmRlckNvbG9yLCBsaW5lV2lkdGg6YXhlcy54MmF4aXMuYm9yZGVyV2lkdGh9KTtcbiAgICAgICAgICAgIGRyYXdMaW5lICh0aGlzLl9yaWdodCwgdGhpcy5fdG9wLCB0aGlzLl9yaWdodCwgdGhpcy5fYm90dG9tLCB7bGluZUNhcDoncm91bmQnLCBzdHJva2VTdHlsZTpheGVzLnkyYXhpcy5ib3JkZXJDb2xvciwgbGluZVdpZHRoOmF4ZXMueTJheGlzLmJvcmRlcldpZHRofSk7XG4gICAgICAgICAgICBkcmF3TGluZSAodGhpcy5fcmlnaHQsIHRoaXMuX2JvdHRvbSwgdGhpcy5fbGVmdCwgdGhpcy5fYm90dG9tLCB7bGluZUNhcDoncm91bmQnLCBzdHJva2VTdHlsZTpheGVzLnhheGlzLmJvcmRlckNvbG9yLCBsaW5lV2lkdGg6YXhlcy54YXhpcy5ib3JkZXJXaWR0aH0pO1xuICAgICAgICAgICAgZHJhd0xpbmUgKHRoaXMuX2xlZnQsIHRoaXMuX2JvdHRvbSwgdGhpcy5fbGVmdCwgdGhpcy5fdG9wLCB7bGluZUNhcDoncm91bmQnLCBzdHJva2VTdHlsZTpheGVzLnlheGlzLmJvcmRlckNvbG9yLCBsaW5lV2lkdGg6YXhlcy55YXhpcy5ib3JkZXJXaWR0aH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAvLyBjdHguc3Ryb2tlUmVjdCh0aGlzLl9sZWZ0LCB0aGlzLl90b3AsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4ID0gIG51bGw7XG4gICAgICAgIGF4ZXMgPSBudWxsO1xuICAgIH07XG4gXG4gICAgLy8gQ2xhc3M6ICQuanFwbG90LkRpdlRpdGxlUmVuZGVyZXJcbiAgICAvLyBUaGUgZGVmYXVsdCB0aXRsZSByZW5kZXJlciBmb3IganFQbG90LiAgVGhpcyBjbGFzcyBoYXMgbm8gb3B0aW9ucyBiZXlvbmQgdGhlIDxUaXRsZT4gY2xhc3MuIFxuICAgICQuanFwbG90LkRpdlRpdGxlUmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LkRpdlRpdGxlUmVuZGVyZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuRGl2VGl0bGVSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBNZW1vcnkgTGVha3MgcGF0Y2hcbiAgICAgICAgaWYgKHRoaXMuX2VsZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uZW1wdHlGb3JjZSgpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2VsZW0gPSAkKGVsZW0pO1xuICAgICAgICB0aGlzLl9lbGVtLmFkZENsYXNzKCdqcXBsb3QtdGl0bGUnKTtcblxuICAgICAgICBpZiAoIXRoaXMudGV4dCkge1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmhlaWdodCgwKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0ud2lkdGgoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY29sb3I7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGV4dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9uJ3QgdHJ1c3QgdGhhdCBhIHN0eWxlc2hlZXQgaXMgcHJlc2VudCwgc2V0IHRoZSBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7cG9zaXRpb246J2Fic29sdXRlJywgdG9wOicwcHgnLCBsZWZ0OicwcHgnfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Bsb3RXaWR0aCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc1snd2lkdGgnXSA9IHRoaXMuX3Bsb3RXaWR0aCsncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ2ZvbnRTaXplJ10gPSB0aGlzLmZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRleHRBbGlnbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ3RleHRBbGlnbiddID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ3RleHRBbGlnbiddID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ2NvbG9yJ10gPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ3BhZGRpbmdCb3R0b20nXSA9IHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbJ2ZvbnRGYW1pbHknXSA9IHRoaXMuZm9udEZhbWlseTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moc3R5bGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVzY2FwZUh0bWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLnRleHQodGhpcy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uaHRtbCh0aGlzLnRleHQpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIHN0eWxldGV4dCArPSAodGhpcy5fcGxvdFdpZHRoKSA/ICd3aWR0aDonK3RoaXMuX3Bsb3RXaWR0aCsncHg7JyA6ICcnO1xuICAgICAgICAgICAgLy8gc3R5bGV0ZXh0ICs9ICh0aGlzLmZvbnRTaXplKSA/ICdmb250LXNpemU6Jyt0aGlzLmZvbnRTaXplKyc7JyA6ICcnO1xuICAgICAgICAgICAgLy8gc3R5bGV0ZXh0ICs9ICh0aGlzLnRleHRBbGlnbikgPyAndGV4dC1hbGlnbjonK3RoaXMudGV4dEFsaWduKyc7JyA6ICd0ZXh0LWFsaWduOmNlbnRlcjsnO1xuICAgICAgICAgICAgLy8gc3R5bGV0ZXh0ICs9IChjb2xvcikgPyAnY29sb3I6Jytjb2xvcisnOycgOiAnJztcbiAgICAgICAgICAgIC8vIHN0eWxldGV4dCArPSAodGhpcy5wYWRkaW5nQm90dG9tKSA/ICdwYWRkaW5nLWJvdHRvbTonK3RoaXMucGFkZGluZ0JvdHRvbSsnOycgOiAnJztcbiAgICAgICAgICAgIC8vIHRoaXMuX2VsZW0gPSAkKCc8ZGl2IGNsYXNzPVwianFwbG90LXRpdGxlXCIgc3R5bGU9XCInK3N0eWxldGV4dCsnXCI+Jyt0aGlzLnRleHQrJzwvZGl2PicpO1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuZm9udEZhbWlseSkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuX2VsZW0uY3NzKCdmb250LWZhbWlseScsIHRoaXMuZm9udEZhbWlseSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuRGl2VGl0bGVSZW5kZXJlci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvIGhlcmVcbiAgICB9O1xuICBcblxuICAgIHZhciBkb3RsZW4gPSAwLjE7XG5cbiAgICAkLmpxcGxvdC5MaW5lUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgsIHBhdHRlcm4pIHtcblxuICAgICAgICB2YXIgZGVmYXVsdExpbmVQYXR0ZXJucyA9IHtcbiAgICAgICAgICAgIGRvdHRlZDogWyBkb3RsZW4sICQuanFwbG90LmNvbmZpZy5kb3RHYXBMZW5ndGggXSxcbiAgICAgICAgICAgIGRhc2hlZDogWyAkLmpxcGxvdC5jb25maWcuZGFzaExlbmd0aCwgJC5qcXBsb3QuY29uZmlnLmdhcExlbmd0aCBdLFxuICAgICAgICAgICAgc29saWQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocGF0dGVyblswXSA9PT0gJy4nIHx8IHBhdHRlcm5bMF0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gcGF0dGVybjtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBpbWF4PXMubGVuZ3RoOyBpPGltYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tpXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnB1c2goIGRvdGxlbiApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbaV0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5wdXNoKCAkLmpxcGxvdC5jb25maWcuZGFzaExlbmd0aCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5wdXNoKCAkLmpxcGxvdC5jb25maWcuZ2FwTGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IGRlZmF1bHRMaW5lUGF0dGVybnNbcGF0dGVybl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShwYXR0ZXJuICYmIHBhdHRlcm4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXR0ZXJuSW5kZXggPSAwO1xuICAgICAgICB2YXIgcGF0dGVybkRpc3RhbmNlID0gcGF0dGVyblswXTtcbiAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgdmFyIHBhdGh4MCA9IDA7XG4gICAgICAgIHZhciBwYXRoeTAgPSAwO1xuXG4gICAgICAgIHZhciBtb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyggeCwgeSApO1xuICAgICAgICAgICAgcHggPSB4O1xuICAgICAgICAgICAgcHkgPSB5O1xuICAgICAgICAgICAgcGF0aHgwID0geDtcbiAgICAgICAgICAgIHBhdGh5MCA9IHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgICAgdmFyIGR4ID0geCAtIHB4O1xuICAgICAgICAgICAgdmFyIGR5ID0geSAtIHB5O1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHgrZHkqZHkpO1xuICAgICAgICAgICAgaWYgKChkaXN0ID4gMCkgJiYgKHNjYWxlID4gMCkpIHtcbiAgICAgICAgICAgICAgICBkeCAvPSBkaXN0O1xuICAgICAgICAgICAgICAgIGR5IC89IGRpc3Q7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwID0gc2NhbGUgKiBwYXR0ZXJuRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcCA8IGRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4ICs9IGRwICogZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBweSArPSBkcCAqIGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXR0ZXJuSW5kZXggJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyggcHgsIHB5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKCBweCwgcHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgLT0gZHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuSW5kZXggPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybkRpc3RhbmNlID0gcGF0dGVybltwYXR0ZXJuSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXR0ZXJuSW5kZXggJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyggcHgsIHB5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKCBweCwgcHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5EaXN0YW5jZSAtPSBkaXN0IC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaW5lVG8oIHBhdGh4MCwgcGF0aHkwICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdmVUbzogbW92ZVRvLFxuICAgICAgICAgICAgbGluZVRvOiBsaW5lVG8sXG4gICAgICAgICAgICBiZWdpblBhdGg6IGJlZ2luUGF0aCxcbiAgICAgICAgICAgIGNsb3NlUGF0aDogY2xvc2VQYXRoXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIENsYXNzOiAkLmpxcGxvdC5MaW5lUmVuZGVyZXJcbiAgICAvLyBUaGUgZGVmYXVsdCBsaW5lIHJlbmRlcmVyIGZvciBqcVBsb3QsIHRoaXMgY2xhc3MgaGFzIG5vIG9wdGlvbnMgYmV5b25kIHRoZSA8U2VyaWVzPiBjbGFzcy5cbiAgICAvLyBEcmF3cyBzZXJpZXMgYXMgYSBsaW5lLlxuICAgICQuanFwbG90LkxpbmVSZW5kZXJlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc2hhcGVSZW5kZXJlciA9IG5ldyAkLmpxcGxvdC5TaGFwZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuc2hhZG93UmVuZGVyZXIgPSBuZXcgJC5qcXBsb3QuU2hhZG93UmVuZGVyZXIoKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIGNhbGxlZCB3aXRoIHNjb3BlIG9mIHNlcmllcy5cbiAgICAkLmpxcGxvdC5MaW5lUmVuZGVyZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zLCBwbG90KSB7XG4gICAgICAgIC8vIEdyb3VwOiBQcm9wZXJ0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLl90eXBlPSdsaW5lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hbmltYXRpb24gPSB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgc3BlZWQ6IDI1MDAsXG4gICAgICAgICAgICBfc3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIHByb3A6IHNtb290aFxuICAgICAgICAvLyBUcnVlIHRvIGRyYXcgYSBzbW9vdGhlZCAoaW50ZXJwb2xhdGVkKSBsaW5lIHRocm91Z2ggdGhlIGRhdGEgcG9pbnRzXG4gICAgICAgIC8vIHdpdGggYXV0b21hdGljYWxseSBjb21wdXRlZCBudW1iZXIgb2Ygc21vb3RoaW5nIHBvaW50cy5cbiAgICAgICAgLy8gU2V0IHRvIGFuIGludGVnZXIgbnVtYmVyID4gMiB0byBzcGVjaWZ5IG51bWJlciBvZiBzbW9vdGhpbmcgcG9pbnRzXG4gICAgICAgIC8vIHRvIHVzZSBiZXR3ZWVuIGVhY2ggZGF0YSBwb2ludC5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zbW9vdGggPSBmYWxzZTsgIC8vIHRydWUgb3IgYSBudW1iZXIgPiAyIGZvciBzbW9vdGhpbmcuXG4gICAgICAgIHRoaXMucmVuZGVyZXIudGVuc2lvbiA9IG51bGw7IC8vIG51bGwgdG8gYXV0byBjb21wdXRlIG9yIGEgbnVtYmVyIHR5cGljYWxseSA+IDYuICBGZXdlciBwb2ludHMgcmVxdWlyZXMgaGlnaGVyIHRlbnNpb24uXG4gICAgICAgIC8vIHByb3A6IGNvbnN0cmFpblNtb290aGluZ1xuICAgICAgICAvLyBUcnVlIHRvIHVzZSBhIG1vcmUgYWNjdXJhdGUgc21vb3RoaW5nIGFsZ29yaXRobSB0aGF0IHdpbGxcbiAgICAgICAgLy8gbm90IG92ZXJzaG9vdCBhbnkgZGF0YSBwb2ludHMuICBGYWxzZSB0byBhbGxvdyBvdmVyc2hvb3QgYnV0XG4gICAgICAgIC8vIHByb2R1Y2UgYSBzbW9vdGhlciBsb29raW5nIGxpbmUuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuY29uc3RyYWluU21vb3RoaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcyBpcyBzbW9vdGhlZCBkYXRhIGluIGdyaWQgY29vcmRpbmF0ZXMsIGxpa2UgZ3JpZERhdGFcbiAgICAgICAgdGhpcy5yZW5kZXJlci5fc21vb3RoZWREYXRhID0gW107XG4gICAgICAgIC8vIHRoaXMgaXMgc21vb3RoZWQgZGF0YSBpbiBwbG90IHVuaXRzIChwbG90IGNvb3JkaW5hdGVzKSwgbGlrZSBwbG90RGF0YS5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5fc21vb3RoZWRQbG90RGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kR3JpZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5faGlCYW5kU21vb3RoZWREYXRhID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX2xvd0JhbmRTbW9vdGhlZERhdGEgPSBbXTtcblxuICAgICAgICAvLyBwcm9wOiBiYW5kRGF0YVxuICAgICAgICAvLyBEYXRhIHVzZWQgdG8gZHJhdyBlcnJvciBiYW5kcyBvciBjb25maWRlbmNlIGludGVydmFscyBhYm92ZS9iZWxvdyBhIGxpbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJhbmREYXRhIGNhbiBiZSBpbnB1dCBpbiAzIGZvcm1zLiAganFQbG90IHdpbGwgZmlndXJlIG91dCB3aGljaCBpcyB0aGVcbiAgICAgICAgLy8gbG93IGJhbmQgbGluZSBhbmQgd2hpY2ggaXMgdGhlIGhpZ2ggYmFuZCBsaW5lIGZvciBhbGwgZm9ybXM6XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBBIDIgZGltZW5zaW9uYWwgYXJyYXkgbGlrZSBbW3lsMSwgeWwyLCAuLi5dLCBbeXUxLCB5dTIsIC4uLl1dIHdoZXJlXG4gICAgICAgIC8vIFt5bDEsIHlsMiwgLi4uXSBhcmUgeSB2YWx1ZXMgb2YgdGhlIGxvd2VyIGxpbmUgYW5kXG4gICAgICAgIC8vIFt5dTEsIHl1MiwgLi4uXSBhcmUgeSB2YWx1ZXMgb2YgdGhlIHVwcGVyIGxpbmUuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB0aGVyZSBtdXN0IGJlIHRoZSBzYW1lIG51bWJlciBvZiB5IGRhdGEgcG9pbnRzIGFzIGRhdGEgcG9pbnRzXG4gICAgICAgIC8vIGluIHRoZSBzZXJpZXMgYW5kIHRoZSBiYW5kcyB3aWxsIGluaGVyaXQgdGhlIHggdmFsdWVzIG9mIHRoZSBzZXJpZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgMiBkaW1lbnNpb25hbCBhcnJheSBsaWtlIFtbW3hsMSwgeWwxXSwgW3hsMiwgeWwyXSwgLi4uXSwgW1t4aDEsIHloMV0sIFt4aDIsIHloMl0sIC4uLl1dXG4gICAgICAgIC8vIHdoZXJlIFt4bDEsIHlsMV0gYXJlIHgseSBkYXRhIHBvaW50cyBmb3IgdGhlIGxvd2VyIGxpbmUgYW5kXG4gICAgICAgIC8vIFt4aDEsIHloMV0gYXJlIHgseSBkYXRhIHBvaW50cyBmb3IgdGhlIGhpZ2ggbGluZS5cbiAgICAgICAgLy8geCB2YWx1ZXMgZG8gbm90IGhhdmUgdG8gY29ycmVzcG9uZCB0byB0aGUgeCB2YWx1ZXMgb2YgdGhlIHNlcmllcyBhbmQgY2FuXG4gICAgICAgIC8vIGJlIG9mIGFueSBhcmJpdHJhcnkgbGVuZ3RoLlxuICAgICAgICAvL1xuICAgICAgICAvLyBDYW4gYmUgb2YgZm9ybSBbW3lsMSwgeXUxXSwgW3lsMiwgeXUyXSwgW3lsMywgeXUzXSwgLi4uXSB3aGVyZVxuICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIDMgb3IgbW9yZSBhcnJheXMgYW5kIHRoZXJlIG11c3QgYmUgdGhlIHNhbWUgbnVtYmVyIG9mIGFycmF5c1xuICAgICAgICAvLyBhcyB0aGVyZSBhcmUgZGF0YSBwb2ludHMgaW4gdGhlIHNlcmllcy4gIEluIHRoaXMgY2FzZSwgXG4gICAgICAgIC8vIFt5bDEsIHl1MV0gc3BlY2lmaWVzIHRoZSBsb3dlciBhbmQgdXBwZXIgeSB2YWx1ZXMgZm9yIHRoZSAxc3RcbiAgICAgICAgLy8gZGF0YSBwb2ludCBhbmQgc28gb24uICBUaGUgYmFuZHMgd2lsbCBpbmhlcml0IHRoZSB4XG4gICAgICAgIC8vIHZhbHVlcyBmcm9tIHRoZSBzZXJpZXMuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmFuZERhdGEgPSBbXTtcblxuICAgICAgICAvLyBHcm91cDogYmFuZHNcbiAgICAgICAgLy8gQmFuZGluZyBhcm91bmQgbGluZSwgZS5nIGVycm9yIGJhbmRzIG9yIGNvbmZpZGVuY2UgaW50ZXJ2YWxzLlxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJhbmRzID0ge1xuICAgICAgICAgICAgLy8gcHJvcDogc2hvd1xuICAgICAgICAgICAgLy8gdHJ1ZSB0byBzaG93IHRoZSBiYW5kcy4gIElmIGJhbmREYXRhIG9yIGludGVydmFsIGlzXG4gICAgICAgICAgICAvLyBzdXBwbGllZCwgc2hvdyB3aWxsIGJlIHNldCB0byB0cnVlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGhpRGF0YTogW10sXG4gICAgICAgICAgICBsb3dEYXRhOiBbXSxcbiAgICAgICAgICAgIC8vIHByb3A6IGNvbG9yXG4gICAgICAgICAgICAvLyBjb2xvciBvZiBsaW5lcyBhdCB0b3AgYW5kIGJvdHRvbSBvZiBiYW5kcyBbZGVmYXVsdDogc2VyaWVzIGNvbG9yXS5cbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgLy8gcHJvcDogc2hvd0xpbmVzXG4gICAgICAgICAgICAvLyBUcnVlIHRvIHNob3cgbGluZXMgYXQgdG9wIGFuZCBib3R0b20gb2YgYmFuZHMgW2RlZmF1bHQ6IGZhbHNlXS5cbiAgICAgICAgICAgIHNob3dMaW5lczogZmFsc2UsXG4gICAgICAgICAgICAvLyBwcm9wOiBmaWxsXG4gICAgICAgICAgICAvLyBUcnVlIHRvIGZpbGwgYXJlYSBiZXR3ZWVuIGJhbmRzIFtkZWZhdWx0OiB0cnVlXS5cbiAgICAgICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgICAgICAvLyBwcm9wOiBmaWxsQ29sb3JcbiAgICAgICAgICAgIC8vIGNzcyBjb2xvciBzcGVjIGZvciBmaWxsZWQgYXJlYS4gIFtkZWZhdWx0OiBzZXJpZXMgY29sb3JdLlxuICAgICAgICAgICAgZmlsbENvbG9yOiBudWxsLFxuICAgICAgICAgICAgX21pbjogbnVsbCxcbiAgICAgICAgICAgIF9tYXg6IG51bGwsXG4gICAgICAgICAgICAvLyBwcm9wOiBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gVXNlciBzcGVjaWZpZWQgaW50ZXJ2YWwgYWJvdmUgYW5kIGJlbG93IGxpbmUgZm9yIGJhbmRzIFtkZWZhdWx0OiAnMyUnJ10uXG4gICAgICAgICAgICAvLyBDYW4gYmUgYSB2YWx1ZSBsaWtlIDMgb3IgYSBzdHJpbmcgbGlrZSAnMyUnIFxuICAgICAgICAgICAgLy8gb3IgYW4gdXBwZXIvbG93ZXIgYXJyYXkgbGlrZSBbMSwgLTJdIG9yIFsnMiUnLCAnLTEuNSUnXVxuICAgICAgICAgICAgaW50ZXJ2YWw6ICczJSdcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBsb3B0cyA9IHtoaWdobGlnaHRNb3VzZU92ZXI6IG9wdGlvbnMuaGlnaGxpZ2h0TW91c2VPdmVyLCBoaWdobGlnaHRNb3VzZURvd246IG9wdGlvbnMuaGlnaGxpZ2h0TW91c2VEb3duLCBoaWdobGlnaHRDb2xvcjogb3B0aW9ucy5oaWdobGlnaHRDb2xvcn07XG4gICAgICAgIFxuICAgICAgICBkZWxldGUgKG9wdGlvbnMuaGlnaGxpZ2h0TW91c2VPdmVyKTtcbiAgICAgICAgZGVsZXRlIChvcHRpb25zLmhpZ2hsaWdodE1vdXNlRG93bik7XG4gICAgICAgIGRlbGV0ZSAob3B0aW9ucy5oaWdobGlnaHRDb2xvcik7XG4gICAgICAgIFxuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLnJlbmRlcmVyLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBnaXZlbiBzb21lIGJhbmQgZGF0YSwgYW5kIGJhbmRzIGFyZW4ndCBleHBsaWNpdHkgc2V0IHRvIGZhbHNlIGluIG9wdGlvbnMsIHR1cm4gdGhlbSBvbi5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuYmFuZERhdGEubGVuZ3RoID4gMSAmJiAoIW9wdGlvbnMuYmFuZHMgfHwgb3B0aW9ucy5iYW5kcy5zaG93ID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmJhbmRzLnNob3cgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIGdpdmVuIGFuIGludGVydmFsLCBhbmQgYmFuZHMgYXJlbid0IGV4cGxpY2l0eSBzZXQgdG8gZmFsc2UgaW4gb3B0aW9ucywgdHVybiB0aGVtIG9uLlxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJhbmRzICYmIG9wdGlvbnMuYmFuZHMuc2hvdyA9PSBudWxsICYmIG9wdGlvbnMuYmFuZHMuaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iYW5kcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHBsb3QgaXMgZmlsbGVkLCB0dXJuIG9mZiBiYW5kcy5cbiAgICAgICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iYW5kcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5iYW5kcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXRCYW5kcy5jYWxsKHRoaXMsIHRoaXMucmVuZGVyZXIub3B0aW9ucywgcGxvdCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHNtb290aGluZyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHN0YWNrZWQgbGluZXMsIGRpc2FibGVcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNtb290aCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBzaGFwZSByZW5kZXJlciBvcHRpb25zXG4gICAgICAgIHZhciBvcHRzID0ge2xpbmVKb2luOnRoaXMubGluZUpvaW4sIGxpbmVDYXA6dGhpcy5saW5lQ2FwLCBmaWxsOnRoaXMuZmlsbCwgaXNhcmM6ZmFsc2UsIHN0cm9rZVN0eWxlOnRoaXMuY29sb3IsIGZpbGxTdHlsZTp0aGlzLmZpbGxDb2xvciwgbGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lUGF0dGVybjp0aGlzLmxpbmVQYXR0ZXJuLCBjbG9zZVBhdGg6dGhpcy5maWxsfTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFwZVJlbmRlcmVyLmluaXQob3B0cyk7XG5cbiAgICAgICAgdmFyIHNoYWRvd19vZmZzZXQgPSBvcHRpb25zLnNoYWRvd09mZnNldDtcbiAgICAgICAgLy8gc2V0IHRoZSBzaGFkb3cgcmVuZGVyZXIgb3B0aW9uc1xuICAgICAgICBpZiAoc2hhZG93X29mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgc2hhZG93T2Zmc2V0IHRvIHRoZSB3aWR0aCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVXaWR0aCA+IDIuNSkge1xuICAgICAgICAgICAgICAgIHNoYWRvd19vZmZzZXQgPSAxLjI1ICogKDEgKyAoTWF0aC5hdGFuKCh0aGlzLmxpbmVXaWR0aC8yLjUpKS8wLjc4NTM5ODE2MyAtIDEpKjAuNik7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHNoYWRvd19vZmZzZXQgPSB0aGlzLnNoYWRvd09mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBza2lubnkgbGluZXMsIGRvbid0IG1ha2Ugc3VjaCBhIGJpZyBzaGFkb3cuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFkb3dfb2Zmc2V0ID0gMS4yNSAqIE1hdGguYXRhbigodGhpcy5saW5lV2lkdGgvMi41KSkvMC43ODUzOTgxNjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzb3B0cyA9IHtsaW5lSm9pbjp0aGlzLmxpbmVKb2luLCBsaW5lQ2FwOnRoaXMubGluZUNhcCwgZmlsbDp0aGlzLmZpbGwsIGlzYXJjOmZhbHNlLCBhbmdsZTp0aGlzLnNoYWRvd0FuZ2xlLCBvZmZzZXQ6c2hhZG93X29mZnNldCwgYWxwaGE6dGhpcy5zaGFkb3dBbHBoYSwgZGVwdGg6dGhpcy5zaGFkb3dEZXB0aCwgbGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lUGF0dGVybjp0aGlzLmxpbmVQYXR0ZXJuLCBjbG9zZVBhdGg6dGhpcy5maWxsfTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5pbml0KHNvcHRzKTtcbiAgICAgICAgdGhpcy5fYXJlYVBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9ib3VuZGluZ0JveCA9IFtbXSxbXV07XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuaXNUcmVuZGxpbmUgJiYgdGhpcy5maWxsIHx8IHRoaXMucmVuZGVyZXIuYmFuZHMuc2hvdykge1xuICAgICAgICAgICAgLy8gR3JvdXA6IFByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vICAgICAgICBcbiAgICAgICAgICAgIC8vIHByb3A6IGhpZ2hsaWdodE1vdXNlT3ZlclxuICAgICAgICAgICAgLy8gVHJ1ZSB0byBoaWdobGlnaHQgYXJlYSBvbiBhIGZpbGxlZCBwbG90IHdoZW4gbW91c2VkIG92ZXIuXG4gICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZmFsc2UgdG8gZW5hYmxlIGhpZ2hsaWdodE1vdXNlRG93biB0byBoaWdobGlnaHQgd2hlbiBjbGlja2luZyBvbiBhbiBhcmVhIG9uIGEgZmlsbGVkIHBsb3QuXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE1vdXNlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICAvLyBwcm9wOiBoaWdobGlnaHRNb3VzZURvd25cbiAgICAgICAgICAgIC8vIFRydWUgdG8gaGlnaGxpZ2h0IHdoZW4gYSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBvdmVyIGFuIGFyZWEgb24gYSBmaWxsZWQgcGxvdC5cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBkaXNhYmxlZCBpZiBoaWdobGlnaHRNb3VzZU92ZXIgaXMgdHJ1ZS5cbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0TW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBwcm9wOiBoaWdobGlnaHRDb2xvclxuICAgICAgICAgICAgLy8gY29sb3IgdG8gdXNlIHdoZW4gaGlnaGxpZ2h0aW5nIGFuIGFyZWEgb24gYSBmaWxsZWQgcGxvdC5cbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29sb3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gaWYgdXNlciBoYXMgcGFzc2VkIGluIGhpZ2hsaWdodE1vdXNlRG93biBvcHRpb24gYW5kIG5vdCBzZXQgaGlnaGxpZ2h0TW91c2VPdmVyLCBkaXNhYmxlIGhpZ2hsaWdodE1vdXNlT3ZlclxuICAgICAgICAgICAgaWYgKGxvcHRzLmhpZ2hsaWdodE1vdXNlRG93biAmJiBsb3B0cy5oaWdobGlnaHRNb3VzZU92ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvcHRzLmhpZ2hsaWdodE1vdXNlT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIHtoaWdobGlnaHRNb3VzZU92ZXI6IGxvcHRzLmhpZ2hsaWdodE1vdXNlT3ZlciwgaGlnaGxpZ2h0TW91c2VEb3duOiBsb3B0cy5oaWdobGlnaHRNb3VzZURvd24sIGhpZ2hsaWdodENvbG9yOiBsb3B0cy5oaWdobGlnaHRDb2xvcn0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGlnaGxpZ2h0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmMgPSAodGhpcy5yZW5kZXJlci5iYW5kcy5zaG93KSA/IHRoaXMucmVuZGVyZXIuYmFuZHMuZmlsbENvbG9yIDogdGhpcy5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb2xvciA9ICQuanFwbG90LmNvbXB1dGVIaWdobGlnaHRDb2xvcnMoZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHVybiBvZmYgKGRpc2FibGUpIHRoZSBoaWdobGlnaHRlciBwbHVnaW5cbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlci5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5pc1RyZW5kbGluZSAmJiBwbG90KSB7XG4gICAgICAgICAgICBwbG90LnBsdWdpbnMubGluZVJlbmRlcmVyID0ge307XG4gICAgICAgICAgICBwbG90LnBvc3RJbml0SG9va3MuYWRkT25jZShwb3N0SW5pdCk7XG4gICAgICAgICAgICBwbG90LnBvc3REcmF3SG9va3MuYWRkT25jZShwb3N0UGxvdERyYXcpO1xuICAgICAgICAgICAgcGxvdC5ldmVudExpc3RlbmVySG9va3MuYWRkT25jZSgnanFwbG90TW91c2VNb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICAgICAgICBwbG90LmV2ZW50TGlzdGVuZXJIb29rcy5hZGRPbmNlKCdqcXBsb3RNb3VzZURvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgICAgICAgICAgcGxvdC5ldmVudExpc3RlbmVySG9va3MuYWRkT25jZSgnanFwbG90TW91c2VVcCcsIGhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgcGxvdC5ldmVudExpc3RlbmVySG9va3MuYWRkT25jZSgnanFwbG90Q2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICAgICAgICBwbG90LmV2ZW50TGlzdGVuZXJIb29rcy5hZGRPbmNlKCdqcXBsb3RSaWdodENsaWNrJywgaGFuZGxlUmlnaHRDbGljayk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAkLmpxcGxvdC5MaW5lUmVuZGVyZXIucHJvdG90eXBlLmluaXRCYW5kcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIHBsb3QpIHtcbiAgICAgICAgLy8gdXNlIGJhbmREYXRhIGlmIG5vIGRhdGEgc3BlY2lmaWVkIGluIGJhbmRzIG9wdGlvblxuICAgICAgICAvL3ZhciBiZCA9IHRoaXMucmVuZGVyZXIuYmFuZERhdGE7XG4gICAgICAgIHZhciBiZCA9IG9wdGlvbnMuYmFuZERhdGEgfHwgW107XG4gICAgICAgIHZhciBiYW5kcyA9IHRoaXMucmVuZGVyZXIuYmFuZHM7XG4gICAgICAgIGJhbmRzLmhpRGF0YSA9IFtdO1xuICAgICAgICBiYW5kcy5sb3dEYXRhID0gW107XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBiYW5kcy5fbWF4ID0gbnVsbDtcbiAgICAgICAgYmFuZHMuX21pbiA9IG51bGw7XG4gICAgICAgIC8vIElmIDIgYXJyYXlzLCBhbmQgZWFjaCBhcnJheSBncmVhdGVyIHRoYW4gMiBlbGVtZW50cywgYXNzdW1lIGl0IGlzIGhpIGFuZCBsb3cgZGF0YSBiYW5kcyBvZiB5IHZhbHVlcy5cbiAgICAgICAgaWYgKGJkLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAvLyBEbyB3ZSBoYXZlIGFuIGFycmF5IG9mIHgseSB2YWx1ZXM/XG4gICAgICAgICAgICAvLyBsaWtlIFtbWzEsMV0sIFsyLDRdLCBbMywzXV0sIFtbMSwzXSwgWzIsNl0sIFszLDVdXV1cbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoYmRbMF1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgYW4gYXJiaXRyYXJ5IGFycmF5IG9mIHBvaW50cywgc3BpbiB0aHJvdWdoIGFsbCBvZiB0aGVtIHRvIGRldGVybWluZSBtYXggYW5kIG1pbiBsaW5lcy5cblxuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIHZhciBiZG1pbmlkeCA9IDAsIGJkbWF4aWR4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJkWzBdLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGJkWzBdW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBbMV0gIT0gbnVsbCAmJiBwWzFdID4gYmFuZHMuX21heCkgfHwgYmFuZHMuX21heCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5fbWF4ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBbMV0gIT0gbnVsbCAmJiBwWzFdIDwgYmFuZHMuX21pbikgfHwgYmFuZHMuX21pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5fbWluID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJkWzFdLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGJkWzFdW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBbMV0gIT0gbnVsbCAmJiBwWzFdID4gYmFuZHMuX21heCkgfHwgYmFuZHMuX21heCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5fbWF4ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJkbWF4aWR4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBbMV0gIT0gbnVsbCAmJiBwWzFdIDwgYmFuZHMuX21pbikgfHwgYmFuZHMuX21pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5fbWluID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJkbWluaWR4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiZG1heGlkeCA9PT0gYmRtaW5pZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFuZHMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJhbmRzLmhpRGF0YSA9IGJkW2JkbWF4aWR4XTtcbiAgICAgICAgICAgICAgICBiYW5kcy5sb3dEYXRhID0gYmRbYmRtaW5pZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBkYXRhIGlzIGFycmF5cyBvZiB5IHZhbHVlc1xuICAgICAgICAgICAgLy8gbGlrZSBbWzEsNCwzXSwgWzMsNiw1XV1cbiAgICAgICAgICAgIC8vIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBiYW5kIGRhdGEgcG9pbnRzIGFzIHBvaW50cyBpbiBzZXJpZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKGJkWzBdLmxlbmd0aCA9PT0gZGF0YS5sZW5ndGggJiYgYmRbMV0ubGVuZ3RoID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBoaSA9IChiZFswXVswXSA+IGJkWzFdWzBdKSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIHZhciBsb3cgPSAoaGkpID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsPWRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbmRzLmhpRGF0YS5wdXNoKFtkYXRhW2ldWzBdLCBiZFtoaV1baV1dKTtcbiAgICAgICAgICAgICAgICAgICAgYmFuZHMubG93RGF0YS5wdXNoKFtkYXRhW2ldWzBdLCBiZFtsb3ddW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHByb3BlciBkYXRhIGFycmF5LCBkb24ndCBzaG93IGJhbmRzLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFuZHMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIDIgYXJyYXlzLCBoYXZlIGFycmF5cyBvZiBbeWxvdywgeWhpXSB2YWx1ZXMuXG4gICAgICAgIC8vIG5vdGUsIGNhbid0IGRpc3Rpbmd1aXNoIGNhc2Ugb2YgW1t5bG93LCB5aGldLCBbeWxvdywgeWhpXV0gZnJvbSBbW3lsb3csIHlsb3ddLCBbeWhpLCB5aGldXVxuICAgICAgICAvLyB0aGlzIGlzIGFzc3VtZWQgdG8gYmUgb2YgdGhlIGxhdHRlciBmb3JtLlxuICAgICAgICBlbHNlIGlmIChiZC5sZW5ndGggPiAyICYmICEkLmlzQXJyYXkoYmRbMF1bMF0pKSB7XG4gICAgICAgICAgICB2YXIgaGkgPSAoYmRbMF1bMF0gPiBiZFswXVsxXSkgPyAwIDogMTtcbiAgICAgICAgICAgIHZhciBsb3cgPSAoaGkpID8gMCA6IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9YmQubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhbmRzLmhpRGF0YS5wdXNoKFtkYXRhW2ldWzBdLCBiZFtpXVtoaV1dKTtcbiAgICAgICAgICAgICAgICBiYW5kcy5sb3dEYXRhLnB1c2goW2RhdGFbaV1bMF0sIGJkW2ldW2xvd11dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IGhhdmUgcHJvcGVyIGRhdGEsIGF1dG8gY2FsY3VsYXRlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludHJ2ID0gYmFuZHMuaW50ZXJ2YWw7XG4gICAgICAgICAgICB2YXIgYSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgYiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgYWZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGJmdW5jID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShpbnRydikpIHtcbiAgICAgICAgICAgICAgICBhID0gaW50cnZbMF07XG4gICAgICAgICAgICAgICAgYiA9IGludHJ2WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYSA9IGludHJ2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oYSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKGEuY2hhckF0KGEubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICBhZnVuYyA9ICdtdWx0aXBseSc7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpLzEwMCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcbiAgICAgICAgICAgICAgICBhZnVuYyA9ICdhZGQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYiAhPT0gbnVsbCAmJiBpc05hTihiKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoYi5jaGFyQXQoYi5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJmdW5jID0gJ211bHRpcGx5JztcbiAgICAgICAgICAgICAgICAgICAgYiA9IHBhcnNlRmxvYXQoYikvMTAwICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiID0gcGFyc2VGbG9hdChiKTtcbiAgICAgICAgICAgICAgICBiZnVuYyA9ICdhZGQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgYmZ1bmMgPSBhZnVuYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmdW5jID09PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYSBhbHdheXMgYXBwbGllcyB0byBoaSBiYW5kLlxuICAgICAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgICAgICAgICBiID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGFmdW5jO1xuICAgICAgICAgICAgICAgICAgICBhZnVuYyA9IGJmdW5jO1xuICAgICAgICAgICAgICAgICAgICBiZnVuYyA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhZnVuYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5oaURhdGEucHVzaChbZGF0YVtpXVswXSwgZGF0YVtpXVsxXSArIGFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5oaURhdGEucHVzaChbZGF0YVtpXVswXSwgZGF0YVtpXVsxXSAqIGFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbmRzLmxvd0RhdGEucHVzaChbZGF0YVtpXVswXSwgZGF0YVtpXVsxXSArIGJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYW5kcy5sb3dEYXRhLnB1c2goW2RhdGFbaV1bMF0sIGRhdGFbaV1bMV0gKiBiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhbmRzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZCA9IGJhbmRzLmhpRGF0YTtcbiAgICAgICAgdmFyIGxkID0gYmFuZHMubG93RGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBoZC5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGhkW2ldWzFdICE9IG51bGwgJiYgaGRbaV1bMV0gPiBiYW5kcy5fbWF4KSB8fCBiYW5kcy5fbWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYW5kcy5fbWF4ID0gaGRbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsZC5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGxkW2ldWzFdICE9IG51bGwgJiYgbGRbaV1bMV0gPCBiYW5kcy5fbWluKSB8fCBiYW5kcy5fbWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYW5kcy5fbWluID0gbGRbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmUgbGFzdCBjaGVjayBmb3IgcHJvcGVyIGRhdGFcbiAgICAgICAgLy8gdGhlc2UgZG9uJ3QgYXBwbHkgYW55IG1vcmUgc2luY2UgYWxsb3dpbmcgYXJiaXRyYXJ5IHgseSB2YWx1ZXNcbiAgICAgICAgLy8gaWYgKGJhbmRzLmhpRGF0YS5sZW5ndGggIT0gYmFuZHMubG93RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gICAgIGJhbmRzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChiYW5kcy5oaURhdGEubGVuZ3RoICE9IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gICAgIGJhbmRzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChiYW5kcy5maWxsQ29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjID0gJC5qcXBsb3QuZ2V0Q29sb3JDb21wb25lbnRzKGJhbmRzLmNvbG9yKTtcbiAgICAgICAgICAgIC8vIG5vdyBhZGp1c3QgYWxwaGEgdG8gZGlmZmVyZW50aWF0ZSBmaWxsXG4gICAgICAgICAgICBjWzNdID0gY1szXSAqIDAuNTtcbiAgICAgICAgICAgIGJhbmRzLmZpbGxDb2xvciA9ICdyZ2JhKCcgKyBjWzBdICsnLCAnKyBjWzFdICsnLCAnKyBjWzJdICsnLCAnKyBjWzNdICsgJyknO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFN0ZXBzIChkLCBmKSB7XG4gICAgICAgIHJldHVybiAoMy40MTgyMDU0K2YpICogTWF0aC5wb3coZCwgLTAuMzUzNDk5Mik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVN0ZXBzIChkMSwgZDIpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoTWF0aC5wb3coKGQyWzBdLSBkMVswXSksIDIpICsgTWF0aC5wb3cgKChkMlsxXSAtIGQxWzFdKSwgMikpO1xuICAgICAgICByZXR1cm4gNS43NjQ4ICogTWF0aC5sb2cocykgKyA3LjQ0NTY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFuaCAoeCkge1xuICAgICAgICB2YXIgYSA9IChNYXRoLmV4cCgyKngpIC0gMSkgLyAoTWF0aC5leHAoMip4KSArIDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vXG4gICAgLy8gY29tcHV0ZUNvbnN0cmFpbmVkU21vb3RoZWREYXRhXG4gICAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbnN0cmFpbmVkIGN1YmljIHNwbGluZSBpbnRlcnBvbGF0aW9uXG4gICAgLy8gbWV0aG9kIGFzIHByZXNlbnRlZCBpbjpcbiAgICAvL1xuICAgIC8vIEtydWdlciwgQ0pDLCBDb25zdHJhaW5lZCBDdWJpYyBTcGluZSBJbnRlcnBvbGF0aW9uIGZvciBDaGVtaWNhbCBFbmdpbmVlcmluZyBBcHBsaWNhdGlvbnNcbiAgICAvLyBodHRwOi8vd3d3LmtvcmYuY28udWsvc3BsaW5lLnBkZlxuICAgIC8vXG4gICAgLy8gVGhlIGltcGxlbWVudGF0aW9uIGJlbG93IGJvcnJvd3MgaGVhdmlseSBmcm9tIHRoZSBzYW1wbGUgVmlzdWFsIEJhc2ljXG4gICAgLy8gaW1wbGVtZW50YXRpb24gYnkgQ0pDIEtydWdlciBmb3VuZCBpbiBodHRwOi8vd3d3LmtvcmYuY28udWsvc3BsaW5lLnhsc1xuICAgIC8vXG4gICAgLy8vLy8vLy8vXG5cbiAgICAvLyBjYWxsZWQgd2l0aCBzY29wZSBvZiBzZXJpZXNcbiAgICBmdW5jdGlvbiBjb21wdXRlQ29uc3RyYWluZWRTbW9vdGhlZERhdGEgKGdkKSB7XG4gICAgICAgIHZhciBzbW9vdGggPSB0aGlzLnJlbmRlcmVyLnNtb290aDtcbiAgICAgICAgdmFyIGRpbSA9IHRoaXMuY2FudmFzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB4cCA9IHRoaXMuX3hheGlzLnNlcmllc19wMnU7XG4gICAgICAgIHZhciB5cCA9IHRoaXMuX3lheGlzLnNlcmllc19wMnU7IFxuICAgICAgICB2YXIgc3RlcHMgPW51bGw7XG4gICAgICAgIHZhciBfc3RlcHMgPSBudWxsO1xuICAgICAgICB2YXIgZGlzdCA9IGdkLmxlbmd0aC9kaW07XG4gICAgICAgIHZhciBfc21vb3RoZWREYXRhID0gW107XG4gICAgICAgIHZhciBfc21vb3RoZWRQbG90RGF0YSA9IFtdO1xuXG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChzbW9vdGgpKSkge1xuICAgICAgICAgICAgc3RlcHMgPSBwYXJzZUZsb2F0KHNtb290aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGVwcyA9IGdldFN0ZXBzKGRpc3QsIDAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeXkgPSBbXTtcbiAgICAgICAgdmFyIHh4ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaT0wLCBsID0gZ2QubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgeXkucHVzaChnZFtpXVsxXSk7XG4gICAgICAgICAgICB4eC5wdXNoKGdkW2ldWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGR4eCh4MSwgeDApIHtcbiAgICAgICAgICAgIGlmICh4MSAtIHgwID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgxIC0geDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgQSwgQiwgQywgRDtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggbGluZSBzZWdtZW50LiAgSGF2ZSAjIHBvaW50cyAtIDEgbGluZSBzZWdtZW50cy4gIE5tYmVyIHNlZ21lbnRzIHN0YXJ0aW5nIGF0IDEuXG4gICAgICAgIHZhciBubWF4ID0gZ2QubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgbnVtID0gMSwgZ2RsID0gZ2QubGVuZ3RoOyBudW08Z2RsOyBudW0rKykge1xuICAgICAgICAgICAgdmFyIGd4eCA9IFtdO1xuICAgICAgICAgICAgdmFyIGdneHggPSBbXTtcbiAgICAgICAgICAgIC8vIHBvaW50IGF0IGVhY2ggZW5kIG9mIHNlZ21lbnQuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gbnVtIC0gMSArIGo7IC8vIHBvaW50IG51bWJlciwgMCB0byAjIHBvaW50cy5cblxuICAgICAgICAgICAgICAgIGlmIChpID09IDAgfHwgaSA9PSBubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGd4eFtqXSA9IE1hdGgucG93KDEwLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHl5W2krMV0gLSB5eVtpXSA9PSAwIHx8IHl5W2ldIC0geXlbaS0xXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGd4eFtqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoeHhbaSsxXSAtIHh4W2ldKSAvICh5eVtpKzFdIC0geXlbaV0pICsgKHh4W2ldIC0geHhbaS0xXSkgLyAoeXlbaV0gLSB5eVtpLTFdKSkgPT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3h4W2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoICh5eVtpKzFdIC0geXlbaV0pICogKHl5W2ldIC0geXlbaS0xXSkgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICBneHhbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBneHhbal0gPSAyIC8gKGR4eCh4eFtpICsgMV0sIHh4W2ldKSAvICh5eVtpICsgMV0gLSB5eVtpXSkgKyBkeHgoeHhbaV0sIHh4W2kgLSAxXSkgLyAoeXlbaV0gLSB5eVtpIC0gMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGZpcnN0IGRlcml2YXRpdmUgKHNsb3BlKSBhdCBmaXJzdCBhbmQgbGFzdCBwb2ludFxuICAgICAgICAgICAgaWYgKG51bSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgcG9pbnQgaGFzIDAgMm5kIGRlcml2YXRpdmVcbiAgICAgICAgICAgICAgICBneHhbMF0gPSAzIC8gMiAqICh5eVsxXSAtIHl5WzBdKSAvIGR4eCh4eFsxXSwgeHhbMF0pIC0gZ3h4WzFdIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bSA9PSBubWF4KSB7XG4gICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludCBoYXMgMCAybmQgZGVyaXZhdGl2ZVxuICAgICAgICAgICAgICAgIGd4eFsxXSA9IDMgLyAyICogKHl5W25tYXhdIC0geXlbbm1heCAtIDFdKSAvIGR4eCh4eFtubWF4XSwgeHhbbm1heCAtIDFdKSAtIGd4eFswXSAvIDI7XG4gICAgICAgICAgICB9ICAgXG5cbiAgICAgICAgICAgIC8vIENhbGMgc2Vjb25kIGRlcml2YXRpdmUgYXQgcG9pbnRzXG4gICAgICAgICAgICBnZ3h4WzBdID0gLTIgKiAoZ3h4WzFdICsgMiAqIGd4eFswXSkgLyBkeHgoeHhbbnVtXSwgeHhbbnVtIC0gMV0pICsgNiAqICh5eVtudW1dIC0geXlbbnVtIC0gMV0pIC8gTWF0aC5wb3coZHh4KHh4W251bV0sIHh4W251bSAtIDFdKSwgMik7XG4gICAgICAgICAgICBnZ3h4WzFdID0gMiAqICgyICogZ3h4WzFdICsgZ3h4WzBdKSAvIGR4eCh4eFtudW1dLCB4eFtudW0gLSAxXSkgLSA2ICogKHl5W251bV0gLSB5eVtudW0gLSAxXSkgLyBNYXRoLnBvdyhkeHgoeHhbbnVtXSwgeHhbbnVtIC0gMV0pLCAyKTtcblxuICAgICAgICAgICAgLy8gQ2FsYyBjb25zdGFudHMgZm9yIGN1YmljIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIEQgPSAxIC8gNiAqIChnZ3h4WzFdIC0gZ2d4eFswXSkgLyBkeHgoeHhbbnVtXSwgeHhbbnVtIC0gMV0pO1xuICAgICAgICAgICAgQyA9IDEgLyAyICogKHh4W251bV0gKiBnZ3h4WzBdIC0geHhbbnVtIC0gMV0gKiBnZ3h4WzFdKSAvIGR4eCh4eFtudW1dLCB4eFtudW0gLSAxXSk7XG4gICAgICAgICAgICBCID0gKHl5W251bV0gLSB5eVtudW0gLSAxXSAtIEMgKiAoTWF0aC5wb3coeHhbbnVtXSwgMikgLSBNYXRoLnBvdyh4eFtudW0gLSAxXSwgMikpIC0gRCAqIChNYXRoLnBvdyh4eFtudW1dLCAzKSAtIE1hdGgucG93KHh4W251bSAtIDFdLCAzKSkpIC8gZHh4KHh4W251bV0sIHh4W251bSAtIDFdKTtcbiAgICAgICAgICAgIEEgPSB5eVtudW0gLSAxXSAtIEIgKiB4eFtudW0gLSAxXSAtIEMgKiBNYXRoLnBvdyh4eFtudW0gLSAxXSwgMikgLSBEICogTWF0aC5wb3coeHhbbnVtIC0gMV0sIDMpO1xuXG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50ID0gKHh4W251bV0gLSB4eFtudW0gLSAxXSkgLyBzdGVwcztcbiAgICAgICAgICAgIHZhciB0ZW1wLCB0ZW1weDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBzdGVwczsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICB0ZW1weCA9IHh4W251bSAtIDFdICsgaiAqIGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2godGVtcHgpO1xuICAgICAgICAgICAgICAgIHRlbXAucHVzaChBICsgQiAqIHRlbXB4ICsgQyAqIE1hdGgucG93KHRlbXB4LCAyKSArIEQgKiBNYXRoLnBvdyh0ZW1weCwgMykpO1xuICAgICAgICAgICAgICAgIF9zbW9vdGhlZERhdGEucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICBfc21vb3RoZWRQbG90RGF0YS5wdXNoKFt4cCh0ZW1wWzBdKSwgeXAodGVtcFsxXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9zbW9vdGhlZERhdGEucHVzaChnZFtpXSk7XG4gICAgICAgIF9zbW9vdGhlZFBsb3REYXRhLnB1c2goW3hwKGdkW2ldWzBdKSwgeXAoZ2RbaV1bMV0pXSk7XG5cbiAgICAgICAgcmV0dXJuIFtfc21vb3RoZWREYXRhLCBfc21vb3RoZWRQbG90RGF0YV07XG4gICAgfVxuXG4gICAgLy8vLy8vL1xuICAgIC8vIGNvbXB1dGVIZXJtaXRlU21vb3RoZWREYXRhXG4gICAgLy8gQSBoZXJtaXRlIHNwbGluZSBzbW9vdGhpbmcgb2YgdGhlIHBsb3QgZGF0YS5cbiAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGRlcml2ZWQgZnJvbSB0aGUgb25lIHBvc3RlZFxuICAgIC8vIGJ5IGtyeXBpbiBvbiB0aGUganFwbG90LXVzZXJzIG1haWxpbmcgbGlzdDpcbiAgICAvL1xuICAgIC8vIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9qcXBsb3QtdXNlcnMvYnJvd3NlX3RocmVhZC90aHJlYWQvNzQ4YmU2YTQ0NTcyM2NlYT9wbGk9MVxuICAgIC8vXG4gICAgLy8gd2l0aCBhIGJsb2cgcG9zdDpcbiAgICAvL1xuICAgIC8vIGh0dHA6Ly9ibG9nLnN0YXRzY29sbGVjdG9yLmNvbS9hLXBsdWdpbi1yZW5kZXJlci1mb3ItanFwbG90LXRvLWRyYXctYS1oZXJtaXRlLXNwbGluZS9cbiAgICAvL1xuICAgIC8vIGFuZCBkb3dubG9hZCBvZiB0aGUgb3JpZ2luYWwgcGx1Z2luOlxuICAgIC8vXG4gICAgLy8gaHR0cDovL2Jsb2cuc3RhdHNjb2xsZWN0b3IuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDEwLzAyL2pxcGxvdC5oZXJtaXRlU3BsaW5lUmVuZGVyZXIuanNcbiAgICAvLy8vLy8vLy8vXG5cbiAgICAvLyBjYWxsZWQgd2l0aCBzY29wZSBvZiBzZXJpZXNcbiAgICBmdW5jdGlvbiBjb21wdXRlSGVybWl0ZVNtb290aGVkRGF0YSAoZ2QpIHtcbiAgICAgICAgdmFyIHNtb290aCA9IHRoaXMucmVuZGVyZXIuc21vb3RoO1xuICAgICAgICB2YXIgdGVuc2lvbiA9IHRoaXMucmVuZGVyZXIudGVuc2lvbjtcbiAgICAgICAgdmFyIGRpbSA9IHRoaXMuY2FudmFzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB4cCA9IHRoaXMuX3hheGlzLnNlcmllc19wMnU7XG4gICAgICAgIHZhciB5cCA9IHRoaXMuX3lheGlzLnNlcmllc19wMnU7IFxuICAgICAgICB2YXIgc3RlcHMgPW51bGw7XG4gICAgICAgIHZhciBfc3RlcHMgPSBudWxsO1xuICAgICAgICB2YXIgYSA9IG51bGw7XG4gICAgICAgIHZhciBhMSA9IG51bGw7XG4gICAgICAgIHZhciBhMiA9IG51bGw7XG4gICAgICAgIHZhciBzbG9wZSA9IG51bGw7XG4gICAgICAgIHZhciBzbG9wZTIgPSBudWxsO1xuICAgICAgICB2YXIgdGVtcCA9IG51bGw7XG4gICAgICAgIHZhciB0LCBzLCBoMSwgaDIsIGgzLCBoNDtcbiAgICAgICAgdmFyIFRpWCwgVGlZLCBUaTFYLCBUaTFZO1xuICAgICAgICB2YXIgcFgsIHBZLCBwO1xuICAgICAgICB2YXIgc2QgPSBbXTtcbiAgICAgICAgdmFyIHNwZCA9IFtdO1xuICAgICAgICB2YXIgZGlzdCA9IGdkLmxlbmd0aC9kaW07XG4gICAgICAgIHZhciBtaW4sIG1heCwgc3RyZXRjaCwgc2NhbGUsIHNoaWZ0O1xuICAgICAgICB2YXIgX3Ntb290aGVkRGF0YSA9IFtdO1xuICAgICAgICB2YXIgX3Ntb290aGVkUGxvdERhdGEgPSBbXTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHNtb290aCkpKSB7XG4gICAgICAgICAgICBzdGVwcyA9IHBhcnNlRmxvYXQoc21vb3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXBzID0gZ2V0U3RlcHMoZGlzdCwgMC41KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodGVuc2lvbikpKSB7XG4gICAgICAgICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk9MCwgbCA9IGdkLmxlbmd0aC0xOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGlmICh0ZW5zaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2xvcGUgPSBNYXRoLmFicygoZ2RbaSsxXVsxXSAtIGdkW2ldWzFdKSAvIChnZFtpKzFdWzBdIC0gZ2RbaV1bMF0pKTtcblxuICAgICAgICAgICAgICAgIG1pbiA9IDAuMztcbiAgICAgICAgICAgICAgICBtYXggPSAwLjY7XG4gICAgICAgICAgICAgICAgc3RyZXRjaCA9IChtYXggLSBtaW4pLzIuMDtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDIuNTtcbiAgICAgICAgICAgICAgICBzaGlmdCA9IC0xLjQ7XG5cbiAgICAgICAgICAgICAgICB0ZW1wID0gc2xvcGUvc2NhbGUgKyBzaGlmdDtcblxuICAgICAgICAgICAgICAgIGExID0gc3RyZXRjaCAqIHRhbmgodGVtcCkgLSBzdHJldGNoICogdGFuaChzaGlmdCkgKyBtaW47XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBoYXZlIGJvdGggbGVmdCBhbmQgcmlnaHQgbGluZSBzZWdtZW50cywgd2lsbCB1c2UgIG1pbmltdW0gdGVuc2lvbi4gXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3BlMiA9IE1hdGguYWJzKChnZFtpXVsxXSAtIGdkW2ktMV1bMV0pIC8gKGdkW2ldWzBdIC0gZ2RbaS0xXVswXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wID0gc2xvcGUyL3NjYWxlICsgc2hpZnQ7XG5cbiAgICAgICAgICAgICAgICBhMiA9IHN0cmV0Y2ggKiB0YW5oKHRlbXApIC0gc3RyZXRjaCAqIHRhbmgoc2hpZnQpICsgbWluO1xuXG4gICAgICAgICAgICAgICAgYSA9IChhMSArIGEyKS8yLjA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB0ZW5zaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh0PTA7IHQgPCBzdGVwczsgdCsrKSB7XG4gICAgICAgICAgICAgICAgcyA9IHQgLyBzdGVwcztcbiAgICAgICAgICAgICAgICBoMSA9ICgxICsgMipzKSpNYXRoLnBvdygoMS1zKSwyKTtcbiAgICAgICAgICAgICAgICBoMiA9IHMqTWF0aC5wb3coKDEtcyksMik7XG4gICAgICAgICAgICAgICAgaDMgPSBNYXRoLnBvdyhzLDIpKigzLTIqcyk7XG4gICAgICAgICAgICAgICAgaDQgPSBNYXRoLnBvdyhzLDIpKihzLTEpOyAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGdkW2ktMV0pIHsgIFxuICAgICAgICAgICAgICAgICAgICBUaVggPSBhICogKGdkW2krMV1bMF0gLSBnZFtpLTFdWzBdKTsgXG4gICAgICAgICAgICAgICAgICAgIFRpWSA9IGEgKiAoZ2RbaSsxXVsxXSAtIGdkW2ktMV1bMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFRpWCA9IGEgKiAoZ2RbaSsxXVswXSAtIGdkW2ldWzBdKTsgXG4gICAgICAgICAgICAgICAgICAgIFRpWSA9IGEgKiAoZ2RbaSsxXVsxXSAtIGdkW2ldWzFdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZFtpKzJdKSB7ICBcbiAgICAgICAgICAgICAgICAgICAgVGkxWCA9IGEgKiAoZ2RbaSsyXVswXSAtIGdkW2ldWzBdKTsgXG4gICAgICAgICAgICAgICAgICAgIFRpMVkgPSBhICogKGdkW2krMl1bMV0gLSBnZFtpXVsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVGkxWCA9IGEgKiAoZ2RbaSsxXVswXSAtIGdkW2ldWzBdKTsgXG4gICAgICAgICAgICAgICAgICAgIFRpMVkgPSBhICogKGdkW2krMV1bMV0gLSBnZFtpXVsxXSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBYID0gaDEqZ2RbaV1bMF0gKyBoMypnZFtpKzFdWzBdICsgaDIqVGlYICsgaDQqVGkxWDtcbiAgICAgICAgICAgICAgICBwWSA9IGgxKmdkW2ldWzFdICsgaDMqZ2RbaSsxXVsxXSArIGgyKlRpWSArIGg0KlRpMVk7XG4gICAgICAgICAgICAgICAgcCA9IFtwWCwgcFldO1xuXG4gICAgICAgICAgICAgICAgX3Ntb290aGVkRGF0YS5wdXNoKHApO1xuICAgICAgICAgICAgICAgIF9zbW9vdGhlZFBsb3REYXRhLnB1c2goW3hwKHBYKSwgeXAocFkpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3Ntb290aGVkRGF0YS5wdXNoKGdkW2xdKTtcbiAgICAgICAgX3Ntb290aGVkUGxvdERhdGEucHVzaChbeHAoZ2RbbF1bMF0pLCB5cChnZFtsXVsxXSldKTtcblxuICAgICAgICByZXR1cm4gW19zbW9vdGhlZERhdGEsIF9zbW9vdGhlZFBsb3REYXRhXTtcbiAgICB9XG4gICAgXG4gICAgLy8gc2V0R3JpZERhdGFcbiAgICAvLyBjb252ZXJ0cyB0aGUgdXNlciBkYXRhIHZhbHVlcyB0byBncmlkIGNvb3JkaW5hdGVzIGFuZCBzdG9yZXMgdGhlbVxuICAgIC8vIGluIHRoZSBncmlkRGF0YSBhcnJheS5cbiAgICAvLyBDYWxsZWQgd2l0aCBzY29wZSBvZiBhIHNlcmllcy5cbiAgICAkLmpxcGxvdC5MaW5lUmVuZGVyZXIucHJvdG90eXBlLnNldEdyaWREYXRhID0gZnVuY3Rpb24ocGxvdCkge1xuICAgICAgICAvLyByZWNhbGN1bGF0ZSB0aGUgZ3JpZCBkYXRhXG4gICAgICAgIHZhciB4cCA9IHRoaXMuX3hheGlzLnNlcmllc191MnA7XG4gICAgICAgIHZhciB5cCA9IHRoaXMuX3lheGlzLnNlcmllc191MnA7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fcGxvdERhdGE7XG4gICAgICAgIHZhciBwZGF0YSA9IHRoaXMuX3ByZXZQbG90RGF0YTtcbiAgICAgICAgdGhpcy5ncmlkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2R3JpZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5fc21vb3RoZWREYXRhID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX3Ntb290aGVkUGxvdERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5faGlCYW5kR3JpZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5fbG93QmFuZEdyaWREYXRhID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX2hpQmFuZFNtb290aGVkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kU21vb3RoZWREYXRhID0gW107XG4gICAgICAgIHZhciBiYW5kcyA9IHRoaXMucmVuZGVyZXIuYmFuZHM7XG4gICAgICAgIHZhciBoYXNOdWxsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGk9MCwgbD1kYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gaWYgbm90IGEgbGluZSBzZXJpZXMgb3IgaWYgbm8gbnVsbHMgaW4gZGF0YSwgcHVzaCB0aGUgY29udmVydGVkIHBvaW50IG9udG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgaWYgKGRhdGFbaV1bMF0gIT0gbnVsbCAmJiBkYXRhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWREYXRhLnB1c2goW3hwLmNhbGwodGhpcy5feGF4aXMsIGRhdGFbaV1bMF0pLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBkYXRhW2ldWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGVyZSBpcyBhIG51bGwsIHByZXNlcnZlIGl0LlxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpXVswXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFzTnVsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkRGF0YS5wdXNoKFtudWxsLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBkYXRhW2ldWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpXVsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFzTnVsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkRGF0YS5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBkYXRhW2ldWzBdKSwgbnVsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm90IGEgbGluZSBzZXJpZXMgb3IgaWYgbm8gbnVsbHMgaW4gZGF0YSwgcHVzaCB0aGUgY29udmVydGVkIHBvaW50IG9udG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgaWYgKHBkYXRhW2ldICE9IG51bGwgJiYgcGRhdGFbaV1bMF0gIT0gbnVsbCAmJiBwZGF0YVtpXVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkdyaWREYXRhLnB1c2goW3hwLmNhbGwodGhpcy5feGF4aXMsIHBkYXRhW2ldWzBdKSwgeXAuY2FsbCh0aGlzLl95YXhpcywgcGRhdGFbaV1bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGlmIHRoZXJlIGlzIGEgbnVsbCwgcHJlc2VydmUgaXQuXG4gICAgICAgICAgICBlbHNlIGlmIChwZGF0YVtpXSAhPSBudWxsICYmIHBkYXRhW2ldWzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2R3JpZERhdGEucHVzaChbbnVsbCwgeXAuY2FsbCh0aGlzLl95YXhpcywgcGRhdGFbaV1bMV0pXSk7XG4gICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIGVsc2UgaWYgKHBkYXRhW2ldICE9IG51bGwgJiYgcGRhdGFbaV1bMF0gIT0gbnVsbCAmJiBwZGF0YVtpXVsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkdyaWREYXRhLnB1c2goW3hwLmNhbGwodGhpcy5feGF4aXMsIHBkYXRhW2ldWzBdKSwgbnVsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgZG8gc21vb3RoaW5nIG9yIGJhbmRzIG9uIGJyb2tlbiBsaW5lcy5cbiAgICAgICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc21vb3RoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgYmFuZHMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdsaW5lJyAmJiBiYW5kcy5zaG93KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9YmFuZHMuaGlEYXRhLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YS5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBiYW5kcy5oaURhdGFbaV1bMF0pLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBiYW5kcy5oaURhdGFbaV1bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9YmFuZHMubG93RGF0YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5fbG93QmFuZEdyaWREYXRhLnB1c2goW3hwLmNhbGwodGhpcy5feGF4aXMsIGJhbmRzLmxvd0RhdGFbaV1bMF0pLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBiYW5kcy5sb3dEYXRhW2ldWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNtb290aGVkIGRhdGEgaWYgZW5vdWdoIHBvaW50cyBhbmQgbm8gbnVsbHNcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdsaW5lJyAmJiB0aGlzLnJlbmRlcmVyLnNtb290aCAmJiB0aGlzLmdyaWREYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5jb25zdHJhaW5TbW9vdGhpbmcpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlQ29uc3RyYWluZWRTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLmdyaWREYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZERhdGEgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5fc21vb3RoZWRQbG90RGF0YSA9IHJldFsxXTtcblxuICAgICAgICAgICAgICAgIGlmIChiYW5kcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVDb25zdHJhaW5lZFNtb290aGVkRGF0YS5jYWxsKHRoaXMsIHRoaXMucmVuZGVyZXIuX2hpQmFuZEdyaWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5faGlCYW5kU21vb3RoZWREYXRhID0gcmV0WzBdO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlQ29uc3RyYWluZWRTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kR3JpZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kU21vb3RoZWREYXRhID0gcmV0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlSGVybWl0ZVNtb290aGVkRGF0YS5jYWxsKHRoaXMsIHRoaXMuZ3JpZERhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX3Ntb290aGVkRGF0YSA9IHJldFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZFBsb3REYXRhID0gcmV0WzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhbmRzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUhlcm1pdGVTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX2hpQmFuZFNtb290aGVkRGF0YSA9IHJldFswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUhlcm1pdGVTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kR3JpZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kU21vb3RoZWREYXRhID0gcmV0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIG1ha2VHcmlkRGF0YVxuICAgIC8vIGNvbnZlcnRzIGFueSBhcmJpdHJhcnkgZGF0YSB2YWx1ZXMgdG8gZ3JpZCBjb29yZGluYXRlcyBhbmRcbiAgICAvLyByZXR1cm5zIHRoZW0uICBUaGlzIG1ldGhvZCBleGlzdHMgc28gdGhhdCBwbHVnaW5zIGNhbiB1c2UgYSBzZXJpZXMnXG4gICAgLy8gbGluZXJlbmRlcmVyIHRvIGdlbmVyYXRlIGdyaWQgZGF0YSBwb2ludHMgd2l0aG91dCBvdmVyd3JpdGluZyB0aGVcbiAgICAvLyBncmlkIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoYXQgc2VyaWVzLlxuICAgIC8vIENhbGxlZCB3aXRoIHNjb3BlIG9mIGEgc2VyaWVzLlxuICAgICQuanFwbG90LkxpbmVSZW5kZXJlci5wcm90b3R5cGUubWFrZUdyaWREYXRhID0gZnVuY3Rpb24oZGF0YSwgcGxvdCkge1xuICAgICAgICAvLyByZWNhbGN1bGF0ZSB0aGUgZ3JpZCBkYXRhXG4gICAgICAgIHZhciB4cCA9IHRoaXMuX3hheGlzLnNlcmllc191MnA7XG4gICAgICAgIHZhciB5cCA9IHRoaXMuX3lheGlzLnNlcmllc191MnA7XG4gICAgICAgIHZhciBnZCA9IFtdO1xuICAgICAgICB2YXIgcGdkID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX3Ntb290aGVkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZFBsb3REYXRhID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX2hpQmFuZEdyaWREYXRhID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXIuX2xvd0JhbmRHcmlkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLl9oaUJhbmRTbW9vdGhlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5fbG93QmFuZFNtb290aGVkRGF0YSA9IFtdO1xuICAgICAgICB2YXIgYmFuZHMgPSB0aGlzLnJlbmRlcmVyLmJhbmRzO1xuICAgICAgICB2YXIgaGFzTnVsbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gaWYgbm90IGEgbGluZSBzZXJpZXMgb3IgaWYgbm8gbnVsbHMgaW4gZGF0YSwgcHVzaCB0aGUgY29udmVydGVkIHBvaW50IG9udG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgaWYgKGRhdGFbaV1bMF0gIT0gbnVsbCAmJiBkYXRhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGVwICYmIGk+MCkge1xuICAgICAgICAgICAgICAgICAgICBnZC5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBkYXRhW2ldWzBdKSwgeXAuY2FsbCh0aGlzLl95YXhpcywgZGF0YVtpLTFdWzFdKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZC5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBkYXRhW2ldWzBdKSwgeXAuY2FsbCh0aGlzLl95YXhpcywgZGF0YVtpXVsxXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlcmUgaXMgYSBudWxsLCBwcmVzZXJ2ZSBpdC5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaV1bMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc051bGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdkLnB1c2goW251bGwsIHlwLmNhbGwodGhpcy5feWF4aXMsIGRhdGFbaV1bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhW2ldWzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoYXNOdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBnZC5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBkYXRhW2ldWzBdKSwgbnVsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgZG8gc21vb3RoaW5nIG9yIGJhbmRzIG9uIGJyb2tlbiBsaW5lcy5cbiAgICAgICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc21vb3RoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgYmFuZHMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdsaW5lJyAmJiBiYW5kcy5zaG93KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9YmFuZHMuaGlEYXRhLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YS5wdXNoKFt4cC5jYWxsKHRoaXMuX3hheGlzLCBiYW5kcy5oaURhdGFbaV1bMF0pLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBiYW5kcy5oaURhdGFbaV1bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9YmFuZHMubG93RGF0YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5fbG93QmFuZEdyaWREYXRhLnB1c2goW3hwLmNhbGwodGhpcy5feGF4aXMsIGJhbmRzLmxvd0RhdGFbaV1bMF0pLCB5cC5jYWxsKHRoaXMuX3lheGlzLCBiYW5kcy5sb3dEYXRhW2ldWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdsaW5lJyAmJiB0aGlzLnJlbmRlcmVyLnNtb290aCAmJiBnZC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuY29uc3RyYWluU21vb3RoaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUNvbnN0cmFpbmVkU21vb3RoZWREYXRhLmNhbGwodGhpcywgZ2QpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX3Ntb290aGVkRGF0YSA9IHJldFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZFBsb3REYXRhID0gcmV0WzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhbmRzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUNvbnN0cmFpbmVkU21vb3RoZWREYXRhLmNhbGwodGhpcywgdGhpcy5yZW5kZXJlci5faGlCYW5kR3JpZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9oaUJhbmRTbW9vdGhlZERhdGEgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVDb25zdHJhaW5lZFNtb290aGVkRGF0YS5jYWxsKHRoaXMsIHRoaXMucmVuZGVyZXIuX2xvd0JhbmRHcmlkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX2xvd0JhbmRTbW9vdGhlZERhdGEgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVIZXJtaXRlU21vb3RoZWREYXRhLmNhbGwodGhpcywgZ2QpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX3Ntb290aGVkRGF0YSA9IHJldFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZFBsb3REYXRhID0gcmV0WzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhbmRzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUhlcm1pdGVTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuX2hpQmFuZFNtb290aGVkRGF0YSA9IHJldFswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29tcHV0ZUhlcm1pdGVTbW9vdGhlZERhdGEuY2FsbCh0aGlzLCB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kR3JpZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLl9sb3dCYW5kU21vb3RoZWREYXRhID0gcmV0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdkO1xuICAgIH07XG4gICAgXG5cbiAgICAvLyBjYWxsZWQgd2l0aGluIHNjb3BlIG9mIHNlcmllcy5cbiAgICAkLmpxcGxvdC5MaW5lUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIGdkLCBvcHRpb25zLCBwbG90KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICAvLyBnZXQgYSBjb3B5IG9mIHRoZSBvcHRpb25zLCBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgdmFyIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzaGFkb3cgPSAob3B0cy5zaGFkb3cgIT0gdW5kZWZpbmVkKSA/IG9wdHMuc2hhZG93IDogdGhpcy5zaGFkb3c7XG4gICAgICAgIHZhciBzaG93TGluZSA9IChvcHRzLnNob3dMaW5lICE9IHVuZGVmaW5lZCkgPyBvcHRzLnNob3dMaW5lIDogdGhpcy5zaG93TGluZTtcbiAgICAgICAgdmFyIGZpbGwgPSAob3B0cy5maWxsICE9IHVuZGVmaW5lZCkgPyBvcHRzLmZpbGwgOiB0aGlzLmZpbGw7XG4gICAgICAgIHZhciBmaWxsQW5kU3Ryb2tlID0gKG9wdHMuZmlsbEFuZFN0cm9rZSAhPSB1bmRlZmluZWQpID8gb3B0cy5maWxsQW5kU3Ryb2tlIDogdGhpcy5maWxsQW5kU3Ryb2tlO1xuICAgICAgICB2YXIgeG1pbiwgeW1pbiwgeG1heCwgeW1heDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKGdkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNob3dMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZmlsbCwgd2UnbGwgaGF2ZSB0byBhZGQgcG9pbnRzIHRvIGNsb3NlIHRoZSBjdXJ2ZS5cbiAgICAgICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxsVG9aZXJvKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBicmVhayBsaW5lIHVwIGludG8gc2hhcGVzIGF0IGF4aXMgY3Jvc3NpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmVDb2xvciA9IHRoaXMubmVnYXRpdmVDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIHRoaXMudXNlTmVnYXRpdmVDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZUNvbG9yID0gb3B0cy5maWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNuZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2ZzID0gb3B0cy5maWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc3Rva2luZyBsaW5lIGFzIHdlbGwgYXMgZmlsbGluZywgZ2V0IGEgY29weSBvZiBsaW5lIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsbEFuZFN0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYXNnZCA9IGdkLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHN0YWNrZWQsIGZpbGwgZG93biB0byBheGlzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwIHx8ICF0aGlzLl9zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBnZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZCA9ICh0aGlzLnJlbmRlcmVyLnNtb290aCkgPyB0aGlzLnJlbmRlcmVyLl9zbW9vdGhlZFBsb3REYXRhIDogdGhpcy5fcGxvdERhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJlYVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBweXplcm8gPSB0aGlzLl95YXhpcy5zZXJpZXNfdTJwKHRoaXMuZmlsbFRvVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBweHplcm8gPSB0aGlzLl94YXhpcy5zZXJpZXNfdTJwKHRoaXMuZmlsbFRvVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5jbG9zZVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGxBeGlzID09ICd5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wZ2QucHVzaChbZ2RbMF1bMF0sIHB5emVyb10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmVhUG9pbnRzLnB1c2goW2dkWzBdWzBdLCBweXplcm9dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxnZC5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wZ2QucHVzaChnZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmVhUG9pbnRzLnB1c2goZ2RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbiBheGlzIGNyb3NzaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBkW2ldWzFdICogcGRbaSsxXVsxXSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBkW2ldWzFdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc25lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5maWxsU3R5bGUgPSBuZWdhdGl2ZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNuZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpbGxTdHlsZSA9IHBvc2ZzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGludGVyY2VwdCA9IGdkW2ldWzBdICsgKGdkW2krMV1bMF0gLSBnZFtpXVswXSkgKiAocHl6ZXJvLWdkW2ldWzFdKS8oZ2RbaSsxXVsxXSAtIGdkW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wZ2QucHVzaChbeGludGVyY2VwdCwgcHl6ZXJvXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJlYVBvaW50cy5wdXNoKFt4aW50ZXJjZXB0LCBweXplcm9dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgZHJhdyB0aGlzIHNoYXBlIGFuZCBzaGFkb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCB0ZW1wZ2QsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHRlbXBnZCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGVtcHR5IHRlbXAgYXJyYXkgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGdkID0gW1t4aW50ZXJjZXB0LCBweXplcm9dXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLl9hcmVhUG9pbnRzID0gW1t4aW50ZXJjZXB0LCBweXplcm9dXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGRbZ2QubGVuZ3RoLTFdWzFdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNuZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpbGxTdHlsZSA9IG5lZ2F0aXZlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc25lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpbGxTdHlsZSA9IHBvc2ZzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBnZC5wdXNoKGdkW2dkLmxlbmd0aC0xXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FyZWFQb2ludHMucHVzaChnZFtnZC5sZW5ndGgtMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wZ2QucHVzaChbZ2RbZ2QubGVuZ3RoLTFdWzBdLCBweXplcm9dKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FyZWFQb2ludHMucHVzaChbZ2RbZ2QubGVuZ3RoLTFdWzBdLCBweXplcm9dKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBkcmF3IHRoZSBsYXN0IGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCB0ZW1wZ2QsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHRlbXBnZCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGdyaWR5bWluID0gdGhpcy5feWF4aXMuc2VyaWVzX3UycCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAvLyBJRSBkb2Vzbid0IHJldHVybiBuZXcgbGVuZ3RoIG9uIHVuc2hpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZC51bnNoaWZ0KFtnZFswXVswXSwgZ3JpZHltaW5dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW4gPSBnZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2QucHVzaChbZ2RbbGVuIC0gMV1bMF0sIGdyaWR5bWluXSk7ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc3RhY2tlZCwgZmlsbCB0byBsaW5lIGJlbG93IFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9wcmV2R3JpZERhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT1wcmV2Lmxlbmd0aDsgaT4wOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2QucHVzaChwcmV2W2ktMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLl9hcmVhUG9pbnRzLnB1c2gocHJldltpLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBnZCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FyZWFQb2ludHMgPSBnZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIGdkLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBmaWxsZWQgdG8gemVyb1xuICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHN0b2tpbmcgbGluZSBhcyB3ZWxsIGFzIGZpbGxpbmcsIGdldCBhIGNvcHkgb2YgbGluZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxBbmRTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFzZ2QgPSBnZC5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBzdGFja2VkLCBmaWxsIGRvd24gdG8gYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMCB8fCAhdGhpcy5fc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZ3JpZHltaW4gPSB0aGlzLl95YXhpcy5zZXJpZXNfdTJwKHRoaXMuX3lheGlzLm1pbikgLSB0aGlzLmdyaWRCb3JkZXJXaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyaWR5bWluID0gY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgZG9lc24ndCByZXR1cm4gbmV3IGxlbmd0aCBvbiB1bnNoaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2QudW5zaGlmdChbZ2RbMF1bMF0sIGdyaWR5bWluXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGdkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZC5wdXNoKFtnZFtsZW4gLSAxXVswXSwgZ3JpZHltaW5dKTsgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzdGFja2VkLCBmaWxsIHRvIGxpbmUgYmVsb3cgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuX3ByZXZHcmlkRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPXByZXYubGVuZ3RoOyBpPjA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZC5wdXNoKHByZXZbaS0xXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJlYVBvaW50cyA9IGdkO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgZ2QsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIGdkLCBvcHRzKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsbEFuZFN0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhc29wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0cywge2ZpbGw6ZmFsc2UsIGNsb3NlUGF0aDpmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFwZVJlbmRlcmVyLmRyYXcoY3R4LCBmYXNnZCwgZmFzb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IHNvbWUgd2F5IHRvIGRvIHNoYWRvd3MgbmljZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgZmFzZ2QsIGZhc29wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGRyYXcgdGhlIG1hcmtlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlclJlbmRlcmVyLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zbW9vdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFzZ2QgPSB0aGlzLmdyaWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxmYXNnZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IG9wdHMubWFya2VyT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyT3B0aW9uc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwgbWFya2VyT3B0aW9ucywgdGhpcy5tYXJrZXJPcHRpb25zQ2FsbGJhY2socGxvdCwgdGhpcywgaSwgdGhpcy5kYXRhW2ldLCBnZFtpXSkgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyUmVuZGVyZXIuZHJhdyhmYXNnZFtpXVswXSwgZmFzZ2RbaV1bMV0sIGN0eCwgbWFya2VyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmJhbmRzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvcHRzID0gJC5leHRlbmQodHJ1ZSwge30sIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuYmFuZHMuc2hvd0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmRhdCA9ICh0aGlzLnJlbmRlcmVyLnNtb290aCkgPyB0aGlzLnJlbmRlcmVyLl9oaUJhbmRTbW9vdGhlZERhdGEgOiB0aGlzLnJlbmRlcmVyLl9oaUJhbmRHcmlkRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIGJkYXQsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJkYXQgPSAodGhpcy5yZW5kZXJlci5zbW9vdGgpID8gdGhpcy5yZW5kZXJlci5fbG93QmFuZFNtb290aGVkRGF0YSA6IHRoaXMucmVuZGVyZXIuX2xvd0JhbmRHcmlkRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIGJkYXQsIGJvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuYmFuZHMuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnNtb290aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZGF0ID0gdGhpcy5yZW5kZXJlci5faGlCYW5kU21vb3RoZWREYXRhLmNvbmNhdCh0aGlzLnJlbmRlcmVyLl9sb3dCYW5kU21vb3RoZWREYXRhLnJldmVyc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZGF0ID0gdGhpcy5yZW5kZXJlci5faGlCYW5kR3JpZERhdGEuY29uY2F0KHRoaXMucmVuZGVyZXIuX2xvd0JhbmRHcmlkRGF0YS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmVhUG9pbnRzID0gYmRhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3B0cy5jbG9zZVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcHRzLmZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcHRzLmZpbGxTdHlsZSA9IHRoaXMucmVuZGVyZXIuYmFuZHMuZmlsbENvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhcGVSZW5kZXJlci5kcmF3KGN0eCwgYmRhdCwgYm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgZ2QsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhcGVSZW5kZXJlci5kcmF3KGN0eCwgZ2QsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAgICB2YXIgeG1pbiA9IHhtYXggPSB5bWluID0geW1heCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLl9hcmVhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9hcmVhUG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4bWluID4gcFswXSB8fCB4bWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeG1pbiA9IHBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5bWF4IDwgcFsxXSB8fCB5bWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1heCA9IHBbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4bWF4IDwgcFswXSB8fCB4bWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeG1heCA9IHBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5bWluID4gcFsxXSB8fCB5bWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1pbiA9IHBbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZScgJiYgdGhpcy5yZW5kZXJlci5iYW5kcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgeW1heCA9IHRoaXMuX3lheGlzLnNlcmllc191MnAodGhpcy5yZW5kZXJlci5iYW5kcy5fbWluKTtcbiAgICAgICAgICAgICAgICB5bWluID0gdGhpcy5feWF4aXMuc2VyaWVzX3UycCh0aGlzLnJlbmRlcmVyLmJhbmRzLl9tYXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9ib3VuZGluZ0JveCA9IFtbeG1pbiwgeW1heF0sIFt4bWF4LCB5bWluXV07XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gbm93IGRyYXcgdGhlIG1hcmtlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlclJlbmRlcmVyLnNob3cgJiYgIWZpbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zbW9vdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2QgPSB0aGlzLmdyaWREYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxnZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IG9wdHMubWFya2VyT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyT3B0aW9uc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwgbWFya2VyT3B0aW9ucywgdGhpcy5tYXJrZXJPcHRpb25zQ2FsbGJhY2socGxvdCwgdGhpcywgaSwgdGhpcy5kYXRhW2ldLCBnZFtpXSkgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZFtpXVswXSAhPSBudWxsICYmIGdkW2ldWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyUmVuZGVyZXIuZHJhdyhnZFtpXVswXSwgZ2RbaV1bMV0sIGN0eCwgbWFya2VyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTsgIFxuICAgIFxuICAgICQuanFwbG90LkxpbmVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1NoYWRvdyA9IGZ1bmN0aW9uKGN0eCwgZ2QsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wLCBzaGFkb3dzIGRyYXduIHdpdGggbGluZXMuXG4gICAgfTtcbiAgICBcbiAgICAvLyBjYWxsZWQgd2l0aCBzY29wZSBvZiBwbG90LlxuICAgIC8vIG1ha2Ugc3VyZSB0byBub3QgbGVhdmUgYW55dGhpbmcgaGlnaGxpZ2h0ZWQuXG4gICAgZnVuY3Rpb24gcG9zdEluaXQodGFyZ2V0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkxpbmVSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFsbG93IG1vdXNlb3ZlciBhbmQgbW91c2Vkb3duIGF0IHNhbWUgdGltZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXJpZXNbaV0uaGlnaGxpZ2h0TW91c2VPdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmhpZ2hsaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gIFxuICAgIFxuICAgIC8vIGNhbGxlZCB3aXRoaW4gY29udGV4dCBvZiBwbG90XG4gICAgLy8gY3JlYXRlIGEgY2FudmFzIHdoaWNoIHdlIGNhbiBkcmF3IG9uLlxuICAgIC8vIGluc2VydCBpdCBiZWZvcmUgdGhlIGV2ZW50Q2FudmFzLCBzbyBldmVudENhbnZhcyB3aWxsIHN0aWxsIGNhcHR1cmUgZXZlbnRzLlxuICAgIGZ1bmN0aW9uIHBvc3RQbG90RHJhdygpIHtcbiAgICAgICAgLy8gTWVtb3J5IExlYWtzIHBhdGNoICAgIFxuICAgICAgICBpZiAodGhpcy5wbHVnaW5zLmxpbmVSZW5kZXJlciAmJiB0aGlzLnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodENhbnZhcykge1xuICAgICAgICAgIHRoaXMucGx1Z2lucy5saW5lUmVuZGVyZXIuaGlnaGxpZ2h0Q2FudmFzLnJlc2V0Q2FudmFzKCk7XG4gICAgICAgICAgdGhpcy5wbHVnaW5zLmxpbmVSZW5kZXJlci5oaWdobGlnaHRDYW52YXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodGVkU2VyaWVzSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodENhbnZhcyA9IG5ldyAkLmpxcGxvdC5HZW5lcmljQ2FudmFzKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJlZm9yZSh0aGlzLnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodENhbnZhcy5jcmVhdGVFbGVtZW50KHRoaXMuX2dyaWRQYWRkaW5nLCAnanFwbG90LWxpbmVSZW5kZXJlci1oaWdobGlnaHQtY2FudmFzJywgdGhpcy5fcGxvdERpbWVuc2lvbnMsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmxpbmVSZW5kZXJlci5oaWdobGlnaHRDYW52YXMuc2V0Q29udGV4dCgpO1xuICAgICAgICB0aGlzLmV2ZW50Q2FudmFzLl9lbGVtLmJpbmQoJ21vdXNlbGVhdmUnLCB7cGxvdDp0aGlzfSwgZnVuY3Rpb24gKGV2KSB7IHVuaGlnaGxpZ2h0KGV2LmRhdGEucGxvdCk7IH0pO1xuICAgIH0gXG4gICAgXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0IChwbG90LCBzaWR4LCBwaWR4LCBwb2ludHMpIHtcbiAgICAgICAgdmFyIHMgPSBwbG90LnNlcmllc1tzaWR4XTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHBsb3QucGx1Z2lucy5saW5lUmVuZGVyZXIuaGlnaGxpZ2h0Q2FudmFzO1xuICAgICAgICBjYW52YXMuX2N0eC5jbGVhclJlY3QoMCwwLGNhbnZhcy5fY3R4LmNhbnZhcy53aWR0aCwgY2FudmFzLl9jdHguY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHMuX2hpZ2hsaWdodGVkUG9pbnQgPSBwaWR4O1xuICAgICAgICBwbG90LnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodGVkU2VyaWVzSW5kZXggPSBzaWR4O1xuICAgICAgICB2YXIgb3B0cyA9IHtmaWxsU3R5bGU6IHMuaGlnaGxpZ2h0Q29sb3J9O1xuICAgICAgICBpZiAocy50eXBlID09PSAnbGluZScgJiYgcy5yZW5kZXJlci5iYW5kcy5zaG93KSB7XG4gICAgICAgICAgICBvcHRzLmZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgb3B0cy5jbG9zZVBhdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHMucmVuZGVyZXIuc2hhcGVSZW5kZXJlci5kcmF3KGNhbnZhcy5fY3R4LCBwb2ludHMsIG9wdHMpO1xuICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodCAocGxvdCkge1xuICAgICAgICB2YXIgY2FudmFzID0gcGxvdC5wbHVnaW5zLmxpbmVSZW5kZXJlci5oaWdobGlnaHRDYW52YXM7XG4gICAgICAgIGNhbnZhcy5fY3R4LmNsZWFyUmVjdCgwLDAsIGNhbnZhcy5fY3R4LmNhbnZhcy53aWR0aCwgY2FudmFzLl9jdHguY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxwbG90LnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGxvdC5zZXJpZXNbaV0uX2hpZ2hsaWdodGVkUG9pbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBsb3QucGx1Z2lucy5saW5lUmVuZGVyZXIuaGlnaGxpZ2h0ZWRTZXJpZXNJbmRleCA9IG51bGw7XG4gICAgICAgIHBsb3QudGFyZ2V0LnRyaWdnZXIoJ2pxcGxvdERhdGFVbmhpZ2hsaWdodCcpO1xuICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3ZlKGV2LCBncmlkcG9zLCBkYXRhcG9zLCBuZWlnaGJvciwgcGxvdCkge1xuICAgICAgICBpZiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgIHZhciBpbnMgPSBbbmVpZ2hib3Iuc2VyaWVzSW5kZXgsIG5laWdoYm9yLnBvaW50SW5kZXgsIG5laWdoYm9yLmRhdGFdO1xuICAgICAgICAgICAgdmFyIGV2dDEgPSBqUXVlcnkuRXZlbnQoJ2pxcGxvdERhdGFNb3VzZU92ZXInKTtcbiAgICAgICAgICAgIGV2dDEucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIGV2dDEucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHBsb3QudGFyZ2V0LnRyaWdnZXIoZXZ0MSwgaW5zKTtcbiAgICAgICAgICAgIGlmIChwbG90LnNlcmllc1tpbnNbMF1dLmhpZ2hsaWdodE1vdXNlT3ZlciAmJiAhKGluc1swXSA9PSBwbG90LnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodGVkU2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9IGpRdWVyeS5FdmVudCgnanFwbG90RGF0YUhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIGV2dC53aGljaCA9IGV2LndoaWNoO1xuICAgICAgICAgICAgICAgIGV2dC5wYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGV2dC5wYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICAgICAgICAgIHBsb3QudGFyZ2V0LnRyaWdnZXIoZXZ0LCBpbnMpO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCAocGxvdCwgbmVpZ2hib3Iuc2VyaWVzSW5kZXgsIG5laWdoYm9yLnBvaW50SW5kZXgsIG5laWdoYm9yLnBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmVpZ2hib3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5oaWdobGlnaHQgKHBsb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldiwgZ3JpZHBvcywgZGF0YXBvcywgbmVpZ2hib3IsIHBsb3QpIHtcbiAgICAgICAgaWYgKG5laWdoYm9yKSB7XG4gICAgICAgICAgICB2YXIgaW5zID0gW25laWdoYm9yLnNlcmllc0luZGV4LCBuZWlnaGJvci5wb2ludEluZGV4LCBuZWlnaGJvci5kYXRhXTtcbiAgICAgICAgICAgIGlmIChwbG90LnNlcmllc1tpbnNbMF1dLmhpZ2hsaWdodE1vdXNlRG93biAmJiAhKGluc1swXSA9PSBwbG90LnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodGVkU2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9IGpRdWVyeS5FdmVudCgnanFwbG90RGF0YUhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIGV2dC53aGljaCA9IGV2LndoaWNoO1xuICAgICAgICAgICAgICAgIGV2dC5wYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGV2dC5wYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICAgICAgICAgIHBsb3QudGFyZ2V0LnRyaWdnZXIoZXZ0LCBpbnMpO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCAocGxvdCwgbmVpZ2hib3Iuc2VyaWVzSW5kZXgsIG5laWdoYm9yLnBvaW50SW5kZXgsIG5laWdoYm9yLnBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmVpZ2hib3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5oaWdobGlnaHQgKHBsb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXYsIGdyaWRwb3MsIGRhdGFwb3MsIG5laWdoYm9yLCBwbG90KSB7XG4gICAgICAgIHZhciBpZHggPSBwbG90LnBsdWdpbnMubGluZVJlbmRlcmVyLmhpZ2hsaWdodGVkU2VyaWVzSW5kZXg7XG4gICAgICAgIGlmIChpZHggIT0gbnVsbCAmJiBwbG90LnNlcmllc1tpZHhdLmhpZ2hsaWdodE1vdXNlRG93bikge1xuICAgICAgICAgICAgdW5oaWdobGlnaHQocGxvdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXYsIGdyaWRwb3MsIGRhdGFwb3MsIG5laWdoYm9yLCBwbG90KSB7XG4gICAgICAgIGlmIChuZWlnaGJvcikge1xuICAgICAgICAgICAgdmFyIGlucyA9IFtuZWlnaGJvci5zZXJpZXNJbmRleCwgbmVpZ2hib3IucG9pbnRJbmRleCwgbmVpZ2hib3IuZGF0YV07XG4gICAgICAgICAgICB2YXIgZXZ0ID0galF1ZXJ5LkV2ZW50KCdqcXBsb3REYXRhQ2xpY2snKTtcbiAgICAgICAgICAgIGV2dC53aGljaCA9IGV2LndoaWNoO1xuICAgICAgICAgICAgZXZ0LnBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBldnQucGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHBsb3QudGFyZ2V0LnRyaWdnZXIoZXZ0LCBpbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZVJpZ2h0Q2xpY2soZXYsIGdyaWRwb3MsIGRhdGFwb3MsIG5laWdoYm9yLCBwbG90KSB7XG4gICAgICAgIGlmIChuZWlnaGJvcikge1xuICAgICAgICAgICAgdmFyIGlucyA9IFtuZWlnaGJvci5zZXJpZXNJbmRleCwgbmVpZ2hib3IucG9pbnRJbmRleCwgbmVpZ2hib3IuZGF0YV07XG4gICAgICAgICAgICB2YXIgaWR4ID0gcGxvdC5wbHVnaW5zLmxpbmVSZW5kZXJlci5oaWdobGlnaHRlZFNlcmllc0luZGV4O1xuICAgICAgICAgICAgaWYgKGlkeCAhPSBudWxsICYmIHBsb3Quc2VyaWVzW2lkeF0uaGlnaGxpZ2h0TW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgdW5oaWdobGlnaHQocGxvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZ0ID0galF1ZXJ5LkV2ZW50KCdqcXBsb3REYXRhUmlnaHRDbGljaycpO1xuICAgICAgICAgICAgZXZ0LndoaWNoID0gZXYud2hpY2g7XG4gICAgICAgICAgICBldnQucGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIGV2dC5wYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICAgICAgcGxvdC50YXJnZXQudHJpZ2dlcihldnQsIGlucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgXG5cbiAgICAvLyBjbGFzczogJC5qcXBsb3QuTGluZWFyQXhpc1JlbmRlcmVyXG4gICAgLy8gVGhlIGRlZmF1bHQganFQbG90IGF4aXMgcmVuZGVyZXIsIGNyZWF0aW5nIGEgbnVtZXJpYyBheGlzLlxuICAgICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggc2NvcGUgb2YgYXhpcyBvYmplY3QuXG4gICAgJC5qcXBsb3QuTGluZWFyQXhpc1JlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAgIC8vIHByb3A6IGJyZWFrUG9pbnRzXG4gICAgICAgIC8vIEVYUEVSSU1FTlRBTCEhIFVzZSBhdCB5b3VyIG93biByaXNrIVxuICAgICAgICAvLyBXb3JrcyBvbmx5IHdpdGggbGluZWFyIGF4ZXMgYW5kIHRoZSBkZWZhdWx0IHRpY2sgcmVuZGVyZXIuXG4gICAgICAgIC8vIEFycmF5IG9mIFtzdGFydCwgc3RvcF0gcG9pbnRzIHRvIGNyZWF0ZSBhIGJyb2tlbiBheGlzLlxuICAgICAgICAvLyBCcm9rZW4gYXhlcyBoYXZlIGEgXCJqdW1wXCIgaW4gdGhlbSwgd2hpY2ggaXMgYW4gaW1tZWRpYXRlIFxuICAgICAgICAvLyB0cmFuc2l0aW9uIGZyb20gYSBzbWFsbGVyIHZhbHVlIHRvIGEgbGFyZ2VyIHZhbHVlLlxuICAgICAgICAvLyBDdXJyZW50bHksIGF4aXMgdGlja3MgTVVTVCBiZSBtYW51YWxseSBhc3NpZ25lZCBpZiB1c2luZyBicmVha1BvaW50c1xuICAgICAgICAvLyBieSB1c2luZyB0aGUgYXhpcyB0aWNrcyBhcnJheSBvcHRpb24uXG4gICAgICAgIHRoaXMuYnJlYWtQb2ludHMgPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBicmVha1RpY2tMYWJlbFxuICAgICAgICAvLyBMYWJlbCB0byB1c2UgYXQgdGhlIGF4aXMgYnJlYWsgaWYgYnJlYWtQb2ludHMgYXJlIHNwZWNpZmllZC5cbiAgICAgICAgdGhpcy5icmVha1RpY2tMYWJlbCA9IFwiJmFzeW1wO1wiO1xuICAgICAgICAvLyBwcm9wOiBkcmF3QmFzZWxpbmVcbiAgICAgICAgLy8gVHJ1ZSB0byBkcmF3IHRoZSBheGlzIGJhc2VsaW5lLlxuICAgICAgICB0aGlzLmRyYXdCYXNlbGluZSA9IHRydWU7XG4gICAgICAgIC8vIHByb3A6IGJhc2VsaW5lV2lkdGhcbiAgICAgICAgLy8gd2lkdGggb2YgdGhlIGJhc2VsaW5lIGluIHBpeGVscy5cbiAgICAgICAgdGhpcy5iYXNlbGluZVdpZHRoID0gbnVsbDtcbiAgICAgICAgLy8gcHJvcDogYmFzZWxpbmVDb2xvclxuICAgICAgICAvLyBDU1MgY29sb3Igc3BlYyBmb3IgdGhlIGJhc2VsaW5lLlxuICAgICAgICB0aGlzLmJhc2VsaW5lQ29sb3IgPSBudWxsO1xuICAgICAgICAvLyBwcm9wOiBmb3JjZVRpY2tBdDBcbiAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZXJlIGlzIGFsd2F5cyBhIHRpY2sgbWFyayBhdCAwLlxuICAgICAgICAvLyBJZiBkYXRhIHJhbmdlIGlzIHN0cmljdGx5IHBvc2l0aXZlIG9yIG5lZ2F0aXZlLFxuICAgICAgICAvLyB0aGlzIHdpbGwgZm9yY2UgMCB0byBiZSBpbnNpZGUgdGhlIGF4aXMgYm91bmRzIHVubGVzc1xuICAgICAgICAvLyB0aGUgYXBwcm9wcmlhdGUgYXhpcyBwYWQgKHBhZCwgcGFkTWluIG9yIHBhZE1heCkgaXMgc2V0XG4gICAgICAgIC8vIHRvIDAsIHRoZW4gdGhpcyB3aWxsIGZvcmNlIGFuIGF4aXMgbWluIG9yIG1heCB2YWx1ZSBhdCAwLlxuICAgICAgICAvLyBUaGlzIGhhcyBrbm93IGVmZmVjdCB3aGVuIGFueSBvZiB0aGUgZm9sbG93aW5nIG9wdGlvbnNcbiAgICAgICAgLy8gYXJlIHNldDogIGF1dG9zY2FsZSwgbWluLCBtYXgsIG51bWJlclRpY2tzIG9yIHRpY2tJbnRlcnZhbC5cbiAgICAgICAgdGhpcy5mb3JjZVRpY2tBdDAgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogZm9yY2VUaWNrQXQxMDBcbiAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZXJlIGlzIGFsd2F5cyBhIHRpY2sgbWFyayBhdCAxMDAuXG4gICAgICAgIC8vIElmIGRhdGEgcmFuZ2UgaXMgc3RyaWN0bHkgYWJvdmUgb3IgYmVsb3cgMTAwLFxuICAgICAgICAvLyB0aGlzIHdpbGwgZm9yY2UgMTAwIHRvIGJlIGluc2lkZSB0aGUgYXhpcyBib3VuZHMgdW5sZXNzXG4gICAgICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBheGlzIHBhZCAocGFkLCBwYWRNaW4gb3IgcGFkTWF4KSBpcyBzZXRcbiAgICAgICAgLy8gdG8gMCwgdGhlbiB0aGlzIHdpbGwgZm9yY2UgYW4gYXhpcyBtaW4gb3IgbWF4IHZhbHVlIGF0IDEwMC5cbiAgICAgICAgLy8gVGhpcyBoYXMga25vdyBlZmZlY3Qgd2hlbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25zXG4gICAgICAgIC8vIGFyZSBzZXQ6ICBhdXRvc2NhbGUsIG1pbiwgbWF4LCBudW1iZXJUaWNrcyBvciB0aWNrSW50ZXJ2YWwuXG4gICAgICAgIHRoaXMuZm9yY2VUaWNrQXQxMDAgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogdGlja0luc2V0XG4gICAgICAgIC8vIENvbnRyb2xzIHRoZSBhbW91bnQgdG8gaW5zZXQgdGhlIGZpcnN0IGFuZCBsYXN0IHRpY2tzIGZyb20gXG4gICAgICAgIC8vIHRoZSBlZGdlcyBvZiB0aGUgZ3JpZCwgaW4gbXVsdGlwbGVzIG9mIHRoZSB0aWNrIGludGVydmFsLlxuICAgICAgICAvLyAwIGlzIG5vIGluc2V0LCAwLjUgaXMgb25lIGhhbGYgYSB0aWNrIGludGVydmFsLCAxIGlzIGEgZnVsbFxuICAgICAgICAvLyB0aWNrIGludGVydmFsLCBldGMuXG4gICAgICAgIHRoaXMudGlja0luc2V0ID0gMDtcbiAgICAgICAgLy8gcHJvcDogbWlub3JUaWNrc1xuICAgICAgICAvLyBOdW1iZXIgb2YgdGlja3MgdG8gYWRkIGJldHdlZW4gXCJtYWpvclwiIHRpY2tzLlxuICAgICAgICAvLyBNYWpvciB0aWNrcyBhcmUgdGlja3Mgc3VwcGxpZWQgYnkgdXNlciBvciBhdXRvIGNvbXB1dGVkLlxuICAgICAgICAvLyBNaW5vciB0aWNrcyBjYW5ub3QgYmUgY3JlYXRlZCBieSB1c2VyLlxuICAgICAgICB0aGlzLm1pbm9yVGlja3MgPSAwO1xuICAgICAgICAvLyBwcm9wOiBhbGlnblRpY2tzXG4gICAgICAgIC8vIHRydWUgdG8gYWxpZ24gdGljayBtYXJrcyBhY3Jvc3Mgb3Bwb3NlZCBheGVzXG4gICAgICAgIC8vIHN1Y2ggYXMgZnJvbSB0aGUgeTJheGlzIHRvIHlheGlzLlxuICAgICAgICB0aGlzLmFsaWduVGlja3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0b0Zvcm1hdFN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLl9vdmVycmlkZUZvcm1hdFN0cmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zY2FsZWZhY3QgPSAxLjA7XG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5icmVha1BvaW50cykge1xuICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkodGhpcy5icmVha1BvaW50cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyZWFrUG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYnJlYWtQb2ludHMubGVuZ3RoIDwgMiB8fCB0aGlzLmJyZWFrUG9pbnRzWzFdIDw9IHRoaXMuYnJlYWtQb2ludHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyZWFrUG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5udW1iZXJUaWNrcyAhPSBudWxsICYmIHRoaXMubnVtYmVyVGlja3MgPCAyKSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0RGF0YUJvdW5kcygpO1xuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggc2NvcGUgb2YgYXhpc1xuICAgICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgcGxvdCkge1xuICAgICAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgYXhpcyBsYWJlbCBhbmQgdmFsdWUgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vIGNyZWF0ZVRpY2tzIGlzIGEgbWV0aG9kIG9uIHRoZSByZW5kZXJlciwgYnV0XG4gICAgICAgICAgICAvLyBjYWxsIGl0IHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGF4aXMuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRpY2tzLmNhbGwodGhpcywgcGxvdCk7XG4gICAgICAgICAgICAvLyBmaWxsIGEgZGl2IHdpdGggYXhlcyBsYWJlbHMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcHJlZ2VuZXJhdGUgZWFjaCBheGlzIHRvIGdldCBpdHMgYm91bmRzIGFuZFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gaXQgYW5kIHRoZSBsYWJlbHMgY29ycmVjdGx5IG9uIHRoZSBwbG90LlxuICAgICAgICAgICAgdmFyIGRpbT0wO1xuICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICAvLyBBZGRlZCBmb3IgdGhlbWluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVtb3J5IExlYWtzIHBhdGNoXG4gICAgICAgICAgICAgICAgLy90aGlzLl9lbGVtLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5lbXB0eUZvcmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX2VsZW0gPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uYWRkQ2xhc3MoJ2pxcGxvdC1heGlzIGpxcGxvdC0nK3RoaXMubmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09ICd4YXhpcycgfHwgdGhpcy5uYW1lID09ICd4MmF4aXMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS53aWR0aCh0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmhlaWdodCh0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBfbGFiZWwgb2JqZWN0LlxuICAgICAgICAgICAgdGhpcy5sYWJlbE9wdGlvbnMuYXhpcyA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbmV3IHRoaXMubGFiZWxSZW5kZXJlcih0aGlzLmxhYmVsT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwuc2hvdykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5fbGFiZWwuZHJhdyhjdHgsIHBsb3QpO1xuICAgICAgICAgICAgICAgIGVsZW0uYXBwZW5kVG8odGhpcy5fZWxlbSk7XG4gICAgICAgICAgICAgICAgZWxlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuX3RpY2tzO1xuICAgICAgICAgICAgdmFyIHRpY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aWNrLnNob3cgJiYgdGljay5zaG93TGFiZWwgJiYgKCF0aWNrLmlzTWlub3JUaWNrIHx8IHRoaXMuc2hvd01pbm9yVGlja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uYXBwZW5kKHRpY2suZHJhdyhjdHgsIHBsb3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWNrID0gbnVsbDtcbiAgICAgICAgICAgIHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtO1xuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggc2NvcGUgb2YgYW4gYXhpc1xuICAgICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLl9vcHRpb25zLm1pbjtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLl9vcHRpb25zLm1heDtcbiAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSB0aGlzLl9vcHRpb25zLnRpY2tJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5udW1iZXJUaWNrcyA9IHRoaXMuX29wdGlvbnMubnVtYmVyVGlja3M7XG4gICAgICAgIHRoaXMuX2F1dG9Gb3JtYXRTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlRm9ybWF0U3RyaW5nICYmIHRoaXMudGlja09wdGlvbnMgJiYgdGhpcy50aWNrT3B0aW9ucy5mb3JtYXRTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGlja09wdGlvbnMuZm9ybWF0U3RyaW5nID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLl90aWNrcyA9IHRoaXMuX190aWNrcztcbiAgICB9O1xuICAgIFxuICAgIC8vIGNhbGxlZCB3aXRoIHNjb3BlIG9mIGF4aXNcbiAgICAkLmpxcGxvdC5MaW5lYXJBeGlzUmVuZGVyZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgdmFyIGRpbSA9IDA7XG4gICAgICAgIHZhciB0ZW1wO1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIHZhciBoID0gMDtcbiAgICAgICAgdmFyIGxzaG93ID0gKHRoaXMuX2xhYmVsID09IG51bGwpID8gZmFsc2UgOiB0aGlzLl9sYWJlbC5zaG93O1xuICAgICAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuX3RpY2tzO1xuICAgICAgICAgICAgdmFyIHRpY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdGljay5fYnJlYWtUaWNrICYmIHRpY2suc2hvdyAmJiB0aWNrLnNob3dMYWJlbCAmJiAoIXRpY2suaXNNaW5vclRpY2sgfHwgdGhpcy5zaG93TWlub3JUaWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSAneGF4aXMnIHx8IHRoaXMubmFtZSA9PSAneDJheGlzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRpY2suX2VsZW0ub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGljay5fZWxlbS5vdXRlcldpZHRoKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wID4gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGljayA9IG51bGw7XG4gICAgICAgICAgICB0ID0gbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGxzaG93KSB7XG4gICAgICAgICAgICAgICAgdyA9IHRoaXMuX2xhYmVsLl9lbGVtLm91dGVyV2lkdGgodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuX2xhYmVsLl9lbGVtLm91dGVySGVpZ2h0KHRydWUpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gJ3hheGlzJykge1xuICAgICAgICAgICAgICAgIGRpbSA9IGRpbSArIGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3MoeydoZWlnaHQnOmRpbSsncHgnLCBsZWZ0OicwcHgnLCBib3R0b206JzBweCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PSAneDJheGlzJykge1xuICAgICAgICAgICAgICAgIGRpbSA9IGRpbSArIGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3MoeydoZWlnaHQnOmRpbSsncHgnLCBsZWZ0OicwcHgnLCB0b3A6JzBweCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PSAneWF4aXMnKSB7XG4gICAgICAgICAgICAgICAgZGltID0gZGltICsgdztcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7J3dpZHRoJzpkaW0rJ3B4JywgbGVmdDonMHB4JywgdG9wOicwcHgnfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxzaG93ICYmIHRoaXMuX2xhYmVsLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkF4aXNMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLl9lbGVtLmNzcygnd2lkdGgnLCB3KydweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpbSA9IGRpbSArIHc7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moeyd3aWR0aCc6ZGltKydweCcsIHJpZ2h0OicwcHgnLCB0b3A6JzBweCd9KTtcbiAgICAgICAgICAgICAgICBpZiAobHNob3cgJiYgdGhpcy5fbGFiZWwuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuQXhpc0xhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuX2VsZW0uY3NzKCd3aWR0aCcsIHcrJ3B4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ICBcbiAgICB9OyAgICBcbiAgICBcbiAgICAvLyBjYWxsZWQgd2l0aCBzY29wZSBvZiBheGlzXG4gICAgJC5qcXBsb3QuTGluZWFyQXhpc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUaWNrcyA9IGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgLy8gd2UncmUgYXJlIG9wZXJhdGluZyBvbiBhbiBheGlzIGhlcmVcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5fdGlja3M7XG4gICAgICAgIHZhciB1c2VyVGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgLy8gZGF0YWJvdW5kcyB3ZXJlIHNldCBvbiBheGlzIGluaXRpYWxpemF0aW9uLlxuICAgICAgICB2YXIgZGIgPSB0aGlzLl9kYXRhQm91bmRzO1xuICAgICAgICB2YXIgZGltID0gKHRoaXMubmFtZS5jaGFyQXQoMCkgPT09ICd4JykgPyB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCA6IHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgdmFyIGludGVydmFsO1xuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIHZhciBwb3MxLCBwb3MyO1xuICAgICAgICB2YXIgdHQsIGk7XG4gICAgICAgIC8vIGdldCBhIGNvcHkgb2YgdXNlcidzIHNldHRpbmdzIGZvciBtaW4vbWF4LlxuICAgICAgICB2YXIgdXNlck1pbiA9IHRoaXMubWluO1xuICAgICAgICB2YXIgdXNlck1heCA9IHRoaXMubWF4O1xuICAgICAgICB2YXIgdXNlck5UID0gdGhpcy5udW1iZXJUaWNrcztcbiAgICAgICAgdmFyIHVzZXJUSSA9IHRoaXMudGlja0ludGVydmFsO1xuXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSAzMDtcbiAgICAgICAgdGhpcy5fc2NhbGVmYWN0ID0gIChNYXRoLm1heChkaW0sIHRocmVzaG9sZCsxKSAtIHRocmVzaG9sZCkvMzAwLjA7XG4gICAgICAgIFxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGlja3MsIHVzZSB0aGVtLlxuICAgICAgICAvLyB0aWNrcyBtdXN0IGJlIGluIG9yZGVyIG9mIGluY3JlYXNpbmcgdmFsdWUuXG4gICAgICAgIFxuICAgICAgICBpZiAodXNlclRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGlja3MgY291bGQgYmUgMUQgb3IgMkQgYXJyYXkgb2YgW3ZhbCwgdmFsLCAsLCxdIG9yIFtbdmFsLCBsYWJlbF0sIFt2YWwsIGxhYmVsXSwgLi4uXSBvciBtaXhlZFxuICAgICAgICAgICAgZm9yIChpPTA7IGk8dXNlclRpY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgdXQgPSB1c2VyVGlja3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgdGhpcy50aWNrUmVuZGVyZXIodGhpcy50aWNrT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheSh1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSA9IHV0WzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5icmVha1BvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0WzBdID09IHRoaXMuYnJlYWtQb2ludHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmxhYmVsID0gdGhpcy5icmVha1RpY2tMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ll9icmVha1RpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc2hvd0dyaWRsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zaG93TWFyayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXRbMF0gPiB0aGlzLmJyZWFrUG9pbnRzWzBdICYmIHV0WzBdIDw9IHRoaXMuYnJlYWtQb2ludHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNob3dHcmlkbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubGFiZWwgPSB1dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubGFiZWwgPSB1dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQubGFiZWwgPSB1dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnNldFRpY2sodXRbMF0sIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tzLnB1c2godCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0LCB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHQuYXhpcyA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGlja3MucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHQudmFsdWUgPSB1dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnJlYWtQb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dCA9PSB0aGlzLmJyZWFrUG9pbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5sYWJlbCA9IHRoaXMuYnJlYWtUaWNrTGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5fYnJlYWtUaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNob3dHcmlkbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc2hvd01hcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0ID4gdGhpcy5icmVha1BvaW50c1swXSAmJiB1dCA8PSB0aGlzLmJyZWFrUG9pbnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zaG93R3JpZGxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnNldFRpY2sodXQsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tzLnB1c2godCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5udW1iZXJUaWNrcyA9IHVzZXJUaWNrcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IHRoaXMuX3RpY2tzWzBdLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLl90aWNrc1t0aGlzLm51bWJlclRpY2tzLTFdLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAodGhpcy5tYXggLSB0aGlzLm1pbikgLyAodGhpcy5udW1iZXJUaWNrcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGFueSB0aWNrcyB5ZXQsIGxldCdzIG1ha2Ugc29tZSFcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSAneGF4aXMnIHx8IG5hbWUgPT0gJ3gyYXhpcycpIHtcbiAgICAgICAgICAgICAgICBkaW0gPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpbSA9IHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9udW1iZXJUaWNrcyA9IHRoaXMubnVtYmVyVGlja3M7XG5cbiAgICAgICAgICAgIC8vIGlmIGFsaWduaW5nIHRoaXMgYXhpcywgdXNlIG51bWJlciBvZiB0aWNrcyBmcm9tIHByZXZpb3VzIGF4aXMuXG4gICAgICAgICAgICAvLyBEbyBJIG5lZWQgdG8gcmVzZXQgc29tZWhvdyBpZiBhbGlnblRpY2tzIGlzIGNoYW5nZWQgYW5kIHRoZW4gZ3JhcGggaXMgcmVwbG90dGVkPz9cbiAgICAgICAgICAgIGlmICh0aGlzLmFsaWduVGlja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lID09PSAneDJheGlzJyAmJiBwbG90LmF4ZXMueGF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfbnVtYmVyVGlja3MgPSBwbG90LmF4ZXMueGF4aXMubnVtYmVyVGlja3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZS5jaGFyQXQoMCkgPT09ICd5JyAmJiB0aGlzLm5hbWUgIT09ICd5YXhpcycgJiYgdGhpcy5uYW1lICE9PSAneU1pZEF4aXMnICYmIHBsb3QuYXhlcy55YXhpcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF9udW1iZXJUaWNrcyA9IHBsb3QuYXhlcy55YXhpcy5udW1iZXJUaWNrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgbWluID0gKCh0aGlzLm1pbiAhPSBudWxsKSA/IHRoaXMubWluIDogZGIubWluKTtcbiAgICAgICAgICAgIG1heCA9ICgodGhpcy5tYXggIT0gbnVsbCkgPyB0aGlzLm1heCA6IGRiLm1heCk7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgICAgICAgICAgIHZhciBybWluLCBybWF4O1xuICAgICAgICAgICAgdmFyIHRlbXA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRpY2tPcHRpb25zID09IG51bGwgfHwgIXRoaXMudGlja09wdGlvbnMuZm9ybWF0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJpZGVGb3JtYXRTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEb2luZyBjb21wbGV0ZSBhdXRvc2NhbGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubWluID09IG51bGwgfHwgdGhpcy5tYXggPT0gbnVsbCAmJiB0aGlzLnRpY2tJbnRlcnZhbCA9PSBudWxsICYmICF0aGlzLmF1dG9zY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHVzZXIgbXVzdCBoYXZlIHRpY2sgYXQgMCBvciAxMDAgYW5kIGVuc3VyZSB0aGV5IGFyZSBpbiByYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYXV0b3NjYWxpbmcgYWxnb3JpdGhtIHdpbGwgYWx3YXlzIHBsYWNlIHRpY2tzIGF0IDAgYW5kIDEwMCBpZiB0aGV5IGFyZSBpbiByYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JjZVRpY2tBdDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JjZVRpY2tBdDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGtlZXBNaW4gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAga2VlcE1heCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcE1pbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBrZWVwTWF4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB2YXIgdGhyZXNob2xkID0gMzA7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHRkaW0gPSBNYXRoLm1heChkaW0sIHRocmVzaG9sZCsxKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zY2FsZWZhY3QgPSAgKHRkaW0tdGhyZXNob2xkKS8zMDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gJC5qcXBsb3QuTGluZWFyVGlja0dlbmVyYXRvcihtaW4sIG1heCwgdGhpcy5fc2NhbGVmYWN0LCBfbnVtYmVyVGlja3MsIGtlZXBNaW4sIGtlZXBNYXgpOyBcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYSBwYWRkZWQgbWF4IGFuZCBtaW4sIHBvaW50cyBzaG91bGQgYmUgbGVzcyB0aGFuIHRoZXNlXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5IGFyZW4ndCB0b28gY2xvc2UgdG8gdGhlIGVkZ2VzIG9mIHRoZSBwbG90LlxuICAgICAgICAgICAgICAgIC8vIFVzZXIgY2FuIGFkanVzdCBob3cgbXVjaCBwYWRkaW5nIGlzIGFsbG93ZWQgd2l0aCBwYWQsIHBhZE1pbiBhbmQgUGFkTWF4IG9wdGlvbnMuIFxuICAgICAgICAgICAgICAgIC8vIElmIG1pbiBvciBtYXggaXMgc2V0LCBkb24ndCBwYWQgdGhhdCBlbmQgb2YgYXhpcy5cbiAgICAgICAgICAgICAgICB2YXIgdHVtaW4gPSAodGhpcy5taW4gIT0gbnVsbCkgPyBtaW4gOiBtaW4gKyByYW5nZSoodGhpcy5wYWRNaW4gLSAxKTtcbiAgICAgICAgICAgICAgICB2YXIgdHVtYXggPSAodGhpcy5tYXggIT0gbnVsbCkgPyBtYXggOiBtYXggLSByYW5nZSoodGhpcy5wYWRNYXggLSAxKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkncmUgZXF1YWwsIHdlIHNob3VsZG4ndCBoYXZlIHRvIGRvIGFueXRoaW5nLCByaWdodD9cbiAgICAgICAgICAgICAgICAvLyBpZiAobWluIDw9dHVtaW4gfHwgbWF4ID49IHR1bWF4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA8dHVtaW4gfHwgbWF4ID4gdHVtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVtaW4gPSAodGhpcy5taW4gIT0gbnVsbCkgPyBtaW4gOiBtaW4gLSByYW5nZSoodGhpcy5wYWRNaW4gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHVtYXggPSAodGhpcy5tYXggIT0gbnVsbCkgPyBtYXggOiBtYXggKyByYW5nZSoodGhpcy5wYWRNYXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gJC5qcXBsb3QuTGluZWFyVGlja0dlbmVyYXRvcih0dW1pbiwgdHVtYXgsIHRoaXMuX3NjYWxlZmFjdCwgX251bWJlclRpY2tzLCBrZWVwTWluLCBrZWVwTWF4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IHJldFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IHJldFsxXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBudW1iZXJUaWNrcyBzcGVjaWZpZWQsIGl0IHNob3VsZCByZXR1cm4gdGhlIHNhbWUuXG4gICAgICAgICAgICAgICAgdGhpcy5udW1iZXJUaWNrcyA9IHJldFsyXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvRm9ybWF0U3RyaW5nID0gcmV0WzNdO1xuICAgICAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gcmV0WzRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2VyIGhhcyBzcGVjaWZpZWQgc29tZSBheGlzIHNjYWxlIHJlbGF0ZWQgb3B0aW9uLCBjYW4gdXNlIGF1dG8gYWxnb3JpdGhtXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBpZiBtaW4gYW5kIG1heCBhcmUgc2FtZSwgc3BhY2UgdGhlbSBvdXQgYSBiaXRcbiAgICAgICAgICAgICAgICBpZiAobWluID09IG1heCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRqID0gMC4wNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkaiA9IE1hdGgubWF4KE1hdGgubG9nKG1pbikvTWF0aC5MTjEwLCAwLjA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtaW4gLT0gYWRqO1xuICAgICAgICAgICAgICAgICAgICBtYXggKz0gYWRqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhdXRvc2NhbGUuICBDYW4ndCBhdXRvc2NhbGUgaWYgbWluIG9yIG1heCBpcyBzdXBwbGllZC5cbiAgICAgICAgICAgICAgICAvLyBXaWxsIHVzZSBudW1iZXJUaWNrcyBhbmQgdGlja0ludGVydmFsIGlmIHN1cHBsaWVkLiAgVGlja3NcbiAgICAgICAgICAgICAgICAvLyBhY3Jvc3MgbXVsdGlwbGUgYXhlcyBtYXkgbm90IGxpbmUgdXAgZGVwZW5kaW5nIG9uIGhvd1xuICAgICAgICAgICAgICAgIC8vIGJhcnMgYXJlIHRvIGJlIHBsb3R0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b3NjYWxlICYmIHRoaXMubWluID09IG51bGwgJiYgdGhpcy5tYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnJhbmdlLCB0aSwgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2VNaW5aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZVplcm9MaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbHMgPSB7bWluOm51bGwsIG1heDpudWxsLCBhdmVyYWdlOm51bGwsIHN0ZGRldjpudWxsfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW55IHNlcmllcyBhcmUgYmFycywgb3IgaWYgYW55IGFyZSBmaWxsIHRvIHplcm8sIGFuZCBpZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBheGlzIHRvIGZpbGwgdG93YXJkLCBjaGVjayB0byBzZWUgaWYgd2UgY2FuIHN0YXJ0IGF4aXMgYXQgemVyby5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuX3Nlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9zZXJpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFuYW1lID0gKHMuZmlsbEF4aXMgPT0gJ3gnKSA/IHMuX3hheGlzLm5hbWUgOiBzLl95YXhpcy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgdGhlIGZpbGwgYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSBmYW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFscyA9IHMuX3Bsb3RWYWx1ZXNbcy5maWxsQXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZtaW4gPSB2YWxzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2bWF4ID0gdmFsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTE7IGo8dmFscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsc1tqXSA8IHZtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZtaW4gPSB2YWxzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHNbal0gPiB2bWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bWF4ID0gdmFsc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHAgPSAodm1heCAtIHZtaW4pIC8gdm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHNyaWVzIGEgYmFyP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkJhclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIG5lZ2F0aXZlIHZhbHVlcyBhbmQgY291bGQgYWxzbyBjaGVjayByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZtaW4gPj0gMCAmJiAocy5maWxsVG9aZXJvIHx8IGRwID4gMC4xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VNaW5aZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlTWluWmVybyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuZmlsbCAmJiBzLmZpbGxUb1plcm8gJiYgdm1pbiA8IDAgJiYgdm1heCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVplcm9MaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlWmVyb0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBiYXIgYW5kIGZpbGxpbmcsIHVzZSBhcHByb3ByaWF0ZSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocy5maWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bWluID49IDAgJiYgKHMuZmlsbFRvWmVybyB8fCBkcCA+IDAuMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlTWluWmVybyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodm1pbiA8IDAgJiYgdm1heCA+IDAgJiYgcy5maWxsVG9aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZU1pblplcm8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlWmVyb0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VNaW5aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVplcm9MaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGEgYmFyIGFuZCBub3QgZmlsbGluZywgb25seSBjaGFuZ2UgZXhpc3Rpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2bWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZU1pblplcm8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgbWFrZSBheGlzIG1pbiBhdCAwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VNaW5aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1iZXJUaWNrcyA9IDIgKyBNYXRoLmNlaWwoKGRpbS0odGhpcy50aWNrU3BhY2luZy0xKSkvdGhpcy50aWNrU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyTWluID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgb3JkZXIgaXMgdGhpcyByYW5nZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgdGljayBpbnRlcnZhbCBkb2VzIHRoYXQgZ2l2ZSB1cz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpID0gbWF4Lyh0aGlzLm51bWJlclRpY2tzLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IE1hdGgucG93KDEwLCBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgubG9nKHRpKS9NYXRoLkxOMTApKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGkvdGVtcCA9PSBwYXJzZUludCh0aS90ZW1wLCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aSArPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSBNYXRoLmNlaWwodGkvdGVtcCkgKiB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLnRpY2tJbnRlcnZhbCAqICh0aGlzLm51bWJlclRpY2tzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgdGljayBhdCAwLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZVplcm9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1iZXJUaWNrcyA9IDIgKyBNYXRoLmNlaWwoKGRpbS0odGhpcy50aWNrU3BhY2luZy0xKSkvdGhpcy50aWNrU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnRtaW4gPSBNYXRoLmNlaWwoTWF0aC5hYnMobWluKS9yYW5nZSoodGhpcy5udW1iZXJUaWNrcy0xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnRtYXggPSB0aGlzLm51bWJlclRpY2tzIC0gMSAgLSBudG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpID0gTWF0aC5tYXgoTWF0aC5hYnMobWluL250bWluKSwgTWF0aC5hYnMobWF4L250bWF4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5wb3coMTAsIE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5sb2codGkpL01hdGguTE4xMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gTWF0aC5jZWlsKHRpL3RlbXApICogdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpcy50aWNrSW50ZXJ2YWwgKiBudG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluID0gLXRoaXMudGlja0ludGVydmFsICogbnRtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdGhpbmcgZWxzZSwgZG8gYXV0b3NjYWxpbmcgd2hpY2ggd2lsbCB0cnkgdG8gbGluZSB1cCB0aWNrcyBhY3Jvc3MgYXhlcy5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm51bWJlclRpY2tzID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gMyArIE1hdGguY2VpbChyYW5nZSAvIHRoaXMudGlja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyVGlja3MgPSAyICsgTWF0aC5jZWlsKChkaW0tKHRoaXMudGlja1NwYWNpbmctMSkpL3RoaXMudGlja1NwYWNpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGEgdGljayBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpID0gcmFuZ2UvKHRoaXMubnVtYmVyVGlja3MgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IE1hdGgucG93KDEwLCBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgubG9nKHRpKS9NYXRoLkxOMTApKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSBNYXRoLmNlaWwodGkqdGVtcCp0aGlzLnBhZCkvdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSAxIC8gdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBjb21wdXRlIGEgbmljZXIsIG1vcmUgZXZlbiB0aWNrIGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2codGkpL01hdGguTE4xMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy50aWNrSW50ZXJ2YWwgPSBNYXRoLmNlaWwodGkvdGVtcCkgKiB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnJhbmdlID0gdGhpcy50aWNrSW50ZXJ2YWwgKiAodGhpcy5udW1iZXJUaWNrcyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gKHJyYW5nZSAtIHJhbmdlKS8yO1xuICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLmZsb29yKHRlbXAqKG1pbi1tYXJnaW4pKS90ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMubWluICsgcnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhIHNvbWV3aGF0IGRlY2VudCBmb3JtYXQgc3RyaW5nIGlmIGl0IGlzIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHByZWNpc2lvbiBvZiBpbnRlcnZhbCBhbmQgZGV0ZXJtaW5lIGEgZm9ybWF0IHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNmID0gJC5qcXBsb3QuZ2V0U2lnbmlmaWNhbnRGaWd1cmVzKHRoaXMudGlja0ludGVydmFsKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZnN0cjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG9ubHkgYSB3aG9sZSBudW1iZXIsIHVzZSBpbnRlZ2VyIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNmLmRpZ2l0c0xlZnQgPj0gc2Yuc2lnbmlmaWNhbnREaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzdHIgPSAnJWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IE1hdGgubWF4KDAsIDUgLSBzZi5kaWdpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBNYXRoLm1pbih0ZW1wLCBzZi5kaWdpdHNSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc3RyID0gJyUuJysgdGVtcCArICdmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9Gb3JtYXRTdHJpbmcgPSBmc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgYWxnb3JpdGhtIHdoaWNoIHBhZHMgZWFjaCBheGlzIHRvIG1ha2UgdGhlIGNoYXJ0XG4gICAgICAgICAgICAgICAgLy8gY2VudGVyZWQgbmljZWx5IG9uIHRoZSBncmlkLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHJtaW4gPSAodGhpcy5taW4gIT0gbnVsbCkgPyB0aGlzLm1pbiA6IG1pbiAtIHJhbmdlKih0aGlzLnBhZE1pbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBybWF4ID0gKHRoaXMubWF4ICE9IG51bGwpID8gdGhpcy5tYXggOiBtYXggKyByYW5nZSoodGhpcy5wYWRNYXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBybWF4IC0gcm1pbjtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm51bWJlclRpY2tzID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGlja0ludGVydmFsIGlzIHNwZWNpZmllZCBieSB1c2VyLCB3ZSB3aWxsIGlnbm9yZSBjb21wdXRlZCBtYXhpbXVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHdpbGwgYmUgZXF1YWwgb3IgZ3JlYXRlciB0byBmaXQgZXZlbiAjIG9mIHRpY2tzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGlja0ludGVydmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gTWF0aC5jZWlsKChybWF4IC0gcm1pbikvdGhpcy50aWNrSW50ZXJ2YWwpKzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaW0gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gcGFyc2VJbnQoMysoZGltLTEwMCkvNzUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyVGlja3MgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9IHJhbmdlIC8gKHRoaXMubnVtYmVyVGlja3MtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBybWF4ID0gcm1pbiArIHRoaXMudGlja0ludGVydmFsKih0aGlzLm51bWJlclRpY2tzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm1pbiA9IHJtYXggLSB0aGlzLnRpY2tJbnRlcnZhbCoodGhpcy5udW1iZXJUaWNrcyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHByZWNpc2lvbiBvZiBpbnRlcnZhbCBhbmQgZGV0ZXJtaW5lIGEgZm9ybWF0IHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNmID0gJC5qcXBsb3QuZ2V0U2lnbmlmaWNhbnRGaWd1cmVzKHRoaXMudGlja0ludGVydmFsKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZnN0cjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG9ubHkgYSB3aG9sZSBudW1iZXIsIHVzZSBpbnRlZ2VyIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNmLmRpZ2l0c0xlZnQgPj0gc2Yuc2lnbmlmaWNhbnREaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzdHIgPSAnJWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IE1hdGgubWF4KDAsIDUgLSBzZi5kaWdpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBNYXRoLm1pbih0ZW1wLCBzZi5kaWdpdHNSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc3RyID0gJyUuJysgdGVtcCArICdmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0b0Zvcm1hdFN0cmluZyA9IGZzdHI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4gPSBybWluO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heCA9IHJtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlciAmJiB0aGlzLl9hdXRvRm9ybWF0U3RyaW5nID09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgbWlzbGVhZGluZyB0aWNrIGRpc3BsYXkgd2l0aCBzbWFsbCByYW5nZSBhbmQgbG93IHByZWNpc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLm1heCAtIHRoaXMubWluO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHByZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcHRpY2sgPSBuZXcgdGhpcy50aWNrUmVuZGVyZXIodGhpcy50aWNrT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdGljayBmb3JtYXRTdHJpbmcgb3IsIHRoZSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSB0ZW1wdGljay5mb3JtYXRTdHJpbmcgfHwgJC5qcXBsb3QuY29uZmlnLmRlZmF1bHRUaWNrRm9ybWF0U3RyaW5nOyBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gZnMubWF0Y2goJC5qcXBsb3Quc3ByaW50Zi5yZWdleClbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcy5zZWFyY2goL1tmRmVFZ0dwUF0vKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBmcy5tYXRjaCgvXFwlXFwuKFxcZHswLH0pP1tlRWZGZ0dwUF0vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZzLnNlYXJjaCgvW2RpXS8pID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFjdCB3aWxsIGJlIDw9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdCA9IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJbnRlcnZhbCA8IGZhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNvcnJlY3QgdW5kZXJyYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyTlQgPT0gbnVsbCAmJiB1c2VyVEkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9IGZhY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyTWF4ID09IG51bGwgJiYgdXNlck1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLm1pbiA9IE1hdGguZmxvb3IoKHRoaXMuX2RhdGFCb3VuZHMubWluIC0gdGhpcy50aWNrSW50ZXJ2YWwpL2ZhY3QpICogZmFjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5mbG9vcih0aGlzLl9kYXRhQm91bmRzLm1pbi9mYWN0KSAqIGZhY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW4gPT0gdGhpcy5fZGF0YUJvdW5kcy5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IHRoaXMuX2RhdGFCb3VuZHMubWluIC0gdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLm1heCA9IE1hdGguY2VpbCgodGhpcy5fZGF0YUJvdW5kcy5tYXggKyB0aGlzLnRpY2tJbnRlcnZhbCkvZmFjdCkgKiBmYWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLmNlaWwodGhpcy5fZGF0YUJvdW5kcy5tYXgvZmFjdCkgKiBmYWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID09IHRoaXMuX2RhdGFCb3VuZHMubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLl9kYXRhQm91bmRzLm1heCArIHRoaXMudGlja0ludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAodGhpcy5tYXggLSB0aGlzLm1pbikvdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi50b0ZpeGVkKDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLmNlaWwobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gbiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlck1heCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgb25lIHRpY2sgZm9yIHRvcCBvZiByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gKHRoaXMuX2RhdGFCb3VuZHMubWF4IC0gdGhpcy5taW4pIC8gdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi50b0ZpeGVkKDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyVGlja3MgPSBNYXRoLmNlaWwobikgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLm1pbiArIHRoaXMudGlja0ludGVydmFsICogKHRoaXMubnVtYmVyVGlja3MtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlck1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgb25lIHRpY2sgZm9yIGJvdHRvbSBvZiByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gKHRoaXMubWF4IC0gdGhpcy5fZGF0YUJvdW5kcy5taW4pIC8gdGhpcy50aWNrSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi50b0ZpeGVkKDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyVGlja3MgPSBNYXRoLmNlaWwobikgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4gPSB0aGlzLm1heCAtIHRoaXMudGlja0ludGVydmFsICogKHRoaXMubnVtYmVyVGlja3MtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYSBudW1iZXIgb2YgdGlja3Mgc28gbWF4IGlzIHdpdGhpbiBheGlzIHNjYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWJlclRpY2tzID0gTWF0aC5jZWlsKCh1c2VyTWF4IC0gdXNlck1pbikvdGhpcy50aWNrSW50ZXJ2YWwpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIncyBtaW4gYW5kIG1heCBkb24ndCBmaXQgZXZlbmx5IGluIHRpY2tzLCBhZGp1c3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRha2VzIGNhcmUgb2YgY2FzZXMgc3VjaCBhcyB1c2VyIG1pbiBzZXQgdG8gMCwgbWF4IHNldCB0byAzLjUgYnV0IHRpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdCBzdHJpbmcgc2V0IHRvICVkIChpbnRlZ2VyIHRpY2tzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4gPSAgTWF0aC5mbG9vcih1c2VyTWluKk1hdGgucG93KDEwLCBwcmVjaXNpb24pKS9NYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gIE1hdGguY2VpbCh1c2VyTWF4Kk1hdGgucG93KDEwLCBwcmVjaXNpb24pKS9NYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMubWF4ID0gdGhpcy5taW4gKyB0aGlzLnRpY2tJbnRlcnZhbCoodGhpcy5udW1iZXJUaWNrcy0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyVGlja3MgPSBNYXRoLmNlaWwoKHRoaXMubWF4IC0gdGhpcy5taW4pL3RoaXMudGlja0ludGVydmFsKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycmlkZUZvcm1hdFN0cmluZyAmJiB0aGlzLl9hdXRvRm9ybWF0U3RyaW5nICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrT3B0aW9ucyA9IHRoaXMudGlja09wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrT3B0aW9ucy5mb3JtYXRTdHJpbmcgPSB0aGlzLl9hdXRvRm9ybWF0U3RyaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdCwgdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5udW1iZXJUaWNrczsgaSsrKXtcbiAgICAgICAgICAgICAgICB0dCA9IHRoaXMubWluICsgaSAqIHRoaXMudGlja0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHQgPSBuZXcgdGhpcy50aWNrUmVuZGVyZXIodGhpcy50aWNrT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHQgPSBuZXcgJC5qcXBsb3QuQXhpc1RpY2tSZW5kZXJlcih0aGlzLnRpY2tPcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIHQuc2V0VGljayh0dCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrcy5wdXNoKHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLm51bWJlclRpY2tzIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8dGhpcy5taW5vclRpY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0ICs9IHRoaXMudGlja0ludGVydmFsLyh0aGlzLm1pbm9yVGlja3MrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLnRpY2tPcHRpb25zLCB7bmFtZTp0aGlzLm5hbWUsIHZhbHVlOnR0LCBsYWJlbDonJywgaXNNaW5vclRpY2s6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5ldyB0aGlzLnRpY2tSZW5kZXJlcih0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWNrcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0luc2V0KSB7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IHRoaXMubWluIC0gdGhpcy50aWNrSW5zZXQgKiB0aGlzLnRpY2tJbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpcy5tYXggKyB0aGlzLnRpY2tJbnNldCAqIHRoaXMudGlja0ludGVydmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlja3MgPSBudWxsO1xuICAgIH07XG4gICAgXG4gICAgLy8gVXNlZCB0byByZXNldCBqdXN0IHRoZSB2YWx1ZXMgb2YgdGhlIHRpY2tzIGFuZCB0aGVuIHJlcGFjaywgd2hpY2ggd2lsbFxuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBwb3NpdGlvbmluZyBmdW5jdGlvbnMuICBJdCBpcyBhc3N1ZW1kIHRoYXQgdGhlIFxuICAgIC8vIG51bWJlciBvZiB0aWNrcyBpcyB0aGUgc2FtZSBhbmQgdGhlIHZhbHVlcyBvZiB0aGUgbmV3IGFycmF5IGFyZSBhdCB0aGVcbiAgICAvLyBwcm9wZXIgaW50ZXJ2YWwuXG4gICAgLy8gVGhpcyBtZXRob2QgbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIHNjb3BlIG9mIGFuIGF4aXMgb2JqZWN0LCBsaWtlOlxuICAgIC8vXG4gICAgLy8gPiBwbG90LmF4ZXMueWF4aXMucmVuZGVyZXIucmVzZXRUaWNrVmFsdWVzLmNhbGwocGxvdC5heGVzLnlheGlzLCB5YXJyKTtcbiAgICAvL1xuICAgICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlci5wcm90b3R5cGUucmVzZXRUaWNrVmFsdWVzID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICBpZiAoJC5pc0FycmF5KG9wdHMpICYmIG9wdHMubGVuZ3RoID09IHRoaXMuX3RpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8b3B0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLl90aWNrc1tpXTtcbiAgICAgICAgICAgICAgICB0LnZhbHVlID0gb3B0c1tpXTtcbiAgICAgICAgICAgICAgICB0LmxhYmVsID0gdC5mb3JtYXR0ZXIodC5mb3JtYXRTdHJpbmcsIG9wdHNbaV0pO1xuICAgICAgICAgICAgICAgIHQubGFiZWwgPSB0LnByZWZpeCArIHQubGFiZWw7XG4gICAgICAgICAgICAgICAgdC5fZWxlbS5odG1sKHQubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1pbiA9ICQuanFwbG90LmFycmF5TWluKG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5tYXggPSAkLmpxcGxvdC5hcnJheU1heChvcHRzKTtcbiAgICAgICAgICAgIHRoaXMucGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICAgIC8vIGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChvcHRzKSkge1xuICAgICAgICAvLyBcbiAgICAgICAgLy8gfVxuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggc2NvcGUgb2YgYXhpc1xuICAgICQuanFwbG90LkxpbmVhckF4aXNSZW5kZXJlci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKHBvcywgb2Zmc2V0cykge1xuICAgICAgICAvLyBBZGQgZGVmYXVsdHMgZm9yIHJlcGFja2luZyBmcm9tIHJlc2V0VGlja1ZhbHVlcyBmdW5jdGlvbi5cbiAgICAgICAgcG9zID0gcG9zIHx8IHt9O1xuICAgICAgICBvZmZzZXRzID0gb2Zmc2V0cyB8fCB0aGlzLl9vZmZzZXRzO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5fdGlja3M7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICAgICAgdmFyIG1pbiA9IHRoaXMubWluO1xuICAgICAgICB2YXIgb2ZmbWF4ID0gb2Zmc2V0cy5tYXg7XG4gICAgICAgIHZhciBvZmZtaW4gPSBvZmZzZXRzLm1pbjtcbiAgICAgICAgdmFyIGxzaG93ID0gKHRoaXMuX2xhYmVsID09IG51bGwpID8gZmFsc2UgOiB0aGlzLl9sYWJlbC5zaG93O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgcCBpbiBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHAsIHBvc1twXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBvZmZzZXRzO1xuICAgICAgICAvLyBwaXhlbGxlbmd0aCB3aWxsIGJlICsgZm9yIHggYXhlcyBhbmQgLSBmb3IgeSBheGVzIGJlY2FzdWUgcGl4ZWxzIGFsd2F5cyBtZWFzdXJlZCBmcm9tIHRvcCBsZWZ0LlxuICAgICAgICB2YXIgcGl4ZWxsZW5ndGggPSBvZmZtYXggLSBvZmZtaW47XG4gICAgICAgIHZhciB1bml0bGVuZ3RoID0gbWF4IC0gbWluO1xuICAgICAgICBcbiAgICAgICAgLy8gcG9pbnQgdG8gdW5pdCBhbmQgdW5pdCB0byBwb2ludCBjb252ZXJzaW9ucyByZWZlcmVuY2VzIHRvIFBsb3QgRE9NIGVsZW1lbnQgdG9wIGxlZnQgY29ybmVyLlxuICAgICAgICBpZiAodGhpcy5icmVha1BvaW50cykge1xuICAgICAgICAgICAgdW5pdGxlbmd0aCA9IHVuaXRsZW5ndGggLSB0aGlzLmJyZWFrUG9pbnRzWzFdICsgdGhpcy5icmVha1BvaW50c1swXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wMnUgPSBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHAgLSBvZmZtaW4pICogdW5pdGxlbmd0aCAvIHBpeGVsbGVuZ3RoICsgbWluO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnUycCA9IGZ1bmN0aW9uKHUpe1xuICAgICAgICAgICAgICAgIGlmICh1ID4gdGhpcy5icmVha1BvaW50c1swXSAmJiB1IDwgdGhpcy5icmVha1BvaW50c1sxXSl7XG4gICAgICAgICAgICAgICAgICAgIHUgPSB0aGlzLmJyZWFrUG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodSA8PSB0aGlzLmJyZWFrUG9pbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodSAtIG1pbikgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGggKyBvZmZtaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHUgLSB0aGlzLmJyZWFrUG9pbnRzWzFdICsgdGhpcy5icmVha1BvaW50c1swXSAtIG1pbikgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGggKyBvZmZtaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUuY2hhckF0KDApID09ICd4Jyl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNfdTJwID0gZnVuY3Rpb24odSl7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID4gdGhpcy5icmVha1BvaW50c1swXSAmJiB1IDwgdGhpcy5icmVha1BvaW50c1sxXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gdGhpcy5icmVha1BvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodSA8PSB0aGlzLmJyZWFrUG9pbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHUgLSBtaW4pICogcGl4ZWxsZW5ndGggLyB1bml0bGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh1IC0gdGhpcy5icmVha1BvaW50c1sxXSArIHRoaXMuYnJlYWtQb2ludHNbMF0gLSBtaW4pICogcGl4ZWxsZW5ndGggLyB1bml0bGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc19wMnUgPSBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgKiB1bml0bGVuZ3RoIC8gcGl4ZWxsZW5ndGggKyBtaW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc191MnAgPSBmdW5jdGlvbih1KXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPiB0aGlzLmJyZWFrUG9pbnRzWzBdICYmIHUgPCB0aGlzLmJyZWFrUG9pbnRzWzFdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB0aGlzLmJyZWFrUG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID49IHRoaXMuYnJlYWtQb2ludHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodSAtIG1heCkgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHUgKyB0aGlzLmJyZWFrUG9pbnRzWzFdIC0gdGhpcy5icmVha1BvaW50c1swXSAtIG1heCkgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzX3AydSA9IGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcCAqIHVuaXRsZW5ndGggLyBwaXhlbGxlbmd0aCArIG1heDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wMnUgPSBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHAgLSBvZmZtaW4pICogdW5pdGxlbmd0aCAvIHBpeGVsbGVuZ3RoICsgbWluO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnUycCA9IGZ1bmN0aW9uKHUpe1xuICAgICAgICAgICAgICAgIHJldHVybiAodSAtIG1pbikgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGggKyBvZmZtaW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSAneGF4aXMnIHx8IHRoaXMubmFtZSA9PSAneDJheGlzJyl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpZXNfdTJwID0gZnVuY3Rpb24odSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodSAtIG1pbikgKiBwaXhlbGxlbmd0aCAvIHVuaXRsZW5ndGg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc19wMnUgPSBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgKiB1bml0bGVuZ3RoIC8gcGl4ZWxsZW5ndGggKyBtaW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllc191MnAgPSBmdW5jdGlvbih1KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh1IC0gbWF4KSAqIHBpeGVsbGVuZ3RoIC8gdW5pdGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzX3AydSA9IGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcCAqIHVuaXRsZW5ndGggLyBwaXhlbGxlbmd0aCArIG1heDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09ICd4YXhpcycgfHwgdGhpcy5uYW1lID09ICd4MmF4aXMnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGlja3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3cgJiYgdC5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGltO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5jb25zdHJ1Y3RvciA9PSAkLmpxcGxvdC5DYW52YXNBeGlzVGlja1JlbmRlcmVyICYmIHQuYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gYWRqdXN0IGF1dG8gcG9zaXRpb25pbmcgYmFzZWQgb24gd2hpY2ggYXhpcyB0aGlzIGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gKHRoaXMubmFtZSA9PSAneGF4aXMnKSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQubGFiZWxQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIGF0IGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAgKiB0LmFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaW0gPSAtdC5nZXRXaWR0aCgpICsgdC5fdGV4dFJlbmRlcmVyLmhlaWdodCAqIE1hdGguc2luKC10Ll90ZXh0UmVuZGVyZXIuYW5nbGUpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIGF0IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuX3RleHRSZW5kZXJlci5oZWlnaHQgKiBNYXRoLnNpbih0Ll90ZXh0UmVuZGVyZXIuYW5nbGUpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpbSA9IC10LmdldFdpZHRoKCkgKyB0Ll90ZXh0UmVuZGVyZXIuaGVpZ2h0ICogTWF0aC5zaW4oLXQuX3RleHRSZW5kZXJlci5hbmdsZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaW0gPSAtdC5fdGV4dFJlbmRlcmVyLmhlaWdodCAqIE1hdGguc2luKHQuX3RleHRSZW5kZXJlci5hbmdsZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuZ2V0V2lkdGgoKS8yICsgdC5fdGV4dFJlbmRlcmVyLmhlaWdodCAqIE1hdGguc2luKC10Ll90ZXh0UmVuZGVyZXIuYW5nbGUpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpbSA9IC10LmdldFdpZHRoKCkvMiArIHQuX3RleHRSZW5kZXJlci5oZWlnaHQgKiBNYXRoLnNpbigtdC5fdGV4dFJlbmRlcmVyLmFuZ2xlKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuZ2V0V2lkdGgoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudTJwKHQudmFsdWUpICsgc2hpbSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0Ll9lbGVtLmNzcygnbGVmdCcsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobHNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB0aGlzLl9sYWJlbC5fZWxlbS5vdXRlcldpZHRoKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5fZWxlbS5jc3MoJ2xlZnQnLCBvZmZtaW4gKyBwaXhlbGxlbmd0aC8yIC0gdy8yICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gJ3hheGlzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuX2VsZW0uY3NzKCdib3R0b20nLCAnMHB4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5fZWxlbS5jc3MoJ3RvcCcsICcwcHgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5wYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGlja3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnNob3cgJiYgdC5zaG93TGFiZWwpIHsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGltO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuQ2FudmFzQXhpc1RpY2tSZW5kZXJlciAmJiB0LmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBuZWVkIHRvIGFkanVzdCBhdXRvIHBvc2l0aW9uaW5nIGJhc2VkIG9uIHdoaWNoIGF4aXMgdGhpcyBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9ICh0aGlzLm5hbWUgPT0gJ3lheGlzJykgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LmxhYmVsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBhdCBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wICogdC5hbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuX3RleHRSZW5kZXJlci5oZWlnaHQgKiBNYXRoLmNvcygtdC5fdGV4dFJlbmRlcmVyLmFuZ2xlKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuZ2V0SGVpZ2h0KCkgKyB0Ll90ZXh0UmVuZGVyZXIuaGVpZ2h0ICogTWF0aC5jb3ModC5fdGV4dFJlbmRlcmVyLmFuZ2xlKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuYW5nbGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpbSA9IC10Ll90ZXh0UmVuZGVyZXIuaGVpZ2h0ICogTWF0aC5jb3MoLXQuX3RleHRSZW5kZXJlci5hbmdsZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpbSA9IC10LmdldEhlaWdodCgpICsgdC5fdGV4dFJlbmRlcmVyLmhlaWdodCAqIE1hdGguY29zKHQuX3RleHRSZW5kZXJlci5hbmdsZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodC5hbmdsZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBzaGltID0gLXQuZ2V0SGVpZ2h0KCkvMiArIHQuX3RleHRSZW5kZXJlci5oZWlnaHQgKiBNYXRoLnNpbigtdC5fdGV4dFJlbmRlcmVyLmFuZ2xlKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBzaGltID0gLXQuZ2V0SGVpZ2h0KCkvMiAtIHQuX3RleHRSZW5kZXJlci5oZWlnaHQgKiBNYXRoLnNpbih0Ll90ZXh0UmVuZGVyZXIuYW5nbGUpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaW0gPSAtdC5nZXRIZWlnaHQoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGltID0gLXQuZ2V0SGVpZ2h0KCkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaW0gPSAtdC5nZXRIZWlnaHQoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy51MnAodC52YWx1ZSkgKyBzaGltICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuX2VsZW0uY3NzKCd0b3AnLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5wYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxzaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy5fbGFiZWwuX2VsZW0ub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLl9lbGVtLmNzcygndG9wJywgb2ZmbWF4IC0gcGl4ZWxsZW5ndGgvMiAtIGgvMiArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lID09ICd5YXhpcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLl9lbGVtLmNzcygnbGVmdCcsICcwcHgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLl9lbGVtLmNzcygncmlnaHQnLCAnMHB4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwucGFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRpY2tzID0gbnVsbDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB3YXMgZ2VuZXJhb3VzbHkgZ2l2ZW4gdG8gbWUgYSB3aGlsZSBiYWNrIGJ5IFNjb3R0IFByYWhsLlxuICAgICogSGUgZGlkIGEgZ29vZCBqb2IgYXQgY29tcHV0aW5nIGF4ZXMgbWluLCBtYXggYW5kIG51bWJlciBvZiB0aWNrcyBmb3IgdGhlIFxuICAgICogY2FzZSB3aGVyZSB0aGUgdXNlciBoYXMgbm90IHNldCBhbnkgc2NhbGUgcmVsYXRlZCBwYXJhbWV0ZXJzICh0aWNrSW50ZXJ2YWwsXG4gICAgKiBudW1iZXJUaWNrcywgbWluIG9yIG1heCkuICBJIGhhZCBpZ25vcmVkIHRoaXMgdXNlIGNhc2UgZm9yIGEgbG9uZyB0aW1lLFxuICAgICogZm9jdXNpbmcgb24gdGhlIG1vcmUgZGlmZmljdWx0IGNhc2Ugd2hlcmUgdXNlciBoYXMgc2V0IHNvbWUgb3B0aW9uIGNvbnRyb2xsaW5nXG4gICAgKiB0aWNrIGdlbmVyYXRpb24uICBBbnl3YXksIGFib3V0IHRpbWUgSSBnb3QgdGhpcyBpbnRvIGpxUGxvdC5cbiAgICAqIFRoYW5rcyBTY290dCEhXG4gICAgKi9cbiAgICBcbiAgICAvKipcbiAgICAqIENvcHlyaWdodCAoYykgMjAxMCBTY290dCBQcmFobFxuICAgICogVGhlIG5leHQgdGhyZWUgcm91dGluZXMgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUgZm9yIHVzZSBpbiBhbGwgcGVyc29uYWwgXG4gICAgKiBvciBjb21tZXJjaWFsIHByb2plY3RzIHVuZGVyIGJvdGggdGhlIE1JVCBhbmQgR1BMIHZlcnNpb24gMi4wIGxpY2Vuc2VzLiBcbiAgICAqIFRoaXMgbWVhbnMgdGhhdCB5b3UgY2FuIGNob29zZSB0aGUgbGljZW5zZSB0aGF0IGJlc3Qgc3VpdHMgeW91ciBwcm9qZWN0IFxuICAgICogYW5kIHVzZSBpdCBhY2NvcmRpbmdseS4gXG4gICAgKi9cblxuICAgIC8vIEEgZ29vZCBmb3JtYXQgc3RyaW5nIGRlcGVuZHMgb24gdGhlIGludGVydmFsLiBJZiB0aGUgaW50ZXJ2YWwgaXMgZ3JlYXRlciBcbiAgICAvLyB0aGFuIDEgdGhlbiB0aGVyZSBpcyBubyBuZWVkIHRvIHNob3cgYW55IGRlY2ltYWwgZGlnaXRzLiBJZiBpdCBpcyA8IDEuMCwgdGhlblxuICAgIC8vIHVzZSB0aGUgbWFnbml0dWRlIG9mIHRoZSBpbnRlcnZhbCB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBvZiBkaWdpdHMgdG8gc2hvdy5cbiAgICBmdW5jdGlvbiBiZXN0Rm9ybWF0U3RyaW5nIChpbnRlcnZhbClcbiAgICB7XG4gICAgICAgIHZhciBmc3RyO1xuICAgICAgICBpbnRlcnZhbCA9IE1hdGguYWJzKGludGVydmFsKTtcbiAgICAgICAgaWYgKGludGVydmFsID49IDEwKSB7XG4gICAgICAgICAgICBmc3RyID0gJyVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGludGVydmFsID4gMSkge1xuICAgICAgICAgICAgaWYgKGludGVydmFsID09PSBwYXJzZUludChpbnRlcnZhbCwgMTApKSB7XG4gICAgICAgICAgICAgICAgZnN0ciA9ICclZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc3RyID0gJyUuMWYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXhwdiA9IC1NYXRoLmZsb29yKE1hdGgubG9nKGludGVydmFsKS9NYXRoLkxOMTApO1xuICAgICAgICAgICAgZnN0ciA9ICclLicgKyBleHB2ICsgJ2YnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZnN0cjsgXG4gICAgfVxuXG4gICAgdmFyIF9mYWN0b3JzID0gWzAuMSwgMC4yLCAwLjMsIDAuNCwgMC41LCAwLjgsIDEsIDIsIDMsIDQsIDVdO1xuXG4gICAgdmFyIF9nZXRMb3dlckZhY3RvciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIGkgPSBfZmFjdG9ycy5pbmRleE9mKGYpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfZmFjdG9yc1tpLTFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9mYWN0b3JzW19mYWN0b3JzLmxlbmd0aCAtIDFdIC8gMTAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfZ2V0SGlnaGVyRmFjdG9yID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgaSA9IF9mYWN0b3JzLmluZGV4T2YoZik7XG4gICAgICAgIGlmIChpIDwgX2ZhY3RvcnMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmFjdG9yc1tpKzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9mYWN0b3JzWzBdICogMTAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEdpdmVuIGEgZml4ZWQgbWluaW11bSBhbmQgbWF4aW11bSBhbmQgYSB0YXJnZXQgbnVtYmVyIG90IHRpY2tzXG4gICAgLy8gZmlndXJlIG91dCB0aGUgYmVzdCBpbnRlcnZhbCBhbmQgXG4gICAgLy8gcmV0dXJuIG1pbiwgbWF4LCBudW1iZXIgdGlja3MsIGZvcm1hdCBzdHJpbmcgYW5kIHRpY2sgaW50ZXJ2YWxcbiAgICBmdW5jdGlvbiBiZXN0Q29uc3RyYWluZWRJbnRlcnZhbChtaW4sIG1heCwgbnR0YXJnZXQpIHtcbiAgICAgICAgLy8gcnVuIHRocm91Z2ggcG9zc2libGUgbnVtYmVyIHRvIHRpY2tzIGFuZCBzZWUgd2hpY2ggaW50ZXJ2YWwgaXMgYmVzdFxuICAgICAgICB2YXIgbG93ID0gTWF0aC5mbG9vcihudHRhcmdldC8yKTtcbiAgICAgICAgdmFyIGhpID0gTWF0aC5jZWlsKG50dGFyZ2V0KjEuNSk7XG4gICAgICAgIHZhciBiYWRuZXNzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIHIgPSAobWF4IC0gbWluKTtcbiAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgIHZhciBzZDtcbiAgICAgICAgdmFyIGJlc3ROVDtcbiAgICAgICAgdmFyIGdzZiA9ICQuanFwbG90LmdldFNpZ25pZmljYW50RmlndXJlcztcbiAgICAgICAgdmFyIGZzZDtcbiAgICAgICAgdmFyIGZzO1xuICAgICAgICB2YXIgY3VycmVudE5UO1xuICAgICAgICB2YXIgYmVzdFByZWM7XG5cbiAgICAgICAgZm9yICh2YXIgaT0wLCBsPWhpLWxvdysxOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudE5UID0gbG93ICsgaTtcbiAgICAgICAgICAgIHRlbXAgPSByLyhjdXJyZW50TlQtMSk7XG4gICAgICAgICAgICBzZCA9IGdzZih0ZW1wKTtcblxuICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKG50dGFyZ2V0IC0gY3VycmVudE5UKSArIHNkLmRpZ2l0c1JpZ2h0O1xuICAgICAgICAgICAgaWYgKHRlbXAgPCBiYWRuZXNzKSB7XG4gICAgICAgICAgICAgICAgYmFkbmVzcyA9IHRlbXA7XG4gICAgICAgICAgICAgICAgYmVzdE5UID0gY3VycmVudE5UO1xuICAgICAgICAgICAgICAgIGJlc3RQcmVjID0gc2QuZGlnaXRzUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZW1wID09PSBiYWRuZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IG5pY2VyIHRpY2tzIHRydW1wIG51bWJlciBvdCB0aWNrc1xuICAgICAgICAgICAgICAgIGlmIChzZC5kaWdpdHNSaWdodCA8IGJlc3RQcmVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3ROVCA9IGN1cnJlbnROVDtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFByZWMgPSBzZC5kaWdpdHNSaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZzZCA9IE1hdGgubWF4KGJlc3RQcmVjLCBNYXRoLm1heChnc2YobWluKS5kaWdpdHNSaWdodCwgZ3NmKG1heCkuZGlnaXRzUmlnaHQpKTtcbiAgICAgICAgaWYgKGZzZCA9PT0gMCkge1xuICAgICAgICAgICAgZnMgPSAnJWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMgPSAnJS4nICsgZnNkICsgJ2YnO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSByIC8gKGJlc3ROVCAtIDEpO1xuICAgICAgICAvLyBtaW4sIG1heCwgbnVtYmVyIHRpY2tzLCBmb3JtYXQgc3RyaW5nLCB0aWNrIGludGVydmFsXG4gICAgICAgIHJldHVybiBbbWluLCBtYXgsIGJlc3ROVCwgZnMsIHRlbXBdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gYW4gaW50ZXJ2YWwgb2YgZm9ybSAyICogMTBebiwgNSAqIDEwXm4gb3IgMTAgKiAxMF5uXG4gICAgLy8gaXQgaXMgYmFzZWQgc29sZXkgb24gdGhlIHJhbmdlIGFuZCBudW1iZXIgb2YgdGlja3MuICBTbyBpZiB1c2VyIHNwZWNpZmllc1xuICAgIC8vIG51bWJlciBvZiB0aWNrcywgdXNlIHRoaXMuXG4gICAgZnVuY3Rpb24gYmVzdEludGVydmFsKHJhbmdlLCBudW1iZXJUaWNrcykge1xuICAgICAgICBudW1iZXJUaWNrcyA9IG51bWJlclRpY2tzIHx8IDc7XG4gICAgICAgIHZhciBtaW5pbXVtID0gcmFuZ2UgLyAobnVtYmVyVGlja3MgLSAxKTtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKG1pbmltdW0pIC8gTWF0aC5MTjEwKSk7XG4gICAgICAgIHZhciByZXNpZHVhbCA9IG1pbmltdW0gLyBtYWduaXR1ZGU7XG4gICAgICAgIHZhciBpbnRlcnZhbDtcbiAgICAgICAgLy8gXCJuaWNlc3RcIiByYW5nZXMgYXJlIDEsIDIsIDUgb3IgcG93ZXJzIG9mIHRoZXNlLlxuICAgICAgICAvLyBmb3IgbWFnbml0dWRlcyBiZWxvdyAxLCBvbmx5IGFsbG93IHRoZXNlLiBcbiAgICAgICAgaWYgKG1hZ25pdHVkZSA8IDEpIHtcbiAgICAgICAgICAgIGlmIChyZXNpZHVhbCA+IDUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IDEwICogbWFnbml0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzaWR1YWwgPiAyKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSA1ICogbWFnbml0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzaWR1YWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAyICogbWFnbml0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBtYWduaXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGxhcmdlIHJhbmdlcyAod2hvbGUgaW50ZWdlcnMpLCBhbGxvdyBpbnRlcnZhbHMgbGlrZSAzLCA0IG9yIHBvd2VycyBvZiB0aGVzZS5cbiAgICAgICAgLy8gdGhpcyBoZWxwcyBhIGxvdCB3aXRoIHBvb3IgY2hvaWNlcyBmb3IgbnVtYmVyIG9mIHRpY2tzLiBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzaWR1YWwgPiA1KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAxMCAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc2lkdWFsID4gNCkge1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gNSAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc2lkdWFsID4gMykge1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gNCAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc2lkdWFsID4gMikge1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gMyAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc2lkdWFsID4gMSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gMiAqIG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gbWFnbml0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgIH1cblxuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gYW4gaW50ZXJ2YWwgb2YgZm9ybSAyICogMTBebiwgNSAqIDEwXm4gb3IgMTAgKiAxMF5uXG4gICAgLy8gaXQgaXMgYmFzZWQgc29sZXkgb24gdGhlIHJhbmdlIG9mIGRhdGEsIG51bWJlciBvZiB0aWNrcyBtdXN0IGJlIGNvbXB1dGVkIGxhdGVyLlxuICAgIGZ1bmN0aW9uIGJlc3RMaW5lYXJJbnRlcnZhbChyYW5nZSwgc2NhbGVmYWN0KSB7XG4gICAgICAgIHNjYWxlZmFjdCA9IHNjYWxlZmFjdCB8fCAxO1xuICAgICAgICB2YXIgZXhwdiA9IE1hdGguZmxvb3IoTWF0aC5sb2cocmFuZ2UpL01hdGguTE4xMCk7XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgZXhwdik7XG4gICAgICAgIC8vIDAgPCBmIDwgMTBcbiAgICAgICAgdmFyIGYgPSByYW5nZSAvIG1hZ25pdHVkZTtcbiAgICAgICAgdmFyIGZhY3Q7XG4gICAgICAgIC8vIGZvciBsYXJnZSBwbG90cywgc2NhbGVmYWN0IHdpbGwgZGVjcmVhc2UgZiBhbmQgaW5jcmVhc2UgbnVtYmVyIG9mIHRpY2tzLlxuICAgICAgICAvLyBmb3Igc21hbGwgcGxvdHMsIHNjYWxlZmFjdCB3aWxsIGluY3JlYXNlIGYgYW5kIGRlY3JlYXNlIG51bWJlciBvZiB0aWNrcy5cbiAgICAgICAgZiA9IGYvc2NhbGVmYWN0O1xuXG4gICAgICAgIC8vIGZvciBsYXJnZSBwbG90cywgc21hbGxlciBpbnRlcnZhbCwgbW9yZSB0aWNrcy5cbiAgICAgICAgaWYgKGY8PTAuMzgpIHtcbiAgICAgICAgICAgIGZhY3QgPSAwLjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZjw9MS42KSB7XG4gICAgICAgICAgICBmYWN0ID0gMC4yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGY8PTQuMCkge1xuICAgICAgICAgICAgZmFjdCA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmPD04LjApIHtcbiAgICAgICAgICAgIGZhY3QgPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIHZlcnkgc21hbGwgcGxvdHMsIGxhcmdlciBpbnRlcnZhbCwgbGVzcyB0aWNrcyBpbiBudW1iZXIgdGlja3NcbiAgICAgICAgZWxzZSBpZiAoZjw9MTYuMCkge1xuICAgICAgICAgICAgZmFjdCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0ID0gNTtcbiAgICAgICAgfSBcblxuICAgICAgICByZXR1cm4gZmFjdCptYWduaXR1ZGU7IFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJlc3RMaW5lYXJDb21wb25lbnRzKHJhbmdlLCBzY2FsZWZhY3QpIHtcbiAgICAgICAgdmFyIGV4cHYgPSBNYXRoLmZsb29yKE1hdGgubG9nKHJhbmdlKS9NYXRoLkxOMTApO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIGV4cHYpO1xuICAgICAgICAvLyAwIDwgZiA8IDEwXG4gICAgICAgIHZhciBmID0gcmFuZ2UgLyBtYWduaXR1ZGU7XG4gICAgICAgIHZhciBpbnRlcnZhbDtcbiAgICAgICAgdmFyIGZhY3Q7XG4gICAgICAgIC8vIGZvciBsYXJnZSBwbG90cywgc2NhbGVmYWN0IHdpbGwgZGVjcmVhc2UgZiBhbmQgaW5jcmVhc2UgbnVtYmVyIG9mIHRpY2tzLlxuICAgICAgICAvLyBmb3Igc21hbGwgcGxvdHMsIHNjYWxlZmFjdCB3aWxsIGluY3JlYXNlIGYgYW5kIGRlY3JlYXNlIG51bWJlciBvZiB0aWNrcy5cbiAgICAgICAgZiA9IGYvc2NhbGVmYWN0O1xuXG4gICAgICAgIC8vIGZvciBsYXJnZSBwbG90cywgc21hbGxlciBpbnRlcnZhbCwgbW9yZSB0aWNrcy5cbiAgICAgICAgaWYgKGY8PTAuMzgpIHtcbiAgICAgICAgICAgIGZhY3QgPSAwLjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZjw9MS42KSB7XG4gICAgICAgICAgICBmYWN0ID0gMC4yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGY8PTQuMCkge1xuICAgICAgICAgICAgZmFjdCA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmPD04LjApIHtcbiAgICAgICAgICAgIGZhY3QgPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIHZlcnkgc21hbGwgcGxvdHMsIGxhcmdlciBpbnRlcnZhbCwgbGVzcyB0aWNrcyBpbiBudW1iZXIgdGlja3NcbiAgICAgICAgZWxzZSBpZiAoZjw9MTYuMCkge1xuICAgICAgICAgICAgZmFjdCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBpZiAoZjw9MjAuMCkge1xuICAgICAgICAvLyAgICAgZmFjdCA9IDM7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZWxzZSBpZiAoZjw9MjQuMCkge1xuICAgICAgICAvLyAgICAgZmFjdCA9IDQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0ID0gNTtcbiAgICAgICAgfSBcblxuICAgICAgICBpbnRlcnZhbCA9IGZhY3QgKiBtYWduaXR1ZGU7XG5cbiAgICAgICAgcmV0dXJuIFtpbnRlcnZhbCwgZmFjdCwgbWFnbml0dWRlXTtcbiAgICB9XG5cbiAgICAvLyBHaXZlbiB0aGUgbWluIGFuZCBtYXggZm9yIGEgZGF0YXNldCwgcmV0dXJuIHN1aXRhYmxlIGVuZHBvaW50c1xuICAgIC8vIGZvciB0aGUgZ3JhcGhpbmcsIGEgZ29vZCBudW1iZXIgZm9yIHRoZSBudW1iZXIgb2YgdGlja3MsIGFuZCBhXG4gICAgLy8gZm9ybWF0IHN0cmluZyBzbyB0aGF0IGV4dHJhbmVvdXMgZGlnaXRzIGFyZSBub3QgZGlzcGxheWVkLlxuICAgIC8vIHJldHVybmVkIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgW21pbiwgbWF4LCBuVGlja3MsIGZvcm1hdF1cbiAgICAkLmpxcGxvdC5MaW5lYXJUaWNrR2VuZXJhdG9yID0gZnVuY3Rpb24oYXhpc19taW4sIGF4aXNfbWF4LCBzY2FsZWZhY3QsIG51bWJlclRpY2tzLCBrZWVwTWluLCBrZWVwTWF4KSB7XG4gICAgICAgIC8vIFNldCB0byBwcmVzZXJ2ZSBFSVRIRVIgbWluIE9SIG1heC5cbiAgICAgICAgLy8gSWYgbWluIGlzIHByZXNlcnZlZCwgbWF4IG11c3QgYmUgZnJlZS5cbiAgICAgICAga2VlcE1pbiA9IChrZWVwTWluID09PSBudWxsKSA/IGZhbHNlIDoga2VlcE1pbjtcbiAgICAgICAga2VlcE1heCA9IChrZWVwTWF4ID09PSBudWxsIHx8IGtlZXBNaW4pID8gZmFsc2UgOiBrZWVwTWF4O1xuICAgICAgICAvLyBpZiBlbmRwb2ludHMgYXJlIGVxdWFsIHRyeSB0byBpbmNsdWRlIHplcm8gb3RoZXJ3aXNlIGluY2x1ZGUgb25lXG4gICAgICAgIGlmIChheGlzX21pbiA9PT0gYXhpc19tYXgpIHtcbiAgICAgICAgICAgIGF4aXNfbWF4ID0gKGF4aXNfbWF4KSA/IDAgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGVmYWN0ID0gc2NhbGVmYWN0IHx8IDEuMDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgcmFuZ2UgaXMgcG9zaXRpdmVcbiAgICAgICAgaWYgKGF4aXNfbWF4IDwgYXhpc19taW4pIHtcbiAgICAgICAgICAgIHZhciBhID0gYXhpc19tYXg7XG4gICAgICAgICAgICBheGlzX21heCA9IGF4aXNfbWluO1xuICAgICAgICAgICAgYXhpc19taW4gPSBhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgdmFyIHNzID0gYmVzdExpbmVhckludGVydmFsKGF4aXNfbWF4IC0gYXhpc19taW4sIHNjYWxlZmFjdCk7XG5cbiAgICAgICAgdmFyIGdzZiA9ICQuanFwbG90LmdldFNpZ25pZmljYW50RmlndXJlcztcbiAgICAgICAgXG4gICAgICAgIGlmIChudW1iZXJUaWNrcyA9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGF4aXMgbWluLCBtYXggYW5kIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgICAgLy8gdGhlIG1pbiBhbmQgbWF4IHdpbGwgYmUgc29tZSBtdWx0aXBsZSBvZiB0aGUgdGljayBpbnRlcnZhbCxcbiAgICAgICAgICAgIC8vIDEqMTBebiwgMioxMF5uIG9yIDUqMTBebi4gIFRoaXMgZ2F1cmFudGVlcyB0aGF0LCBpZiB0aGVcbiAgICAgICAgICAgIC8vIGF4aXMgbWluIGlzIG5lZ2F0aXZlLCAwIHdpbGwgYmUgYSB0aWNrLlxuICAgICAgICAgICAgaWYgKCFrZWVwTWluICYmICFrZWVwTWF4KSB7XG4gICAgICAgICAgICAgICAgclswXSA9IE1hdGguZmxvb3IoYXhpc19taW4gLyBzcykgKiBzczsgIC8vIG1pblxuICAgICAgICAgICAgICAgIHJbMV0gPSBNYXRoLmNlaWwoYXhpc19tYXggLyBzcykgKiBzczsgICAvLyBtYXhcbiAgICAgICAgICAgICAgICByWzJdID0gTWF0aC5yb3VuZCgoclsxXS1yWzBdKS9zcysxLjApOyAgLy8gbnVtYmVyIG9mIHRpY2tzXG4gICAgICAgICAgICAgICAgclszXSA9IGJlc3RGb3JtYXRTdHJpbmcoc3MpOyAgICAgICAgICAgIC8vIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgICAgICAgICByWzRdID0gc3M7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGljayBJbnRlcnZhbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChrZWVwTWluKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IGF4aXNfbWluOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5cbiAgICAgICAgICAgICAgICByWzJdID0gTWF0aC5jZWlsKChheGlzX21heCAtIGF4aXNfbWluKSAvIHNzICsgMS4wKTsgICAgIC8vIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgICAgICAgIHJbMV0gPSBheGlzX21pbiArIChyWzJdIC0gMSkgKiBzczsgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4XG4gICAgICAgICAgICAgICAgdmFyIGRpZ2l0c01pbiA9IGdzZihheGlzX21pbikuZGlnaXRzUmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpZ2l0c1NTID0gZ3NmKHNzKS5kaWdpdHNSaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXRzTWluIDwgZGlnaXRzU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgclszXSA9IGJlc3RGb3JtYXRTdHJpbmcoc3MpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJbM10gPSAnJS4nICsgZGlnaXRzTWluICsgJ2YnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByWzRdID0gc3M7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpY2sgSW50ZXJ2YWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxzZSBpZiAoa2VlcE1heCkge1xuICAgICAgICAgICAgICAgIHJbMV0gPSBheGlzX21heDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4XG4gICAgICAgICAgICAgICAgclsyXSA9IE1hdGguY2VpbCgoYXhpc19tYXggLSBheGlzX21pbikgLyBzcyArIDEuMCk7ICAgICAvLyBudW1iZXIgb2YgdGlja3NcbiAgICAgICAgICAgICAgICByWzBdID0gYXhpc19tYXggLSAoclsyXSAtIDEpICogc3M7ICAgICAgICAgICAgICAgICAgICAgIC8vIG1pblxuICAgICAgICAgICAgICAgIHZhciBkaWdpdHNNYXggPSBnc2YoYXhpc19tYXgpLmRpZ2l0c1JpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBkaWdpdHNTUyA9IGdzZihzcykuZGlnaXRzUmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0c01heCA8IGRpZ2l0c1NTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJbM10gPSBiZXN0Rm9ybWF0U3RyaW5nKHNzKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXQgc3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByWzNdID0gJyUuJyArIGRpZ2l0c01heCArICdmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcls0XSA9IHNzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aWNrIEludGVydmFsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZW1wciA9IFtdO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBheGlzIG1pbiwgbWF4IGFuZCBudW1iZXIgb2YgdGlja3NcbiAgICAgICAgICAgIC8vIHRoZSBtaW4gYW5kIG1heCB3aWxsIGJlIHNvbWUgbXVsdGlwbGUgb2YgdGhlIHRpY2sgaW50ZXJ2YWwsXG4gICAgICAgICAgICAvLyAxKjEwXm4sIDIqMTBebiBvciA1KjEwXm4uICBUaGlzIGdhdXJhbnRlZXMgdGhhdCwgaWYgdGhlXG4gICAgICAgICAgICAvLyBheGlzIG1pbiBpcyBuZWdhdGl2ZSwgMCB3aWxsIGJlIGEgdGljay5cbiAgICAgICAgICAgIHRlbXByWzBdID0gTWF0aC5mbG9vcihheGlzX21pbiAvIHNzKSAqIHNzOyAgLy8gbWluXG4gICAgICAgICAgICB0ZW1wclsxXSA9IE1hdGguY2VpbChheGlzX21heCAvIHNzKSAqIHNzOyAgIC8vIG1heFxuICAgICAgICAgICAgdGVtcHJbMl0gPSBNYXRoLnJvdW5kKCh0ZW1wclsxXS10ZW1wclswXSkvc3MrMS4wKTsgICAgLy8gbnVtYmVyIG9mIHRpY2tzXG4gICAgICAgICAgICB0ZW1wclszXSA9IGJlc3RGb3JtYXRTdHJpbmcoc3MpOyAgICAgICAgICAgIC8vIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgICAgIHRlbXByWzRdID0gc3M7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGljayBJbnRlcnZhbFxuXG4gICAgICAgICAgICAvLyBmaXJzdCwgc2VlIGlmIHdlIGhhcHBlbiB0byBnZXQgdGhlIHJpZ2h0IG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgICAgaWYgKHRlbXByWzJdID09PSBudW1iZXJUaWNrcykge1xuICAgICAgICAgICAgICAgIHIgPSB0ZW1wcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3dGkgPSBiZXN0SW50ZXJ2YWwodGVtcHJbMV0gLSB0ZW1wclswXSwgbnVtYmVyVGlja3MpO1xuXG4gICAgICAgICAgICAgICAgclswXSA9IHRlbXByWzBdOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pblxuICAgICAgICAgICAgICAgIHJbMl0gPSBudW1iZXJUaWNrczsgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgdGlja3NcbiAgICAgICAgICAgICAgICByWzRdID0gbmV3dGk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGljayBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIHJbM10gPSBiZXN0Rm9ybWF0U3RyaW5nKG5ld3RpKTsgICAgICAgICAvLyBmb3JtYXQgc3RyaW5nXG4gICAgICAgICAgICAgICAgclsxXSA9IHJbMF0gKyAoclsyXSAtIDEpICogcls0XTsgICAgICAgIC8vIG1heFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgICQuanFwbG90LkxpbmVhclRpY2tHZW5lcmF0b3IuYmVzdExpbmVhckludGVydmFsID0gYmVzdExpbmVhckludGVydmFsO1xuICAgICQuanFwbG90LkxpbmVhclRpY2tHZW5lcmF0b3IuYmVzdEludGVydmFsID0gYmVzdEludGVydmFsO1xuICAgICQuanFwbG90LkxpbmVhclRpY2tHZW5lcmF0b3IuYmVzdExpbmVhckNvbXBvbmVudHMgPSBiZXN0TGluZWFyQ29tcG9uZW50cztcbiAgICAkLmpxcGxvdC5MaW5lYXJUaWNrR2VuZXJhdG9yLmJlc3RDb25zdHJhaW5lZEludGVydmFsID0gYmVzdENvbnN0cmFpbmVkSW50ZXJ2YWw7XG5cblxuICAgIC8vIGNsYXNzOiAkLmpxcGxvdC5NYXJrZXJSZW5kZXJlclxuICAgIC8vIFRoZSBkZWZhdWx0IGpxUGxvdCBtYXJrZXIgcmVuZGVyZXIsIHJlbmRlcmluZyB0aGUgcG9pbnRzIG9uIHRoZSBsaW5lLlxuICAgICQuanFwbG90Lk1hcmtlclJlbmRlcmVyID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAgIC8vIEdyb3VwOiBQcm9wZXJ0aWVzXG4gICAgICAgIFxuICAgICAgICAvLyBwcm9wOiBzaG93XG4gICAgICAgIC8vIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIG1hcmtlci5cbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogc3R5bGVcbiAgICAgICAgLy8gT25lIG9mIGRpYW1vbmQsIGNpcmNsZSwgc3F1YXJlLCB4LCBwbHVzLCBkYXNoLCBmaWxsZWREaWFtb25kLCBmaWxsZWRDaXJjbGUsIGZpbGxlZFNxdWFyZVxuICAgICAgICB0aGlzLnN0eWxlID0gJ2ZpbGxlZENpcmNsZSc7XG4gICAgICAgIC8vIHByb3A6IGxpbmVXaWR0aFxuICAgICAgICAvLyBzaXplIG9mIHRoZSBsaW5lIGZvciBub24tZmlsbGVkIG1hcmtlcnMuXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gMjtcbiAgICAgICAgLy8gcHJvcDogc2l6ZVxuICAgICAgICAvLyBTaXplIG9mIHRoZSBtYXJrZXIgKGRpYW1ldGVyIG9yIGNpcmNsZSwgbGVuZ3RoIG9mIGVkZ2Ugb2Ygc3F1YXJlLCBldGMuKVxuICAgICAgICB0aGlzLnNpemUgPSA5LjA7XG4gICAgICAgIC8vIHByb3A6IGNvbG9yXG4gICAgICAgIC8vIGNvbG9yIG9mIG1hcmtlci4gIFdpbGwgYmUgc2V0IHRvIGNvbG9yIG9mIHNlcmllcyBieSBkZWZhdWx0IG9uIGluaXQuXG4gICAgICAgIHRoaXMuY29sb3IgPSAnIzY2NjY2Nic7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBkcmF3IGEgc2hhZG93IG9uIHRoZSBsaW5lXG4gICAgICAgIHRoaXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgLy8gcHJvcDogc2hhZG93QW5nbGVcbiAgICAgICAgLy8gU2hhZG93IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgICAgdGhpcy5zaGFkb3dBbmdsZSA9IDQ1O1xuICAgICAgICAvLyBwcm9wOiBzaGFkb3dPZmZzZXRcbiAgICAgICAgLy8gU2hhZG93IG9mZnNldCBmcm9tIGxpbmUgaW4gcGl4ZWxzXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0ID0gMTtcbiAgICAgICAgLy8gcHJvcDogc2hhZG93RGVwdGhcbiAgICAgICAgLy8gTnVtYmVyIG9mIHRpbWVzIHNoYWRvdyBpcyBzdHJva2VkLCBlYWNoIHN0cm9rZSBvZmZzZXQgc2hhZG93T2Zmc2V0IGZyb20gdGhlIGxhc3QuXG4gICAgICAgIHRoaXMuc2hhZG93RGVwdGggPSAzO1xuICAgICAgICAvLyBwcm9wOiBzaGFkb3dBbHBoYVxuICAgICAgICAvLyBBbHBoYSBjaGFubmVsIHRyYW5zcGFyZW5jeSBvZiBzaGFkb3cuICAwID0gdHJhbnNwYXJlbnQuXG4gICAgICAgIHRoaXMuc2hhZG93QWxwaGEgPSAnMC4wNyc7XG4gICAgICAgIC8vIHByb3A6IHNoYWRvd1JlbmRlcmVyXG4gICAgICAgIC8vIFJlbmRlcmVyIHRoYXQgd2lsbCBkcmF3cyB0aGUgc2hhZG93cyBvbiB0aGUgbWFya2VyLlxuICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyID0gbmV3ICQuanFwbG90LlNoYWRvd1JlbmRlcmVyKCk7XG4gICAgICAgIC8vIHByb3A6IHNoYXBlUmVuZGVyZXJcbiAgICAgICAgLy8gUmVuZGVyZXIgdGhhdCB3aWxsIGRyYXcgdGhlIG1hcmtlci5cbiAgICAgICAgdGhpcy5zaGFwZVJlbmRlcmVyID0gbmV3ICQuanFwbG90LlNoYXBlUmVuZGVyZXIoKTtcbiAgICAgICAgXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gZ2V0U2hhZG93UmVuZGVyZXJPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgdmFyIHNkb3B0ID0ge2FuZ2xlOm9wdHMuc2hhZG93QW5nbGUsIG9mZnNldDpvcHRzLnNoYWRvd09mZnNldCwgYWxwaGE6b3B0cy5zaGFkb3dBbHBoYSwgbGluZVdpZHRoOm9wdHMubGluZVdpZHRoLCBkZXB0aDpvcHRzLnNoYWRvd0RlcHRoLCBjbG9zZVBhdGg6dHJ1ZX07XG4gICAgICAgIGlmIChvcHRzLnN0eWxlLmluZGV4T2YoJ2ZpbGxlZCcpICE9IC0xKSB7XG4gICAgICAgICAgICBzZG9wdC5maWxsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5zdHlsZS5pbmRleE9mKCdpcmNsZScpICE9IC0xKSB7XG4gICAgICAgICAgICBzZG9wdC5pc2FyYyA9IHRydWU7XG4gICAgICAgICAgICBzZG9wdC5jbG9zZVBhdGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIHNkb3B0KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZ2V0U2hhcGVSZW5kZXJlck9wdGlvbnMob3B0cykge1xuICAgICAgICB2YXIgc2hvcHQgPSB7ZmlsbDpmYWxzZSwgaXNhcmM6ZmFsc2UsIHN0cm9rZVN0eWxlOm9wdHMuY29sb3IsIGZpbGxTdHlsZTpvcHRzLmNvbG9yLCBsaW5lV2lkdGg6b3B0cy5saW5lV2lkdGgsIGNsb3NlUGF0aDp0cnVlfTtcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUuaW5kZXhPZignZmlsbGVkJykgIT0gLTEpIHtcbiAgICAgICAgICAgIHNob3B0LmZpbGwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnN0eWxlLmluZGV4T2YoJ2lyY2xlJykgIT0gLTEpIHtcbiAgICAgICAgICAgIHNob3B0LmlzYXJjID0gdHJ1ZTtcbiAgICAgICAgICAgIHNob3B0LmNsb3NlUGF0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgc2hvcHQpO1xuICAgIH1cbiAgICBcbiAgICAkLmpxcGxvdC5NYXJrZXJSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5NYXJrZXJSZW5kZXJlci5wcm90b3R5cGUuZHJhd0RpYW1vbmQgPSBmdW5jdGlvbih4LCB5LCBjdHgsIGZpbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgfHwgJC5pc0VtcHR5T2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRzID0gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmV0Y2ggPSAxLjI7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuc2l6ZS8yL3N0cmV0Y2g7XG4gICAgICAgIHZhciBkeSA9IHRoaXMuc2l6ZS8yKnN0cmV0Y2g7XG4gICAgICAgIHZhciBwb2ludHMgPSBbW3gtZHgsIHldLCBbeCwgeStkeV0sIFt4K2R4LCB5XSwgW3gsIHktZHldXTtcbiAgICAgICAgaWYgKG9wdHMuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMsIGdldFNoYWRvd1JlbmRlcmVyT3B0aW9ucyhvcHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZVJlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMsIGdldFNoYXBlUmVuZGVyZXJPcHRpb25zKG9wdHMpKTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90Lk1hcmtlclJlbmRlcmVyLnByb3RvdHlwZS5kcmF3UGx1cyA9IGZ1bmN0aW9uKHgsIHksIGN0eCwgZmlsbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLCBvcHRpb25zLCB7Y2xvc2VQYXRoOmZhbHNlfSk7XG4gICAgICAgIHZhciBzdHJldGNoID0gMS4wO1xuICAgICAgICB2YXIgZHggPSBvcHRzLnNpemUvMipzdHJldGNoO1xuICAgICAgICB2YXIgZHkgPSBvcHRzLnNpemUvMipzdHJldGNoO1xuICAgICAgICB2YXIgcG9pbnRzMSA9IFtbeCwgeS1keV0sIFt4LCB5K2R5XV07XG4gICAgICAgIHZhciBwb2ludHMyID0gW1t4K2R4LCB5XSwgW3gtZHgsIHldXTtcbiAgICAgICAgaWYgKG9wdHMuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMxLCBnZXRTaGFkb3dSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzMiwgZ2V0U2hhZG93UmVuZGVyZXJPcHRpb25zKG9wdHMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50czEsIG9wdHMpO1xuICAgICAgICB0aGlzLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50czIsIG9wdHMpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuTWFya2VyUmVuZGVyZXIucHJvdG90eXBlLmRyYXdYID0gZnVuY3Rpb24oeCwgeSwgY3R4LCBmaWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMsIG9wdGlvbnMsIHtjbG9zZVBhdGg6ZmFsc2V9KTtcbiAgICAgICAgdmFyIHN0cmV0Y2ggPSAxLjA7XG4gICAgICAgIHZhciBkeCA9IG9wdHMuc2l6ZS8yKnN0cmV0Y2g7XG4gICAgICAgIHZhciBkeSA9IG9wdHMuc2l6ZS8yKnN0cmV0Y2g7XG4gICAgICAgIHZhciBwb2ludHMxID0gW1t4LWR4LCB5LWR5XSwgW3grZHgsIHkrZHldXTtcbiAgICAgICAgdmFyIHBvaW50czIgPSBbW3gtZHgsIHkrZHldLCBbeCtkeCwgeS1keV1dO1xuICAgICAgICBpZiAob3B0cy5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93UmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50czEsIGdldFNoYWRvd1JlbmRlcmVyT3B0aW9ucyhvcHRzKSk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMyLCBnZXRTaGFkb3dSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGVSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzMSwgZ2V0U2hhcGVSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgICAgICB0aGlzLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50czIsIGdldFNoYXBlUmVuZGVyZXJPcHRpb25zKG9wdHMpKTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90Lk1hcmtlclJlbmRlcmVyLnByb3RvdHlwZS5kcmF3RGFzaCA9IGZ1bmN0aW9uKHgsIHksIGN0eCwgZmlsbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCAkLmlzRW1wdHlPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdHMgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZXRjaCA9IDEuMDtcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5zaXplLzIqc3RyZXRjaDtcbiAgICAgICAgdmFyIGR5ID0gdGhpcy5zaXplLzIqc3RyZXRjaDtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtbeC1keCwgeV0sIFt4K2R4LCB5XV07XG4gICAgICAgIGlmIChvcHRzLnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50cywgZ2V0U2hhcGVSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuTWFya2VyUmVuZGVyZXIucHJvdG90eXBlLmRyYXdMaW5lID0gZnVuY3Rpb24ocDEsIHAyLCBjdHgsIGZpbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgfHwgJC5pc0VtcHR5T2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRzID0gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50cyA9IFtwMSwgcDJdO1xuICAgICAgICBpZiAob3B0cy5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93UmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50cywgZ2V0U2hhZG93UmVuZGVyZXJPcHRpb25zKG9wdHMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlUmVuZGVyZXIuZHJhdyhjdHgsIHBvaW50cywgZ2V0U2hhcGVSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuTWFya2VyUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTcXVhcmUgPSBmdW5jdGlvbih4LCB5LCBjdHgsIGZpbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgfHwgJC5pc0VtcHR5T2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRzID0gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmV0Y2ggPSAxLjA7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuc2l6ZS8yL3N0cmV0Y2g7XG4gICAgICAgIHZhciBkeSA9IHRoaXMuc2l6ZS8yKnN0cmV0Y2g7XG4gICAgICAgIHZhciBwb2ludHMgPSBbW3gtZHgsIHktZHldLCBbeC1keCwgeStkeV0sIFt4K2R4LCB5K2R5XSwgW3grZHgsIHktZHldXTtcbiAgICAgICAgaWYgKG9wdHMuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1JlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMsIGdldFNoYWRvd1JlbmRlcmVyT3B0aW9ucyhvcHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZVJlbmRlcmVyLmRyYXcoY3R4LCBwb2ludHMsIGdldFNoYXBlUmVuZGVyZXJPcHRpb25zKG9wdHMpKTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90Lk1hcmtlclJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgY3R4LCBmaWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8ICQuaXNFbXB0eU9iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0cyA9IHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLnNpemUvMjtcbiAgICAgICAgdmFyIGVuZCA9IDIqTWF0aC5QSTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFt4LCB5LCByYWRpdXMsIDAsIGVuZCwgdHJ1ZV07XG4gICAgICAgIGlmIChvcHRzLnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzLCBnZXRTaGFkb3dSZW5kZXJlck9wdGlvbnMob3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGVSZW5kZXJlci5kcmF3KGN0eCwgcG9pbnRzLCBnZXRTaGFwZVJlbmRlcmVyT3B0aW9ucyhvcHRzKSk7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5NYXJrZXJSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHgsIHksIGN0eCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gaGFjayBoZXJlIGIvYyBzaGFwZSByZW5kZXJlciB1c2VzIGNhbnZhcyBiYXNlZCBjb2xvciBzdHlsZSBvcHRpb25zXG4gICAgICAgIC8vIGFuZCBtYXJrZXIgdXNlcyBjc3Mgc3R5bGUgbmFtZXMuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3cgPT0gbnVsbCB8fCBvcHRpb25zLnNob3cgIT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbG9yICYmICFvcHRpb25zLmZpbGxTdHlsZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsbFN0eWxlID0gb3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbG9yICYmICFvcHRpb25zLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlIHx8IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlhbW9uZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0RpYW1vbmQoeCx5LGN0eCwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsZWREaWFtb25kJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3RGlhbW9uZCh4LHksY3R4LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKHgseSxjdHgsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbGVkQ2lyY2xlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKHgseSxjdHgsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCx5LGN0eCwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsZWRTcXVhcmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCx5LGN0eCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdYKHgseSxjdHgsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwbHVzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UGx1cyh4LHksY3R4LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGFzaCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Rhc2goeCx5LGN0eCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKHgsIHksIGN0eCwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdEaWFtb25kKHgseSxjdHgsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuXG4gICAgLy8gY2xhc3M6ICQuanFwbG90LnNoYWRvd1JlbmRlcmVyXG4gICAgLy8gVGhlIGRlZmF1bHQganFQbG90IHNoYWRvdyByZW5kZXJlciwgcmVuZGVyaW5nIHNoYWRvd3MgYmVoaW5kIHNoYXBlcy5cbiAgICAkLmpxcGxvdC5TaGFkb3dSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpeyBcbiAgICAgICAgLy8gR3JvdXA6IFByb3BlcnRpZXNcbiAgICAgICAgXG4gICAgICAgIC8vIHByb3A6IGFuZ2xlXG4gICAgICAgIC8vIEFuZ2xlIG9mIHRoZSBzaGFkb3cgaW4gZGVncmVlcy4gIE1lYXN1cmVkIGNvdW50ZXItY2xvY2t3aXNlIGZyb20gdGhlIHggYXhpcy5cbiAgICAgICAgdGhpcy5hbmdsZSA9IDQ1O1xuICAgICAgICAvLyBwcm9wOiBvZmZzZXRcbiAgICAgICAgLy8gUGl4ZWwgb2Zmc2V0IGF0IHRoZSBnaXZlbiBzaGFkb3cgYW5nbGUgb2YgZWFjaCBzaGFkb3cgc3Ryb2tlIGZyb20gdGhlIGxhc3Qgc3Ryb2tlLlxuICAgICAgICB0aGlzLm9mZnNldCA9IDE7XG4gICAgICAgIC8vIHByb3A6IGFscGhhXG4gICAgICAgIC8vIGFscGhhIHRyYW5zcGFyZW5jeSBvZiBzaGFkb3cgc3Ryb2tlLlxuICAgICAgICB0aGlzLmFscGhhID0gMC4wNztcbiAgICAgICAgLy8gcHJvcDogbGluZVdpZHRoXG4gICAgICAgIC8vIHdpZHRoIG9mIHRoZSBzaGFkb3cgbGluZSBzdHJva2UuXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gMS41O1xuICAgICAgICAvLyBwcm9wOiBsaW5lSm9pblxuICAgICAgICAvLyBIb3cgbGluZSBzZWdtZW50cyBvZiB0aGUgc2hhZG93IGFyZSBqb2luZWQuXG4gICAgICAgIHRoaXMubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgICAvLyBwcm9wOiBsaW5lQ2FwXG4gICAgICAgIC8vIGhvdyBlbmRzIG9mIHRoZSBzaGFkb3cgbGluZSBhcmUgcmVuZGVyZWQuXG4gICAgICAgIHRoaXMubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICAgIC8vIHByb3A7IGNsb3NlUGF0aFxuICAgICAgICAvLyB3aGV0aGVyIGxpbmUgcGF0aCBzZWdtZW50IGlzIGNsb3NlZCB1cG9uIGl0c2VsZi5cbiAgICAgICAgdGhpcy5jbG9zZVBhdGggPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogZmlsbFxuICAgICAgICAvLyB3aGV0aGVyIHRvIGZpbGwgdGhlIHNoYXBlLlxuICAgICAgICB0aGlzLmZpbGwgPSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcDogZGVwdGhcbiAgICAgICAgLy8gaG93IG1hbnkgdGltZXMgdGhlIHNoYWRvdyBpcyBzdHJva2VkLiAgRWFjaCBzdHJva2Ugd2lsbCBiZSBvZmZzZXQgYnkgb2Zmc2V0IGF0IGFuZ2xlIGRlZ3JlZXMuXG4gICAgICAgIHRoaXMuZGVwdGggPSAzO1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgICAgIC8vIHByb3A6IGlzYXJjXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlIHNoYWRvdyBpcyBhbiBhcmMgb3Igbm90LlxuICAgICAgICB0aGlzLmlzYXJjID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LlNoYWRvd1JlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIGZ1bmN0aW9uOiBkcmF3XG4gICAgLy8gZHJhd3MgYW4gdHJhbnNwYXJlbnQgYmxhY2sgKGkuZS4gZ3JheSkgc2hhZG93LlxuICAgIC8vXG4gICAgLy8gY3R4IC0gY2FudmFzIGRyYXdpbmcgY29udGV4dFxuICAgIC8vIHBvaW50cyAtIGFycmF5IG9mIHBvaW50cyBvciBbeCwgeSwgcmFkaXVzLCBzdGFydCBhbmdsZSAocmFkKSwgZW5kIGFuZ2xlIChyYWQpXVxuICAgICQuanFwbG90LlNoYWRvd1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmFyIG9wdHMgPSAob3B0aW9ucyAhPSBudWxsKSA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgdmFyIGZpbGwgPSAob3B0cy5maWxsICE9IG51bGwpID8gb3B0cy5maWxsIDogdGhpcy5maWxsO1xuICAgICAgICB2YXIgZmlsbFJlY3QgPSAob3B0cy5maWxsUmVjdCAhPSBudWxsKSA/IG9wdHMuZmlsbFJlY3QgOiB0aGlzLmZpbGxSZWN0O1xuICAgICAgICB2YXIgY2xvc2VQYXRoID0gKG9wdHMuY2xvc2VQYXRoICE9IG51bGwpID8gb3B0cy5jbG9zZVBhdGggOiB0aGlzLmNsb3NlUGF0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IChvcHRzLm9mZnNldCAhPSBudWxsKSA/IG9wdHMub2Zmc2V0IDogdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBhbHBoYSA9IChvcHRzLmFscGhhICE9IG51bGwpID8gb3B0cy5hbHBoYSA6IHRoaXMuYWxwaGE7XG4gICAgICAgIHZhciBkZXB0aCA9IChvcHRzLmRlcHRoICE9IG51bGwpID8gb3B0cy5kZXB0aCA6IHRoaXMuZGVwdGg7XG4gICAgICAgIHZhciBpc2FyYyA9IChvcHRzLmlzYXJjICE9IG51bGwpID8gb3B0cy5pc2FyYyA6IHRoaXMuaXNhcmM7XG4gICAgICAgIHZhciBsaW5lUGF0dGVybiA9IChvcHRzLmxpbmVQYXR0ZXJuICE9IG51bGwpID8gb3B0cy5saW5lUGF0dGVybiA6IHRoaXMubGluZVBhdHRlcm47XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAob3B0cy5saW5lV2lkdGggIT0gbnVsbCkgPyBvcHRzLmxpbmVXaWR0aCA6IHRoaXMubGluZVdpZHRoO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAob3B0cy5saW5lSm9pbiAhPSBudWxsKSA/IG9wdHMubGluZUpvaW4gOiB0aGlzLmxpbmVKb2luO1xuICAgICAgICBjdHgubGluZUNhcCA9IChvcHRzLmxpbmVDYXAgIT0gbnVsbCkgPyBvcHRzLmxpbmVDYXAgOiB0aGlzLmxpbmVDYXA7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlU3R5bGUgfHwgdGhpcy5zdHJva2VTdHlsZSB8fCAncmdiYSgwLDAsMCwnK2FscGhhKycpJztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuZmlsbFN0eWxlIHx8IHRoaXMuZmlsbFN0eWxlIHx8ICdyZ2JhKDAsMCwwLCcrYWxwaGErJyknO1xuICAgICAgICBmb3IgKHZhciBqPTA7IGo8ZGVwdGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGN0eFBhdHRlcm4gPSAkLmpxcGxvdC5MaW5lUGF0dGVybihjdHgsIGxpbmVQYXR0ZXJuKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3ModGhpcy5hbmdsZSpNYXRoLlBJLzE4MCkqb2Zmc2V0LCBNYXRoLnNpbih0aGlzLmFuZ2xlKk1hdGguUEkvMTgwKSpvZmZzZXQpO1xuICAgICAgICAgICAgY3R4UGF0dGVybi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChpc2FyYykge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHRydWUpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbGxSZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGxSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRvIHRoZSBmaXJzdCBub24tbnVsbCBwb2ludCBhbmQgbW92ZSB0byBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXVswXSAhPSBudWxsICYmIHBvaW50c1tpXVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eFBhdHRlcm4ubW92ZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHhQYXR0ZXJuLmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbG9zZVBhdGgpIHtcbiAgICAgICAgICAgICAgICBjdHhQYXR0ZXJuLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBjbGFzczogJC5qcXBsb3Quc2hhcGVSZW5kZXJlclxuICAgIC8vIFRoZSBkZWZhdWx0IGpxUGxvdCBzaGFwZSByZW5kZXJlci4gIEdpdmVuIGEgc2V0IG9mIHBvaW50cyB3aWxsXG4gICAgLy8gcGxvdCB0aGVtIGFuZCBlaXRoZXIgc3Ryb2tlIGEgbGluZSAoZmlsbCA9IGZhbHNlKSBvciBmaWxsIHRoZW0gKGZpbGwgPSB0cnVlKS5cbiAgICAvLyBJZiBhIGZpbGxlZCBzaGFwZSBpcyBkZXNpcmVkLCBjbG9zZVBhdGggPSB0cnVlIG11c3QgYWxzbyBiZSBzZXQgdG8gY2xvc2VcbiAgICAvLyB0aGUgc2hhcGUuXG4gICAgJC5qcXBsb3QuU2hhcGVSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSAxLjU7XG4gICAgICAgIC8vIHByb3A6IGxpbmVQYXR0ZXJuXG4gICAgICAgIC8vIGxpbmUgcGF0dGVybiAnZGFzaGVkJywgJ2RvdHRlZCcsICdzb2xpZCcsIHNvbWUgY29tYmluYXRpb25cbiAgICAgICAgLy8gb2YgJy0nIGFuZCAnLicgY2hhcmFjdGVycyBzdWNoIGFzICcuLS4nIG9yIGEgbnVtZXJpY2FsIGFycmF5IGxpa2UgXG4gICAgICAgIC8vIFtkcmF3LCBza2lwLCBkcmF3LCBza2lwLCAuLi5dIHN1Y2ggYXMgWzEsIDEwXSB0byBkcmF3IGEgZG90dGVkIGxpbmUsIFxuICAgICAgICAvLyBbMSwgMTAsIDIwLCAxMF0gdG8gZHJhdyBhIGRvdC1kYXNoIGxpbmUsIGFuZCBzbyBvbi5cbiAgICAgICAgdGhpcy5saW5lUGF0dGVybiA9ICdzb2xpZCc7XG4gICAgICAgIC8vIHByb3A6IGxpbmVKb2luXG4gICAgICAgIC8vIEhvdyBsaW5lIHNlZ21lbnRzIG9mIHRoZSBzaGFkb3cgYXJlIGpvaW5lZC5cbiAgICAgICAgdGhpcy5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgICAgIC8vIHByb3A6IGxpbmVDYXBcbiAgICAgICAgLy8gaG93IGVuZHMgb2YgdGhlIHNoYWRvdyBsaW5lIGFyZSByZW5kZXJlZC5cbiAgICAgICAgdGhpcy5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgLy8gcHJvcDsgY2xvc2VQYXRoXG4gICAgICAgIC8vIHdoZXRoZXIgbGluZSBwYXRoIHNlZ21lbnQgaXMgY2xvc2VkIHVwb24gaXRzZWxmLlxuICAgICAgICB0aGlzLmNsb3NlUGF0aCA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBmaWxsXG4gICAgICAgIC8vIHdoZXRoZXIgdG8gZmlsbCB0aGUgc2hhcGUuXG4gICAgICAgIHRoaXMuZmlsbCA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBpc2FyY1xuICAgICAgICAvLyB3aGV0aGVyIHRoZSBzaGFkb3cgaXMgYW4gYXJjIG9yIG5vdC5cbiAgICAgICAgdGhpcy5pc2FyYyA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBmaWxsUmVjdFxuICAgICAgICAvLyB0cnVlIHRvIGRyYXcgc2hhcGUgYXMgYSBmaWxsZWQgcmVjdGFuZ2xlLlxuICAgICAgICB0aGlzLmZpbGxSZWN0ID0gZmFsc2U7XG4gICAgICAgIC8vIHByb3A6IHN0cm9rZVJlY3RcbiAgICAgICAgLy8gdHJ1ZSB0byBkcmF3IHNoYXBlIGFzIGEgc3Ryb2tlZCByZWN0YW5nbGUuXG4gICAgICAgIHRoaXMuc3Ryb2tlUmVjdCA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBjbGVhclJlY3RcbiAgICAgICAgLy8gdHJ1ZSB0byBjZWFyIGEgcmVjdGFuZ2xlLlxuICAgICAgICB0aGlzLmNsZWFyUmVjdCA9IGZhbHNlO1xuICAgICAgICAvLyBwcm9wOiBzdHJva2VTdHlsZVxuICAgICAgICAvLyBjc3MgY29sb3Igc3BlYyBmb3IgdGhlIHN0b2tlIHN0eWxlXG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSAnIzk5OTk5OSc7XG4gICAgICAgIC8vIHByb3A6IGZpbGxTdHlsZVxuICAgICAgICAvLyBjc3MgY29sb3Igc3BlYyBmb3IgdGhlIGZpbGwgc3R5bGUuXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gJyM5OTk5OTknOyBcbiAgICAgICAgXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuU2hhcGVSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBmdW5jdGlvbjogZHJhd1xuICAgIC8vIGRyYXdzIHRoZSBzaGFwZS5cbiAgICAvL1xuICAgIC8vIGN0eCAtIGNhbnZhcyBkcmF3aW5nIGNvbnRleHRcbiAgICAvLyBwb2ludHMgLSBhcnJheSBvZiBwb2ludHMgZm9yIHNoYXBlcyBvciBcbiAgICAvLyBbeCwgeSwgd2lkdGgsIGhlaWdodF0gZm9yIHJlY3RhbmdsZXMgb3JcbiAgICAvLyBbeCwgeSwgcmFkaXVzLCBzdGFydCBhbmdsZSAocmFkKSwgZW5kIGFuZ2xlIChyYWQpXSBmb3IgY2lyY2xlcyBhbmQgYXJjcy5cbiAgICAkLmpxcGxvdC5TaGFwZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmFyIG9wdHMgPSAob3B0aW9ucyAhPSBudWxsKSA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgdmFyIGZpbGwgPSAob3B0cy5maWxsICE9IG51bGwpID8gb3B0cy5maWxsIDogdGhpcy5maWxsO1xuICAgICAgICB2YXIgY2xvc2VQYXRoID0gKG9wdHMuY2xvc2VQYXRoICE9IG51bGwpID8gb3B0cy5jbG9zZVBhdGggOiB0aGlzLmNsb3NlUGF0aDtcbiAgICAgICAgdmFyIGZpbGxSZWN0ID0gKG9wdHMuZmlsbFJlY3QgIT0gbnVsbCkgPyBvcHRzLmZpbGxSZWN0IDogdGhpcy5maWxsUmVjdDtcbiAgICAgICAgdmFyIHN0cm9rZVJlY3QgPSAob3B0cy5zdHJva2VSZWN0ICE9IG51bGwpID8gb3B0cy5zdHJva2VSZWN0IDogdGhpcy5zdHJva2VSZWN0O1xuICAgICAgICB2YXIgY2xlYXJSZWN0ID0gKG9wdHMuY2xlYXJSZWN0ICE9IG51bGwpID8gb3B0cy5jbGVhclJlY3QgOiB0aGlzLmNsZWFyUmVjdDtcbiAgICAgICAgdmFyIGlzYXJjID0gKG9wdHMuaXNhcmMgIT0gbnVsbCkgPyBvcHRzLmlzYXJjIDogdGhpcy5pc2FyYztcbiAgICAgICAgdmFyIGxpbmVQYXR0ZXJuID0gKG9wdHMubGluZVBhdHRlcm4gIT0gbnVsbCkgPyBvcHRzLmxpbmVQYXR0ZXJuIDogdGhpcy5saW5lUGF0dGVybjtcbiAgICAgICAgdmFyIGN0eFBhdHRlcm4gPSAkLmpxcGxvdC5MaW5lUGF0dGVybihjdHgsIGxpbmVQYXR0ZXJuKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMubGluZVdpZHRoIHx8IHRoaXMubGluZVdpZHRoO1xuICAgICAgICBjdHgubGluZUpvaW4gPSBvcHRzLmxpbmVKb2luIHx8IHRoaXMubGluZUpvaW47XG4gICAgICAgIGN0eC5saW5lQ2FwID0gb3B0cy5saW5lQ2FwIHx8IHRoaXMubGluZUNhcDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gKG9wdHMuc3Ryb2tlU3R5bGUgfHwgb3B0cy5jb2xvcikgfHwgdGhpcy5zdHJva2VTdHlsZTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuZmlsbFN0eWxlIHx8IHRoaXMuZmlsbFN0eWxlO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChpc2FyYykge1xuICAgICAgICAgICAgY3R4LmFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgdHJ1ZSk7ICAgXG4gICAgICAgICAgICBpZiAoY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGVhclJlY3QpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsbFJlY3QgfHwgc3Ryb2tlUmVjdCkge1xuICAgICAgICAgICAgaWYgKGZpbGxSZWN0KSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Ryb2tlUmVjdCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIG1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdG8gdGhlIGZpcnN0IG5vbi1udWxsIHBvaW50IGFuZCBtb3ZlIHRvIGl0LlxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV1bMF0gIT0gbnVsbCAmJiBwb2ludHNbaV1bMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4UGF0dGVybi5tb3ZlVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4UGF0dGVybi5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICAgICAgY3R4UGF0dGVybi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgXG4gICAgLy8gY2xhc3MgJC5qcXBsb3QuVGFibGVMZWdlbmRSZW5kZXJlclxuICAgIC8vIFRoZSBkZWZhdWx0IGxlZ2VuZCByZW5kZXJlciBmb3IganFQbG90LlxuICAgICQuanFwbG90LlRhYmxlTGVnZW5kUmVuZGVyZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL1xuICAgIH07XG4gICAgXG4gICAgJC5qcXBsb3QuVGFibGVMZWdlbmRSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAgICAgXG4gICAgJC5qcXBsb3QuVGFibGVMZWdlbmRSZW5kZXJlci5wcm90b3R5cGUuYWRkcm93ID0gZnVuY3Rpb24gKGxhYmVsLCBjb2xvciwgcGFkLCByZXZlcnNlKSB7XG4gICAgICAgIHZhciBycyA9IChwYWQpID8gdGhpcy5yb3dTcGFjaW5nKydweCcgOiAnMHB4JztcbiAgICAgICAgdmFyIHRyO1xuICAgICAgICB2YXIgdGQ7XG4gICAgICAgIHZhciBlbGVtO1xuICAgICAgICB2YXIgZGl2MDtcbiAgICAgICAgdmFyIGRpdjE7XG4gICAgICAgIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0ciA9ICQoZWxlbSk7XG4gICAgICAgIHRyLmFkZENsYXNzKCdqcXBsb3QtdGFibGUtbGVnZW5kJyk7XG4gICAgICAgIGVsZW0gPSBudWxsO1xuXG4gICAgICAgIGlmIChyZXZlcnNlKXtcbiAgICAgICAgICAgIHRyLnByZXBlbmRUbyh0aGlzLl9lbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0ci5hcHBlbmRUbyh0aGlzLl9lbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dTd2F0Y2hlcykge1xuICAgICAgICAgICAgdGQgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJykpO1xuICAgICAgICAgICAgdGQuYWRkQ2xhc3MoJ2pxcGxvdC10YWJsZS1sZWdlbmQganFwbG90LXRhYmxlLWxlZ2VuZC1zd2F0Y2gnKTtcbiAgICAgICAgICAgIHRkLmNzcyh7dGV4dEFsaWduOiAnY2VudGVyJywgcGFkZGluZ1RvcDogcnN9KTtcblxuICAgICAgICAgICAgZGl2MCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICAgICAgZGl2MC5hZGRDbGFzcygnanFwbG90LXRhYmxlLWxlZ2VuZC1zd2F0Y2gtb3V0bGluZScpO1xuICAgICAgICAgICAgZGl2MSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICAgICAgZGl2MS5hZGRDbGFzcygnanFwbG90LXRhYmxlLWxlZ2VuZC1zd2F0Y2gnKTtcbiAgICAgICAgICAgIGRpdjEuY3NzKHtiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLCBib3JkZXJDb2xvcjogY29sb3J9KTtcblxuICAgICAgICAgICAgdHIuYXBwZW5kKHRkLmFwcGVuZChkaXYwLmFwcGVuZChkaXYxKSkpO1xuXG4gICAgICAgICAgICAvLyAkKCc8dGQgY2xhc3M9XCJqcXBsb3QtdGFibGUtbGVnZW5kXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nLXRvcDonK3JzKyc7XCI+JytcbiAgICAgICAgICAgIC8vICc8ZGl2PjxkaXYgY2xhc3M9XCJqcXBsb3QtdGFibGUtbGVnZW5kLXN3YXRjaFwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonK2NvbG9yKyc7Ym9yZGVyLWNvbG9yOicrY29sb3IrJztcIj48L2Rpdj4nK1xuICAgICAgICAgICAgLy8gJzwvZGl2PjwvdGQ+JykuYXBwZW5kVG8odHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgIHRkID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKTtcbiAgICAgICAgICAgIHRkLmFkZENsYXNzKCdqcXBsb3QtdGFibGUtbGVnZW5kIGpxcGxvdC10YWJsZS1sZWdlbmQtbGFiZWwnKTtcbiAgICAgICAgICAgIHRkLmNzcygncGFkZGluZ1RvcCcsIHJzKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZCh0ZCk7XG5cbiAgICAgICAgICAgIC8vIGVsZW0gPSAkKCc8dGQgY2xhc3M9XCJqcXBsb3QtdGFibGUtbGVnZW5kXCIgc3R5bGU9XCJwYWRkaW5nLXRvcDonK3JzKyc7XCI+PC90ZD4nKTtcbiAgICAgICAgICAgIC8vIGVsZW0uYXBwZW5kVG8odHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXNjYXBlSHRtbCkge1xuICAgICAgICAgICAgICAgIHRkLnRleHQobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGQuaHRtbChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGQgPSBudWxsO1xuICAgICAgICBkaXYwID0gbnVsbDtcbiAgICAgICAgZGl2MSA9IG51bGw7XG4gICAgICAgIHRyID0gbnVsbDtcbiAgICAgICAgZWxlbSA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBjYWxsZWQgd2l0aCBzY29wZSBvZiBsZWdlbmRcbiAgICAkLmpxcGxvdC5UYWJsZUxlZ2VuZFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtLmVtcHR5Rm9yY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdykge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX3NlcmllcztcbiAgICAgICAgICAgIC8vIG1ha2UgYSB0YWJsZS4gIG9uZSBsaW5lIGxhYmVsIHBlciByb3cuXG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtID0gJChlbGVtKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW0uYWRkQ2xhc3MoJ2pxcGxvdC10YWJsZS1sZWdlbmQnKTtcblxuICAgICAgICAgICAgdmFyIHNzID0ge3Bvc2l0aW9uOidhYnNvbHV0ZSd9O1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIHNzWydiYWNrZ3JvdW5kJ10gPSB0aGlzLmJhY2tncm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ib3JkZXIpIHtcbiAgICAgICAgICAgICAgICBzc1snYm9yZGVyJ10gPSB0aGlzLmJvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgc3NbJ2ZvbnRTaXplJ10gPSB0aGlzLmZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgIHNzWydmb250RmFtaWx5J10gPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBzc1sndGV4dENvbG9yJ10gPSB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblRvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3NbJ21hcmdpblRvcCddID0gdGhpcy5tYXJnaW5Ub3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJnaW5Cb3R0b20gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNzWydtYXJnaW5Cb3R0b20nXSA9IHRoaXMubWFyZ2luQm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWFyZ2luTGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3NbJ21hcmdpbkxlZnQnXSA9IHRoaXMubWFyZ2luTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmdpblJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzc1snbWFyZ2luUmlnaHQnXSA9IHRoaXMubWFyZ2luUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGFkID0gZmFsc2UsIFxuICAgICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGk8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHMgPSBzZXJpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHMuX3N0YWNrIHx8IHMucmVuZGVyZXIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuQmV6aWVyQ3VydmVSZW5kZXJlcil7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocy5zaG93ICYmIHMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsdCA9IHRoaXMubGFiZWxzW2ldIHx8IHMubGFiZWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVyc2UgJiYgaSA8IHNlcmllcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmV2ZXJzZSAmJiBpID09IHNlcmllcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkcm93LmNhbGwodGhpcywgbHQsIGNvbG9yLCBwYWQsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBhZGQgbW9yZSByb3dzIHRvIGxlZ2VuZC4gIFVzZWQgYnkgdHJlbmQgbGluZSBwbHVnaW4uXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajwkLmpxcGxvdC5hZGRMZWdlbmRSb3dIb29rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSAkLmpxcGxvdC5hZGRMZWdlbmRSb3dIb29rc1tqXS5jYWxsKHRoaXMsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZHJvdy5jYWxsKHRoaXMsIGl0ZW0ubGFiZWwsIGl0ZW0uY29sb3IsIHBhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbTtcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LlRhYmxlTGVnZW5kUmVuZGVyZXIucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbihvZmZzZXRzKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3cpIHsgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ2luc2lkZUdyaWQnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ253JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gb2Zmc2V0cy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdsZWZ0JywgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygndG9wJywgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IChvZmZzZXRzLmxlZnQgKyAodGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggLSBvZmZzZXRzLnJpZ2h0KSkvMiAtIHRoaXMuZ2V0V2lkdGgoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdsZWZ0JywgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygndG9wJywgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDphLCB0b3A6Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAob2Zmc2V0cy50b3AgKyAodGhpcy5fcGxvdERpbWVuc2lvbnMuaGVpZ2h0IC0gb2Zmc2V0cy5ib3R0b20pKS8yIC0gdGhpcy5nZXRIZWlnaHQoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moe3JpZ2h0OmEsIHRvcDpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDphLCBib3R0b206Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAob2Zmc2V0cy5sZWZ0ICsgKHRoaXMuX3Bsb3REaW1lbnNpb25zLndpZHRoIC0gb2Zmc2V0cy5yaWdodCkpLzIgLSB0aGlzLmdldFdpZHRoKCkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gb2Zmc2V0cy5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7bGVmdDphLCBib3R0b206Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gb2Zmc2V0cy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtsZWZ0OmEsIGJvdHRvbTpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG9mZnNldHMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gKG9mZnNldHMudG9wICsgKHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodCAtIG9mZnNldHMuYm90dG9tKSkvMiAtIHRoaXMuZ2V0SGVpZ2h0KCkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtsZWZ0OmEsIHRvcDpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogIC8vIHNhbWUgYXMgJ3NlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDphLCBib3R0b206Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ291dHNpZGUnKXtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbncnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIG9mZnNldHMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gb2Zmc2V0cy50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcygncmlnaHQnLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCd0b3AnLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gKG9mZnNldHMubGVmdCArICh0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIG9mZnNldHMucmlnaHQpKS8yIC0gdGhpcy5nZXRXaWR0aCgpLzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodCAtIG9mZnNldHMudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3MoJ2xlZnQnLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKCdib3R0b20nLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuX3Bsb3REaW1lbnNpb25zLndpZHRoIC0gb2Zmc2V0cy5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gb2Zmc2V0cy50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7bGVmdDphLCB0b3A6Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIG9mZnNldHMucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IChvZmZzZXRzLnRvcCArICh0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQgLSBvZmZzZXRzLmJvdHRvbSkpLzIgLSB0aGlzLmdldEhlaWdodCgpLzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7bGVmdDphLCB0b3A6Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggLSBvZmZzZXRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBvZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtsZWZ0OmEsIGJvdHRvbTpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IChvZmZzZXRzLmxlZnQgKyAodGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggLSBvZmZzZXRzLnJpZ2h0KSkvMiAtIHRoaXMuZ2V0V2lkdGgoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQgLSBvZmZzZXRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtsZWZ0OmEsIHRvcDpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIG9mZnNldHMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gb2Zmc2V0cy5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7cmlnaHQ6YSwgYm90dG9tOmJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggLSBvZmZzZXRzLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IChvZmZzZXRzLnRvcCArICh0aGlzLl9wbG90RGltZW5zaW9ucy5oZWlnaHQgLSBvZmZzZXRzLmJvdHRvbSkpLzIgLSB0aGlzLmdldEhlaWdodCgpLzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7cmlnaHQ6YSwgdG9wOmJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAgLy8gc2FtZSBhcyAnc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG9mZnNldHMucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG9mZnNldHMuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moe3JpZ2h0OmEsIGJvdHRvbTpifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbncnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moe2xlZnQ6MCwgdG9wOm9mZnNldHMudG9wfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IChvZmZzZXRzLmxlZnQgKyAodGhpcy5fcGxvdERpbWVuc2lvbnMud2lkdGggLSBvZmZzZXRzLnJpZ2h0KSkvMiAtIHRoaXMuZ2V0V2lkdGgoKS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moe2xlZnQ6IGEsIHRvcDpvZmZzZXRzLnRvcH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDowLCB0b3A6b2Zmc2V0cy50b3B9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gKG9mZnNldHMudG9wICsgKHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodCAtIG9mZnNldHMuYm90dG9tKSkvMiAtIHRoaXMuZ2V0SGVpZ2h0KCkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDpvZmZzZXRzLnJpZ2h0LCB0b3A6Yn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtyaWdodDpvZmZzZXRzLnJpZ2h0LCBib3R0b206b2Zmc2V0cy5ib3R0b219KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gKG9mZnNldHMubGVmdCArICh0aGlzLl9wbG90RGltZW5zaW9ucy53aWR0aCAtIG9mZnNldHMucmlnaHQpKS8yIC0gdGhpcy5nZXRXaWR0aCgpLzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7bGVmdDogYSwgYm90dG9tOm9mZnNldHMuYm90dG9tfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5jc3Moe2xlZnQ6b2Zmc2V0cy5sZWZ0LCBib3R0b206b2Zmc2V0cy5ib3R0b219KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gKG9mZnNldHMudG9wICsgKHRoaXMuX3Bsb3REaW1lbnNpb25zLmhlaWdodCAtIG9mZnNldHMuYm90dG9tKSkvMiAtIHRoaXMuZ2V0SGVpZ2h0KCkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uY3NzKHtsZWZ0Om9mZnNldHMubGVmdCwgdG9wOmJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAgLy8gc2FtZSBhcyAnc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtLmNzcyh7cmlnaHQ6b2Zmc2V0cy5yaWdodCwgYm90dG9tOm9mZnNldHMuYm90dG9tfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiAkLmpxcGxvdC5UaGVtZUVuZ2luZVxuICAgICAqIFRoZW1lIEVuZ2luZSBwcm92aWRlcyBhIHByb2dyYW1hdGljIHdheSB0byBjaGFuZ2Ugc29tZSBvZiB0aGUgIG1vcmVcbiAgICAgKiBjb21tb24ganFwbG90IHN0eWxpbmcgb3B0aW9ucyBzdWNoIGFzIGZvbnRzLCBjb2xvcnMgYW5kIGdyaWQgb3B0aW9ucy5cbiAgICAgKiBBIHRoZW1lIGVuZ2luZSBpbnN0YW5jZSBpcyBjcmVhdGVkIHdpdGggZWFjaCBwbG90LiAgVGhlIHRoZW1lIGVuZ2luZVxuICAgICAqIG1hbmFnZXMgYSBjb2xsZWN0aW9uIG9mIHRoZW1lcyB3aGljaCBjYW4gYmUgbW9kaWZpZWQsIGFkZGVkIHRvLCBvciBcbiAgICAgKiBhcHBsaWVkIHRvIHRoZSBwbG90LlxuICAgICAqIFxuICAgICAqIFRoZSB0aGVtZUVuZ2luZSBjbGFzcyBpcyBub3QgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAqIFdoZW4gYSBwbG90IGlzIGluaXRpYWxpemVkLCB0aGUgY3VycmVudCBwbG90IG9wdGlvbnMgYXJlIHNjYW5uZWRcbiAgICAgKiBhbiBhIGRlZmF1bHQgdGhlbWUgbmFtZWQgXCJEZWZhdWx0XCIgaXMgY3JlYXRlZC4gIFRoaXMgdGhlbWUgaXNcbiAgICAgKiB1c2VkIGFzIHRoZSBiYXNpcyBmb3Igb3RoZXIgdGhlbWVzIGFkZGVkIHRvIHRoZSB0aGVtZSBlbmdpbmUgYW5kXG4gICAgICogaXMgYWx3YXlzIGF2YWlsYWJsZS5cbiAgICAgKiBcbiAgICAgKiBBIHRoZW1lIGlzIGEgc2ltcGxlIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggc3R5bGluZyBwYXJhbWV0ZXJzIGZvclxuICAgICAqIHZhcmlvdXMgZW50aXRpZXMgb2YgdGhlIHBsb3QuICBBIHRoZW1lIGhhcyB0aGUgZm9ybTpcbiAgICAgKiBcbiAgICAgKiBcbiAgICAgKiA+IHtcbiAgICAgKiA+ICAgICBfbmFtZTpmIFwiRGVmYXVsdFwiLFxuICAgICAqID4gICAgIHRhcmdldDoge1xuICAgICAqID4gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAqID4gICAgIH0sXG4gICAgICogPiAgICAgbGVnZW5kOiB7XG4gICAgICogPiAgICAgICAgIHRleHRDb2xvcjogbnVsbCxcbiAgICAgKiA+ICAgICAgICAgZm9udEZhbWlseTogbnVsbCxcbiAgICAgKiA+ICAgICAgICAgZm9udFNpemU6IG51bGwsXG4gICAgICogPiAgICAgICAgIGJvcmRlcjogbnVsbCxcbiAgICAgKiA+ICAgICAgICAgYmFja2dyb3VuZDogbnVsbFxuICAgICAqID4gICAgIH0sXG4gICAgICogPiAgICAgdGl0bGU6IHtcbiAgICAgKiA+ICAgICAgICAgdGV4dENvbG9yOiBcInJnYigxMDIsIDEwMiwgMTAyKVwiLFxuICAgICAqID4gICAgICAgICBmb250RmFtaWx5OiBcIidUcmVidWNoZXQgTVMnLEFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmXCIsXG4gICAgICogPiAgICAgICAgIGZvbnRTaXplOiBcIjE5LjJweFwiLFxuICAgICAqID4gICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgKiA+ICAgICB9LFxuICAgICAqID4gICAgIHNlcmllc1N0eWxlczoge30sXG4gICAgICogPiAgICAgc2VyaWVzOiBbe1xuICAgICAqID4gICAgICAgICBjb2xvcjogXCIjNGJiMmM1XCIsXG4gICAgICogPiAgICAgICAgIGxpbmVXaWR0aDogMi41LFxuICAgICAqID4gICAgICAgICBsaW5lUGF0dGVybjogXCJzb2xpZFwiLFxuICAgICAqID4gICAgICAgICBzaGFkb3c6IHRydWUsXG4gICAgICogPiAgICAgICAgIGZpbGxDb2xvcjogXCIjNGJiMmM1XCIsXG4gICAgICogPiAgICAgICAgIHNob3dNYXJrZXI6IHRydWUsXG4gICAgICogPiAgICAgICAgIG1hcmtlck9wdGlvbnM6IHtcbiAgICAgKiA+ICAgICAgICAgICAgIGNvbG9yOiBcIiM0YmIyYzVcIixcbiAgICAgKiA+ICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICogPiAgICAgICAgICAgICBzdHlsZTogJ2ZpbGxlZENpcmNsZScsXG4gICAgICogPiAgICAgICAgICAgICBsaW5lV2lkdGg6IDEuNSxcbiAgICAgKiA+ICAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICogPiAgICAgICAgICAgICBzaGFkb3c6IHRydWVcbiAgICAgKiA+ICAgICAgICAgfVxuICAgICAqID4gICAgIH1dLFxuICAgICAqID4gICAgIGdyaWQ6IHtcbiAgICAgKiA+ICAgICAgICAgZHJhd0dyaWRsaW5lczogdHJ1ZSxcbiAgICAgKiA+ICAgICAgICAgZ3JpZExpbmVDb2xvcjogXCIjY2NjY2NjXCIsXG4gICAgICogPiAgICAgICAgIGdyaWRMaW5lV2lkdGg6IDEsXG4gICAgICogPiAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmZGY2XCIsXG4gICAgICogPiAgICAgICAgIGJvcmRlckNvbG9yOiBcIiM5OTk5OTlcIixcbiAgICAgKiA+ICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICogPiAgICAgICAgIHNoYWRvdzogdHJ1ZVxuICAgICAqID4gICAgIH0sXG4gICAgICogPiAgICAgYXhlc1N0eWxlczoge1xuICAgICAqID4gICAgICAgICBsYWJlbDoge30sXG4gICAgICogPiAgICAgICAgIHRpY2tzOiB7fVxuICAgICAqID4gICAgIH0sXG4gICAgICogPiAgICAgYXhlczoge1xuICAgICAqID4gICAgICAgICB4YXhpczoge1xuICAgICAqID4gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzk5OTk5OVwiLFxuICAgICAqID4gICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICogPiAgICAgICAgICAgICB0aWNrczoge1xuICAgICAqID4gICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICogPiAgICAgICAgICAgICAgICAgc2hvd0dyaWRsaW5lOiB0cnVlLFxuICAgICAqID4gICAgICAgICAgICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBzaG93TWFyazogdHJ1ZSxcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBzaXplOiA0LFxuICAgICAqID4gICAgICAgICAgICAgICAgIHRleHRDb2xvcjogXCJcIixcbiAgICAgKiA+ICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAqID4gICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIidUcmVidWNoZXQgTVMnLEFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmXCJcbiAgICAgKiA+ICAgICAgICAgICAgIH0sXG4gICAgICogPiAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAqID4gICAgICAgICAgICAgICAgIHRleHRDb2xvcjogXCJyZ2IoMTAyLCAxMDIsIDEwMilcIixcbiAgICAgKiA+ICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICAgICAqID4gICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE0LjY2NjdweFwiLFxuICAgICAqID4gICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ1RyZWJ1Y2hldCBNUycsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZcIixcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgICogPiAgICAgICAgICAgICB9XG4gICAgICogPiAgICAgICAgIH0sXG4gICAgICogPiAgICAgICAgIHlheGlzOiB7XG4gICAgICogPiAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjOTk5OTk5XCIsXG4gICAgICogPiAgICAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgKiA+ICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICogPiAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBzaG93R3JpZGxpbmU6IHRydWUsXG4gICAgICogPiAgICAgICAgICAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgICAqID4gICAgICAgICAgICAgICAgIHNob3dNYXJrOiB0cnVlLFxuICAgICAqID4gICAgICAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICogPiAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBcIlwiLFxuICAgICAqID4gICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICogPiAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAqID4gICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ1RyZWJ1Y2hldCBNUycsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZcIlxuICAgICAqID4gICAgICAgICAgICAgfSxcbiAgICAgKiA+ICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICogPiAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBudWxsLFxuICAgICAqID4gICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IG51bGwsXG4gICAgICogPiAgICAgICAgICAgICAgICAgZm9udFNpemU6IG51bGwsXG4gICAgICogPiAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogbnVsbCxcbiAgICAgKiA+ICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBudWxsXG4gICAgICogPiAgICAgICAgICAgICB9XG4gICAgICogPiAgICAgICAgIH0sXG4gICAgICogPiAgICAgICAgIHgyYXhpczogey4uLlxuICAgICAqID4gICAgICAgICB9LFxuICAgICAqID4gICAgICAgICAuLi5cbiAgICAgKiA+ICAgICAgICAgeTlheGlzOiB7Li4uXG4gICAgICogPiAgICAgICAgIH1cbiAgICAgKiA+ICAgICB9XG4gICAgICogPiB9XG4gICAgICogXG4gICAgICogXCJzZXJpZXNTdHlsZXNcIiBpcyBhIHN0eWxlIG9iamVjdCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbGwgc2VyaWVzIGluIHRoZSBwbG90LlxuICAgICAqIEl0IHdpbGwgZm9yY2libHkgb3ZlcnJpZGUgYW55IHN0eWxlcyBhcHBsaWVkIG9uIHRoZSBpbmRpdmlkdWFsIHNlcmllcy4gIFwiYXhlc1N0eWxlc1wiIGlzXG4gICAgICogYSBzdHlsZSBvYmplY3QgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGF4ZXMgaW4gdGhlIHBsb3QuICBJdCB3aWxsIGFsc28gZm9yY2libHlcbiAgICAgKiBvdmVycmlkZSBhbnkgc3R5bGVzIG9uIHRoZSBpbmRpdmlkdWFsIGF4ZXMuXG4gICAgICogXG4gICAgICogVGhlIGV4YW1wbGUgc2hvd24gYWJvdmUgaGFzIHNlcmllcyBvcHRpb25zIGZvciBhIGxpbmUgc2VyaWVzLiAgT3B0aW9ucyBmb3Igb3RoZXJcbiAgICAgKiBzZXJpZXMgdHlwZXMgYXJlIHNob3duIGJlbG93OlxuICAgICAqIFxuICAgICAqIEJhciBTZXJpZXM6XG4gICAgICogXG4gICAgICogPiB7XG4gICAgICogPiAgICAgY29sb3I6IFwiIzRiYjJjNVwiLFxuICAgICAqID4gICAgIHNlcmllc0NvbG9yczogW1wiIzRiYjJjNVwiLCBcIiNFQUEyMjhcIiwgXCIjYzViNDdmXCIsIFwiIzU3OTU3NVwiLCBcIiM4Mzk1NTdcIiwgXCIjOTU4YzEyXCIsIFwiIzk1MzU3OVwiLCBcIiM0YjVkZTRcIiwgXCIjZDhiODNmXCIsIFwiI2ZmNTgwMFwiLCBcIiMwMDg1Y2NcIiwgXCIjYzc0N2EzXCIsIFwiI2NkZGY1NFwiLCBcIiNGQkQxNzhcIiwgXCIjMjZCNEUzXCIsIFwiI2JkNzBjN1wiXSxcbiAgICAgKiA+ICAgICBsaW5lV2lkdGg6IDIuNSxcbiAgICAgKiA+ICAgICBzaGFkb3c6IHRydWUsXG4gICAgICogPiAgICAgYmFyUGFkZGluZzogMixcbiAgICAgKiA+ICAgICBiYXJNYXJnaW46IDEwLFxuICAgICAqID4gICAgIGJhcldpZHRoOiAxNS4wOTM3NSxcbiAgICAgKiA+ICAgICBoaWdobGlnaHRDb2xvcnM6IFtcInJnYigxMjksMjAxLDIxNClcIiwgXCJyZ2IoMTI5LDIwMSwyMTQpXCIsIFwicmdiKDEyOSwyMDEsMjE0KVwiLCBcInJnYigxMjksMjAxLDIxNClcIiwgXCJyZ2IoMTI5LDIwMSwyMTQpXCIsIFwicmdiKDEyOSwyMDEsMjE0KVwiLCBcInJnYigxMjksMjAxLDIxNClcIiwgXCJyZ2IoMTI5LDIwMSwyMTQpXCJdXG4gICAgICogPiB9XG4gICAgICogXG4gICAgICogUGllIFNlcmllczpcbiAgICAgKiBcbiAgICAgKiA+IHtcbiAgICAgKiA+ICAgICBzZXJpZXNDb2xvcnM6IFtcIiM0YmIyYzVcIiwgXCIjRUFBMjI4XCIsIFwiI2M1YjQ3ZlwiLCBcIiM1Nzk1NzVcIiwgXCIjODM5NTU3XCIsIFwiIzk1OGMxMlwiLCBcIiM5NTM1NzlcIiwgXCIjNGI1ZGU0XCIsIFwiI2Q4YjgzZlwiLCBcIiNmZjU4MDBcIiwgXCIjMDA4NWNjXCIsIFwiI2M3NDdhM1wiLCBcIiNjZGRmNTRcIiwgXCIjRkJEMTc4XCIsIFwiIzI2QjRFM1wiLCBcIiNiZDcwYzdcIl0sXG4gICAgICogPiAgICAgcGFkZGluZzogMjAsXG4gICAgICogPiAgICAgc2xpY2VNYXJnaW46IDAsXG4gICAgICogPiAgICAgZmlsbDogdHJ1ZSxcbiAgICAgKiA+ICAgICBzaGFkb3c6IHRydWUsXG4gICAgICogPiAgICAgc3RhcnRBbmdsZTogMCxcbiAgICAgKiA+ICAgICBsaW5lV2lkdGg6IDIuNSxcbiAgICAgKiA+ICAgICBoaWdobGlnaHRDb2xvcnM6IFtcInJnYigxMjksMjAxLDIxNClcIiwgXCJyZ2IoMjQwLDE4OSwxMDQpXCIsIFwicmdiKDIxNCwyMDIsMTY1KVwiLCBcInJnYigxMzcsMTgwLDE1OClcIiwgXCJyZ2IoMTY4LDE4MCwxMzcpXCIsIFwicmdiKDE4MCwxNzQsODkpXCIsIFwicmdiKDE4MCwxMTMsMTYxKVwiLCBcInJnYigxMjksMTQxLDIzNilcIiwgXCJyZ2IoMjI3LDIwNSwxMjApXCIsIFwicmdiKDI1NSwxMzgsNzYpXCIsIFwicmdiKDc2LDE2OSwyMTkpXCIsIFwicmdiKDIxNSwxMjYsMTkwKVwiLCBcInJnYigyMjAsMjMyLDEzNSlcIiwgXCJyZ2IoMjAwLDE2Nyw5NilcIiwgXCJyZ2IoMTAzLDIwMiwyMzUpXCIsIFwicmdiKDIwOCwxNTQsMjE1KVwiXVxuICAgICAqID4gfVxuICAgICAqIFxuICAgICAqIEZ1bm5lbCBTZXJpZXM6XG4gICAgICogXG4gICAgICogPiB7XG4gICAgICogPiAgICAgY29sb3I6IFwiIzRiYjJjNVwiLFxuICAgICAqID4gICAgIGxpbmVXaWR0aDogMixcbiAgICAgKiA+ICAgICBzaGFkb3c6IHRydWUsXG4gICAgICogPiAgICAgcGFkZGluZzoge1xuICAgICAqID4gICAgICAgICB0b3A6IDIwLFxuICAgICAqID4gICAgICAgICByaWdodDogMjAsXG4gICAgICogPiAgICAgICAgIGJvdHRvbTogMjAsXG4gICAgICogPiAgICAgICAgIGxlZnQ6IDIwXG4gICAgICogPiAgICAgfSxcbiAgICAgKiA+ICAgICBzZWN0aW9uTWFyZ2luOiA2LFxuICAgICAqID4gICAgIHNlcmllc0NvbG9yczogW1wiIzRiYjJjNVwiLCBcIiNFQUEyMjhcIiwgXCIjYzViNDdmXCIsIFwiIzU3OTU3NVwiLCBcIiM4Mzk1NTdcIiwgXCIjOTU4YzEyXCIsIFwiIzk1MzU3OVwiLCBcIiM0YjVkZTRcIiwgXCIjZDhiODNmXCIsIFwiI2ZmNTgwMFwiLCBcIiMwMDg1Y2NcIiwgXCIjYzc0N2EzXCIsIFwiI2NkZGY1NFwiLCBcIiNGQkQxNzhcIiwgXCIjMjZCNEUzXCIsIFwiI2JkNzBjN1wiXSxcbiAgICAgKiA+ICAgICBoaWdobGlnaHRDb2xvcnM6IFtcInJnYigxNDcsMjA4LDIyMClcIiwgXCJyZ2IoMjQyLDE5OSwxMjYpXCIsIFwicmdiKDIyMCwyMTAsMTc4KVwiLCBcInJnYigxNTQsMTkxLDE3MilcIiwgXCJyZ2IoMTgwLDE5MSwxNTQpXCIsIFwicmdiKDE5MSwxODYsMTEyKVwiLCBcInJnYigxOTEsMTMzLDE3NClcIiwgXCJyZ2IoMTQ3LDE1NywyMzgpXCIsIFwicmdiKDIzMSwyMTIsMTM5KVwiLCBcInJnYigyNTUsMTU0LDEwMilcIiwgXCJyZ2IoMTAyLDE4MSwyMjQpXCIsIFwicmdiKDIyMSwxNDQsMTk5KVwiLCBcInJnYigyMjUsMjM1LDE1MilcIiwgXCJyZ2IoMjAwLDE2Nyw5NilcIiwgXCJyZ2IoMTI0LDIxMCwyMzgpXCIsIFwicmdiKDIxNSwxNjksMjIxKVwiXVxuICAgICAqID4gfVxuICAgICAqIFxuICAgICAqL1xuICAgICQuanFwbG90LlRoZW1lRW5naW5lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gR3JvdXA6IFByb3BlcnRpZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcHJvcDogdGhlbWVzXG4gICAgICAgIC8vIGhhc2ggb2YgdGhlbWVzIG1hbmFnZWQgYnkgdGhlIHRoZW1lIGVuZ2luZS4gIFxuICAgICAgICAvLyBJbmRleGVkIGJ5IHRoZW1lIG5hbWUuXG4gICAgICAgIHRoaXMudGhlbWVzID0ge307XG4gICAgICAgIC8vIHByb3A6IGFjdGl2ZVRoZW1lXG4gICAgICAgIC8vIFBvaW50ZXIgdG8gY3VycmVudGx5IGFjdGl2ZSB0aGVtZVxuICAgICAgICB0aGlzLmFjdGl2ZVRoZW1lPW51bGw7XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgLy8gY2FsbGVkIHdpdGggc2NvcGUgb2YgcGxvdFxuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGdldCB0aGUgRGVmYXVsdCB0aGVtZSBmcm9tIHRoZSBjdXJyZW50IHBsb3Qgc2V0dGluZ3MuXG4gICAgICAgIHZhciB0aCA9IG5ldyAkLmpxcGxvdC5UaGVtZSh7X25hbWU6J0RlZmF1bHQnfSk7XG4gICAgICAgIHZhciBuLCBpLCBubjtcbiAgICAgICAgXG4gICAgICAgIGZvciAobiBpbiB0aC50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChuID09IFwidGV4dENvbG9yXCIpIHtcbiAgICAgICAgICAgICAgICB0aC50YXJnZXRbbl0gPSB0aGlzLnRhcmdldC5jc3MoJ2NvbG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aC50YXJnZXRbbl0gPSB0aGlzLnRhcmdldC5jc3Mobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnRpdGxlLnNob3cgJiYgdGhpcy50aXRsZS5fZWxlbSkge1xuICAgICAgICAgICAgZm9yIChuIGluIHRoLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gXCJ0ZXh0Q29sb3JcIikge1xuICAgICAgICAgICAgICAgICAgICB0aC50aXRsZVtuXSA9IHRoaXMudGl0bGUuX2VsZW0uY3NzKCdjb2xvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGgudGl0bGVbbl0gPSB0aGlzLnRpdGxlLl9lbGVtLmNzcyhuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAobiBpbiB0aC5ncmlkKSB7XG4gICAgICAgICAgICB0aC5ncmlkW25dID0gdGhpcy5ncmlkW25dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aC5ncmlkLmJhY2tncm91bmRDb2xvciA9PSBudWxsICYmIHRoaXMuZ3JpZC5iYWNrZ3JvdW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoLmdyaWQuYmFja2dyb3VuZENvbG9yID0gdGhpcy5ncmlkLmJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGVnZW5kLnNob3cgJiYgdGhpcy5sZWdlbmQuX2VsZW0pIHtcbiAgICAgICAgICAgIGZvciAobiBpbiB0aC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAndGV4dENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICB0aC5sZWdlbmRbbl0gPSB0aGlzLmxlZ2VuZC5fZWxlbS5jc3MoJ2NvbG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aC5sZWdlbmRbbl0gPSB0aGlzLmxlZ2VuZC5fZWxlbS5jc3Mobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpPTA7IGk8dGhpcy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSB0aGlzLnNlcmllc1tpXTtcbiAgICAgICAgICAgIGlmIChzLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkxpbmVSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoLnNlcmllcy5wdXNoKG5ldyBMaW5lU2VyaWVzUHJvcGVydGllcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMucmVuZGVyZXIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuQmFyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aC5zZXJpZXMucHVzaChuZXcgQmFyU2VyaWVzUHJvcGVydGllcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMucmVuZGVyZXIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuUGllUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aC5zZXJpZXMucHVzaChuZXcgUGllU2VyaWVzUHJvcGVydGllcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMucmVuZGVyZXIuY29uc3RydWN0b3IgPT0gJC5qcXBsb3QuRG9udXRSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoLnNlcmllcy5wdXNoKG5ldyBEb251dFNlcmllc1Byb3BlcnRpZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90LkZ1bm5lbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGguc2VyaWVzLnB1c2gobmV3IEZ1bm5lbFNlcmllc1Byb3BlcnRpZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzLnJlbmRlcmVyLmNvbnN0cnVjdG9yID09ICQuanFwbG90Lk1ldGVyR2F1Z2VSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoLnNlcmllcy5wdXNoKG5ldyBNZXRlclNlcmllc1Byb3BlcnRpZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aC5zZXJpZXMucHVzaCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKG4gaW4gdGguc2VyaWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGguc2VyaWVzW2ldW25dID0gc1tuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYSwgYXg7XG4gICAgICAgIGZvciAobiBpbiB0aGlzLmF4ZXMpIHtcbiAgICAgICAgICAgIGF4ID0gdGhpcy5heGVzW25dO1xuICAgICAgICAgICAgYSA9IHRoLmF4ZXNbbl0gPSBuZXcgQXhpc1Byb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIGEuYm9yZGVyQ29sb3IgPSBheC5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGEuYm9yZGVyV2lkdGggPSBheC5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGlmIChheC5fdGlja3MgJiYgYXguX3RpY2tzWzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChubiBpbiBhLnRpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheC5fdGlja3NbMF0uaGFzT3duUHJvcGVydHkobm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnRpY2tzW25uXSA9IGF4Ll90aWNrc1swXVtubl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXguX3RpY2tzWzBdLl9lbGVtKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEudGlja3Nbbm5dID0gYXguX3RpY2tzWzBdLl9lbGVtLmNzcyhubik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXguX2xhYmVsICYmIGF4Ll9sYWJlbC5zaG93KSB7XG4gICAgICAgICAgICAgICAgZm9yIChubiBpbiBhLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEubGFiZWxbbm5dID0gYXguX2xhYmVsLl9lbGVtLmNzcyhubik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheC5fbGFiZWxbbm5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmxhYmVsW25uXSA9IGF4Ll9sYWJlbFtubl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXguX2xhYmVsLl9lbGVtKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubiA9PSAndGV4dENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEubGFiZWxbbm5dID0gYXguX2xhYmVsLl9lbGVtLmNzcygnY29sb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEubGFiZWxbbm5dID0gYXguX2xhYmVsLl9lbGVtLmNzcyhubik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aGVtZUVuZ2luZS5fYWRkKHRoKTtcbiAgICAgICAgdGhpcy50aGVtZUVuZ2luZS5hY3RpdmVUaGVtZSAgPSB0aGlzLnRoZW1lRW5naW5lLnRoZW1lc1t0aC5fbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHcm91cDogbWV0aG9kc1xuICAgICAqIFxuICAgICAqIG1ldGhvZDogZ2V0XG4gICAgICogXG4gICAgICogR2V0IGFuZCByZXR1cm4gdGhlIG5hbWVkIHRoZW1lIG9yIHRoZSBhY3RpdmUgdGhlbWUgaWYgbm8gbmFtZSBnaXZlbi5cbiAgICAgKiBcbiAgICAgKiBwYXJhbWV0ZXI6XG4gICAgICogXG4gICAgICogbmFtZSAtIG5hbWUgb2YgdGhlbWUgdG8gZ2V0LlxuICAgICAqIFxuICAgICAqIHJldHVybnM6XG4gICAgICogXG4gICAgICogVGhlbWUgaW5zdGFuY2Ugb2YgZ2l2ZW4gbmFtZS5cbiAgICAgKi8gICBcbiAgICAkLmpxcGxvdC5UaGVtZUVuZ2luZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgYWN0aXZlIHRoZW1lXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaGVtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW1lc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gbnVtZXJpY2FsT3JkZXIoYSxiKSB7IHJldHVybiBhLWI7IH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBtZXRob2Q6IGdldFRoZW1lTmFtZXNcbiAgICAgKiBcbiAgICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgdGhlbWUgbmFtZXMgaW4gdGhpcyBtYW5hZ2VyIGluIGFscGhhLW51bWVyaWNhbCBvcmRlci5cbiAgICAgKiBcbiAgICAgKiBwYXJhbWV0ZXI6XG4gICAgICogXG4gICAgICogTm9uZVxuICAgICAqIFxuICAgICAqIHJldHVybnM6XG4gICAgICogXG4gICAgICogQSB0aGUgbGlzdCBvZiB0aGVtZSBuYW1lcyBpbiB0aGlzIG1hbmFnZXIgaW4gYWxwaGEtbnVtZXJpY2FsIG9yZGVyLlxuICAgICAqLyAgICAgICBcbiAgICAkLmpxcGxvdC5UaGVtZUVuZ2luZS5wcm90b3R5cGUuZ2V0VGhlbWVOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLnRoZW1lcykge1xuICAgICAgICAgICAgdG4ucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG4uc29ydChudW1lcmljYWxPcmRlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZDogZ2V0VGhlbWVzXG4gICAgICogXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiB0aGVtZXMgaW4gYWxwaGEtbnVtZXJpY2FsIG9yZGVyIGJ5IG5hbWUuXG4gICAgICogXG4gICAgICogcGFyYW1ldGVyOlxuICAgICAqIFxuICAgICAqIE5vbmVcbiAgICAgKiBcbiAgICAgKiByZXR1cm5zOlxuICAgICAqIFxuICAgICAqIEEgbGlzdCBvZiB0aGVtZXMgaW4gYWxwaGEtbnVtZXJpY2FsIG9yZGVyIGJ5IG5hbWUuXG4gICAgICovIFxuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5nZXRUaGVtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRuID0gW107XG4gICAgICAgIHZhciB0aGVtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLnRoZW1lcykge1xuICAgICAgICAgICAgdG4ucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICB0bi5zb3J0KG51bWVyaWNhbE9yZGVyKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGVtZXMucHVzaCh0aGlzLnRoZW1lc1t0bltpXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVtZXM7XG4gICAgfTtcbiAgICBcbiAgICAkLmpxcGxvdC5UaGVtZUVuZ2luZS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihwbG90LCBuYW1lKSB7XG4gICAgICAgIC8vIHNvbWV0aW1lcyBuZWVkIHRvIHJlZHJhdyB3aG9sZSBwbG90LlxuICAgICAgICB2YXIgcmVkcmF3UGxvdCA9IGZhbHNlO1xuICAgICAgICBpZiAoIW5hbWUgJiYgdGhpcy5hY3RpdmVUaGVtZSAmJiB0aGlzLmFjdGl2ZVRoZW1lLl9uYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5hY3RpdmVUaGVtZS5fbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGhlbWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0aGVtZSBvZiB0aGF0IG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGggPSB0aGlzLnRoZW1lc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGhlbWUgPSB0aDtcbiAgICAgICAgICAgIHZhciB2YWwsIGNoZWNrQm9yZGVyQ29sb3IgPSBmYWxzZSwgY2hlY2tCb3JkZXJXaWR0aCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFyciA9IFsneGF4aXMnLCAneDJheGlzJywgJ3lheGlzJywgJ3kyYXhpcyddO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXggPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoLmF4ZXNTdHlsZXMuYm9yZGVyQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwbG90LmF4ZXNbYXhdLmJvcmRlckNvbG9yID0gdGguYXhlc1N0eWxlcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoLmF4ZXNTdHlsZXMuYm9yZGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwbG90LmF4ZXNbYXhdLmJvcmRlcldpZHRoID0gdGguYXhlc1N0eWxlcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGF4bmFtZSBpbiBwbG90LmF4ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBsb3QuYXhlc1theG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXhpcyA9IHRoLmF4ZXNbYXhuYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXhzdHlsZSA9IHRoLmF4ZXNTdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF4ID0gJC5qcXBsb3QuZXh0ZW5kKHRydWUsIHt9LCB0aGF4aXMsIHRoYXhzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICh0aC5heGVzU3R5bGVzLmJvcmRlckNvbG9yICE9IG51bGwpID8gdGguYXhlc1N0eWxlcy5ib3JkZXJDb2xvciA6IHRoYXguYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF4LmJvcmRlckNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuYm9yZGVyQ29sb3IgPSB0aGF4LmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3UGxvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHRoLmF4ZXNTdHlsZXMuYm9yZGVyV2lkdGggIT0gbnVsbCkgPyB0aC5heGVzU3R5bGVzLmJvcmRlcldpZHRoIDogdGhheC5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXguYm9yZGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5ib3JkZXJXaWR0aCA9IHRoYXguYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXdQbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5fdGlja3MgJiYgYXhpcy5fdGlja3NbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5uIGluIHRoYXgudGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aC5heGVzU3R5bGVzLnRpY2tzICYmIHRoLmF4ZXNTdHlsZXMudGlja3Nbbm5dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgdmFsID0gdGguYXhlc1N0eWxlcy50aWNrc1tubl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgKHRoYXgudGlja3Nbbm5dICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB2YWwgPSB0aGF4LnRpY2tzW25uXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGF4LnRpY2tzW25uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aWNrT3B0aW9uc1tubl0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuX3RpY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhd1Bsb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5fbGFiZWwgJiYgYXhpcy5fbGFiZWwuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbm4gaW4gdGhheC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoLmF4ZXNTdHlsZXMubGFiZWwgJiYgdGguYXhlc1N0eWxlcy5sYWJlbFtubl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB2YWwgPSB0aC5heGVzU3R5bGVzLmxhYmVsW25uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiAodGhheC5sYWJlbCAmJiB0aGF4LmxhYmVsW25uXSAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgdmFsID0gdGhheC5sYWJlbFtubl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhheC5sYWJlbFtubl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMubGFiZWxPcHRpb25zW25uXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3UGxvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiB0aC5ncmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoLmdyaWRbbl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwbG90LmdyaWRbbl0gPSB0aC5ncmlkW25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVkcmF3UGxvdCkge1xuICAgICAgICAgICAgICAgIHBsb3QuZ3JpZC5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwbG90LmxlZ2VuZC5zaG93KSB7IFxuICAgICAgICAgICAgICAgIGZvciAobiBpbiB0aC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoLmxlZ2VuZFtuXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LmxlZ2VuZFtuXSA9IHRoLmxlZ2VuZFtuXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbG90LnRpdGxlLnNob3cpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG4gaW4gdGgudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoLnRpdGxlW25dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudGl0bGVbbl0gPSB0aC50aXRsZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTx0aC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciByZWRyYXdTZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKG4gaW4gdGguc2VyaWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICh0aC5zZXJpZXNTdHlsZXNbbl0gIT0gbnVsbCkgPyB0aC5zZXJpZXNTdHlsZXNbbl0gOiB0aC5zZXJpZXNbaV1bbl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1tuXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LnNlcmllc1tpXS5yZW5kZXJlci5zaGFwZVJlbmRlcmVyLmZpbGxTdHlsZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LnNlcmllc1tpXS5yZW5kZXJlci5zaGFwZVJlbmRlcmVyLnN0cm9rZVN0eWxlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3Quc2VyaWVzW2ldW25dID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKG4gPT0gJ2xpbmVXaWR0aCcpIHx8IChuID09ICdsaW5lUGF0dGVybicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5zZXJpZXNbaV0ucmVuZGVyZXIuc2hhcGVSZW5kZXJlcltuXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LnNlcmllc1tpXVtuXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gPT0gJ21hcmtlck9wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgKHBsb3Quc2VyaWVzW2ldLm1hcmtlck9wdGlvbnMsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgKHBsb3Quc2VyaWVzW2ldLm1hcmtlclJlbmRlcmVyLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5zZXJpZXNbaV1bbl0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXdQbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlZHJhd1Bsb3QpIHtcbiAgICAgICAgICAgICAgICBwbG90LnRhcmdldC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHBsb3QuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKG4gaW4gdGgudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoLnRhcmdldFtuXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QudGFyZ2V0LmNzcyhuLCB0aC50YXJnZXRbbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24odGhlbWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHRoZW1lLl9uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoZW1lLl9uYW1lKSB7XG4gICAgICAgICAgICB0aGVtZS5fbmFtZSA9IERhdGUucGFyc2UobmV3IERhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRoZW1lcy5oYXNPd25Qcm9wZXJ0eSh0aGVtZS5fbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGhlbWVzW3RoZW1lLl9uYW1lXSA9IHRoZW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwianFwbG90LlRoZW1lRW5naW5lIEVycm9yOiBUaGVtZSBhbHJlYWR5IGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gbWV0aG9kIHJlbW92ZVxuICAgIC8vIERlbGV0ZSB0aGUgbmFtZWQgdGhlbWUsIHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gICAgXG5cbiAgICAvKipcbiAgICAgKiBtZXRob2Q6IHJlbW92ZVxuICAgICAqIFxuICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gdGhlbWUgZnJvbSB0aGUgdGhlbWVFbmdpbmUuXG4gICAgICogXG4gICAgICogcGFyYW1ldGVyczpcbiAgICAgKiBcbiAgICAgKiBuYW1lIC0gbmFtZSBvZiB0aGUgdGhlbWUgdG8gcmVtb3ZlLlxuICAgICAqIFxuICAgICAqIHJldHVybnM6XG4gICAgICogXG4gICAgICogdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlLlxuICAgICAqL1xuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09ICdEZWZhdWx0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGUgdGhpcy50aGVtZXNbbmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZDogbmV3VGhlbWVcbiAgICAgKiBcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGhlbWUgYmFzZWQgb24gdGhlIGRlZmF1bHQgdGhlbWUsIGFkZGluZyBpdCB0aGUgdGhlbWVFbmdpbmUuXG4gICAgICogXG4gICAgICogcGFyYW1ldGVyczpcbiAgICAgKiBcbiAgICAgKiBuYW1lIC0gbmFtZSBvZiB0aGUgbmV3IHRoZW1lLlxuICAgICAqIG9iaiAtIG9wdGlvbmFsIG9iamVjdCBvZiBzdHlsZXMgdG8gYmUgYXBwbGllZCB0byB0aGlzIG5ldyB0aGVtZS5cbiAgICAgKiBcbiAgICAgKiByZXR1cm5zOlxuICAgICAqIFxuICAgICAqIG5ldyBUaGVtZSBvYmplY3QuXG4gICAgICovXG4gICAgJC5qcXBsb3QuVGhlbWVFbmdpbmUucHJvdG90eXBlLm5ld1RoZW1lID0gZnVuY3Rpb24obmFtZSwgb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YobmFtZSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiAmJiBvYmouX25hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBvYmouX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBEYXRlLnBhcnNlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciB0aCA9IG5ldyAkLmpxcGxvdC5UaGVtZShuYW1lKTtcbiAgICAgICAgdmFyIHRoID0gdGhpcy5jb3B5KHRoaXMudGhlbWVzWydEZWZhdWx0J10uX25hbWUsIG5hbWUpO1xuICAgICAgICAkLmpxcGxvdC5leHRlbmQodGgsIG9iaik7XG4gICAgICAgIHJldHVybiB0aDtcbiAgICB9O1xuICAgIFxuICAgIC8vIGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIC8vICAgICByZXR1cm4gZXZhbChvYmoudG9Tb3VyY2UoKSk7XG4gICAgLy8gfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNsb25lKG9iail7XG4gICAgICAgIGlmKG9iaiA9PSBudWxsIHx8IHR5cGVvZihvYmopICE9ICdvYmplY3QnKXtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgdmFyIHRlbXAgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICB0ZW1wW2tleV0gPSBjbG9uZShvYmpba2V5XSk7XG4gICAgICAgIH0gICBcbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfVxuICAgIFxuICAgICQuanFwbG90LmNsb25lID0gY2xvbmU7XG4gICAgXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMiA9PSAgbnVsbCB8fCB0eXBlb2Yob2JqMikgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqMikge1xuICAgICAgICAgICAgaWYgKGtleSA9PSAnaGlnaGxpZ2h0Q29sb3JzJykge1xuICAgICAgICAgICAgICAgIG9iajFba2V5XSA9IGNsb25lKG9iajJba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqMltrZXldICE9IG51bGwgJiYgdHlwZW9mKG9iajJba2V5XSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBvYmoxW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2Uob2JqMVtrZXldLCBvYmoyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgICQuanFwbG90Lm1lcmdlID0gbWVyZ2U7XG4gICAgXG4gICAgICAgIC8vIFVzZSB0aGUgalF1ZXJ5IDEuMy4yIGV4dGVuZCBmdW5jdGlvbiBzaW5jZSBiZWhhdmlvdXIgaW4galF1ZXJ5IDEuNCBzZWVtcyBwcm9ibGVtYXRpY1xuICAgICQuanFwbG90LmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBjb3B5IHJlZmVyZW5jZSB0byB0YXJnZXQgb2JqZWN0XG4gICAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBkZWVwID0gZmFsc2UsIG9wdGlvbnM7XG5cbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIGkgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhdG9TdHJpbmcuY2FsbCh0YXJnZXQpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCIgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmMgPSB0YXJnZXRbIG5hbWUgXSwgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgb2JqZWN0IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiB0eXBlb2YgY29weSA9PT0gXCJvYmplY3RcIiAmJiAhY29weS5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gJC5qcXBsb3QuZXh0ZW5kKCBkZWVwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMgfHwgKCBjb3B5Lmxlbmd0aCAhPSBudWxsID8gWyBdIDogeyB9IClcbiAgICAgICAgICAgICAgICAgICAgICAgICwgY29weSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtZXRob2Q6IHJlbmFtZVxuICAgICAqIFxuICAgICAqIFJlbmFtZSBhIHRoZW1lLlxuICAgICAqIFxuICAgICAqIHBhcmFtZXRlcnM6XG4gICAgICogXG4gICAgICogb2xkTmFtZSAtIGN1cnJlbnQgbmFtZSBvZiB0aGUgdGhlbWUuXG4gICAgICogbmV3TmFtZSAtIGRlc2lyZWQgbmFtZSBvZiB0aGUgdGhlbWUuXG4gICAgICogXG4gICAgICogcmV0dXJuczpcbiAgICAgKiBcbiAgICAgKiBuZXcgVGhlbWUgb2JqZWN0LlxuICAgICAqL1xuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICBpZiAob2xkTmFtZSA9PSAnRGVmYXVsdCcgfHwgbmV3TmFtZSA9PSAnRGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciAoXCJqcXBsb3QuVGhlbWVFbmdpbmUgRXJyb3I6IENhbm5vdCByZW5hbWUgZnJvbS90byBEZWZhdWx0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRoZW1lcy5oYXNPd25Qcm9wZXJ0eShuZXdOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChcImpxcGxvdC5UaGVtZUVuZ2luZSBFcnJvcjogTmV3IG5hbWUgYWxyZWFkeSBpbiB1c2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGhlbWVzLmhhc093blByb3BlcnR5KG9sZE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdGggPSB0aGlzLmNvcHkgKG9sZE5hbWUsIG5ld05hbWUpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUob2xkTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwianFwbG90LlRoZW1lRW5naW5lIEVycm9yOiBPbGQgbmFtZSBvciBuZXcgbmFtZSBpbnZhbGlkXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtZXRob2Q6IGNvcHlcbiAgICAgKiBcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIGFuIGV4aXN0aW5nIHRoZW1lIGluIHRoZSB0aGVtZUVuZ2luZSwgYWRkaW5nIGl0IHRoZSB0aGVtZUVuZ2luZS5cbiAgICAgKiBcbiAgICAgKiBwYXJhbWV0ZXJzOlxuICAgICAqIFxuICAgICAqIHNvdXJjZU5hbWUgLSBuYW1lIG9mIHRoZSBleGlzdGluZyB0aGVtZS5cbiAgICAgKiB0YXJnZXROYW1lIC0gbmFtZSBvZiB0aGUgY29weS5cbiAgICAgKiBvYmogLSBvcHRpb25hbCBvYmplY3Qgb2Ygc3R5bGUgcGFyYW1ldGVyIHRvIGFwcGx5IHRvIHRoZSBuZXcgdGhlbWUuXG4gICAgICogXG4gICAgICogcmV0dXJuczpcbiAgICAgKiBcbiAgICAgKiBuZXcgVGhlbWUgb2JqZWN0LlxuICAgICAqL1xuICAgICQuanFwbG90LlRoZW1lRW5naW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIG9iaikge1xuICAgICAgICBpZiAodGFyZ2V0TmFtZSA9PSAnRGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciAoXCJqcXBsb3QuVGhlbWVFbmdpbmUgRXJyb3I6IENhbm5vdCBjb3B5IG92ZXIgRGVmYXVsdCB0aGVtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGhlbWVzLmhhc093blByb3BlcnR5KHNvdXJjZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IFwianFwbG90LlRoZW1lRW5naW5lIEVycm9yOiBTb3VyY2UgbmFtZSBpbnZhbGlkXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGhlbWVzLmhhc093blByb3BlcnR5KHRhcmdldE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IFwianFwbG90LlRoZW1lRW5naW5lIEVycm9yOiBUYXJnZXQgbmFtZSBpbnZhbGlkXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGggPSBjbG9uZSh0aGlzLnRoZW1lc1tzb3VyY2VOYW1lXSk7XG4gICAgICAgICAgICB0aC5fbmFtZSA9IHRhcmdldE5hbWU7XG4gICAgICAgICAgICAkLmpxcGxvdC5leHRlbmQodHJ1ZSwgdGgsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9hZGQodGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBcbiAgICAkLmpxcGxvdC5UaGVtZSA9IGZ1bmN0aW9uKG5hbWUsIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mKG5hbWUpID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IERhdGUucGFyc2UobmV3IERhdGUoKSk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxlZ2VuZCA9IHtcbiAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbCxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IG51bGwsXG4gICAgICAgICAgICBmb250U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGJvcmRlcjogbnVsbCxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50aXRsZSA9IHtcbiAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbCxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IG51bGwsXG4gICAgICAgICAgICBmb250U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHRleHRBbGlnbjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlcmllc1N0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgICAgICB0aGlzLmdyaWQgPSB7XG4gICAgICAgICAgICBkcmF3R3JpZGxpbmVzOiBudWxsLFxuICAgICAgICAgICAgZ3JpZExpbmVDb2xvcjogbnVsbCxcbiAgICAgICAgICAgIGdyaWRMaW5lV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiBudWxsLFxuICAgICAgICAgICAgc2hhZG93OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXhlc1N0eWxlcyA9IHtsYWJlbDp7fSwgdGlja3M6e319O1xuICAgICAgICB0aGlzLmF4ZXMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZihvYmopID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodHlwZW9mKG9iaikgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICQuanFwbG90LmV4dGVuZCh0cnVlLCB0aGlzLCBvYmopO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgQXhpc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSBudWxsO1xuICAgICAgICB0aGlzLnRpY2tzID0gbmV3IEF4aXNUaWNrcygpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IEF4aXNMYWJlbCgpO1xuICAgIH07XG4gICAgXG4gICAgdmFyIEF4aXNUaWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNob3cgPSBudWxsO1xuICAgICAgICB0aGlzLnNob3dHcmlkbGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd0xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaG93TWFyayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dENvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy53aGl0ZVNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgQXhpc0xhYmVsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGV4dENvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy53aGl0ZVNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgTGluZVNlcmllc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb2xvcj1udWxsO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aD1udWxsO1xuICAgICAgICB0aGlzLmxpbmVQYXR0ZXJuPW51bGw7XG4gICAgICAgIHRoaXMuc2hhZG93PW51bGw7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yPW51bGw7XG4gICAgICAgIHRoaXMuc2hvd01hcmtlcj1udWxsO1xuICAgICAgICB0aGlzLm1hcmtlck9wdGlvbnMgPSBuZXcgTWFya2VyT3B0aW9ucygpO1xuICAgIH07XG4gICAgXG4gICAgdmFyIE1hcmtlck9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBCYXJTZXJpZXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29sb3I9bnVsbDtcbiAgICAgICAgdGhpcy5zZXJpZXNDb2xvcnM9bnVsbDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGg9bnVsbDtcbiAgICAgICAgdGhpcy5zaGFkb3c9bnVsbDtcbiAgICAgICAgdGhpcy5iYXJQYWRkaW5nPW51bGw7XG4gICAgICAgIHRoaXMuYmFyTWFyZ2luPW51bGw7XG4gICAgICAgIHRoaXMuYmFyV2lkdGg9bnVsbDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb2xvcnM9bnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBQaWVTZXJpZXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzQ29sb3JzPW51bGw7XG4gICAgICAgIHRoaXMucGFkZGluZz1udWxsO1xuICAgICAgICB0aGlzLnNsaWNlTWFyZ2luPW51bGw7XG4gICAgICAgIHRoaXMuZmlsbD1udWxsO1xuICAgICAgICB0aGlzLnNoYWRvdz1udWxsO1xuICAgICAgICB0aGlzLnN0YXJ0QW5nbGU9bnVsbDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGg9bnVsbDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb2xvcnM9bnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBEb251dFNlcmllc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNDb2xvcnM9bnVsbDtcbiAgICAgICAgdGhpcy5wYWRkaW5nPW51bGw7XG4gICAgICAgIHRoaXMuc2xpY2VNYXJnaW49bnVsbDtcbiAgICAgICAgdGhpcy5maWxsPW51bGw7XG4gICAgICAgIHRoaXMuc2hhZG93PW51bGw7XG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZT1udWxsO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aD1udWxsO1xuICAgICAgICB0aGlzLmlubmVyRGlhbWV0ZXI9bnVsbDtcbiAgICAgICAgdGhpcy50aGlja25lc3M9bnVsbDtcbiAgICAgICAgdGhpcy5yaW5nTWFyZ2luPW51bGw7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29sb3JzPW51bGw7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgRnVubmVsU2VyaWVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbG9yPW51bGw7XG4gICAgICAgIHRoaXMubGluZVdpZHRoPW51bGw7XG4gICAgICAgIHRoaXMuc2hhZG93PW51bGw7XG4gICAgICAgIHRoaXMucGFkZGluZz1udWxsO1xuICAgICAgICB0aGlzLnNlY3Rpb25NYXJnaW49bnVsbDtcbiAgICAgICAgdGhpcy5zZXJpZXNDb2xvcnM9bnVsbDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb2xvcnM9bnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBNZXRlclNlcmllc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wYWRkaW5nPW51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yPW51bGw7XG4gICAgICAgIHRoaXMucmluZ0NvbG9yPW51bGw7XG4gICAgICAgIHRoaXMudGlja0NvbG9yPW51bGw7XG4gICAgICAgIHRoaXMucmluZ1dpZHRoPW51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxDb2xvcnM9bnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElubmVyUmFkaXVzPW51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxPdXRlclJhZGl1cz1udWxsO1xuICAgICAgICB0aGlzLmh1YlJhZGl1cz1udWxsO1xuICAgICAgICB0aGlzLm5lZWRsZVRoaWNrbmVzcz1udWxsO1xuICAgICAgICB0aGlzLm5lZWRsZVBhZD1udWxsO1xuICAgIH07XG4gICAgICAgIFxuXG5cblxuICAgICQuZm4uanFwbG90Q2hpbGRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgIC8vIE5vZGUuVEVYVF9OT0RFIG5vdCBkZWZpbmVkIGluIEk3XG4gICAgICAgIH0pLnRleHQoKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBmb250IHN0eWxlIGFzIGFiYnJldmlhdGlvbiBmb3IgXCJmb250XCIgcHJvcGVydHkuXG4gICAgJC5mbi5qcXBsb3RHZXRDb21wdXRlZEZvbnRTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgXCJcIikgOiB0aGlzWzBdLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgdmFyIGF0dHJzID0gY3NzWydmb250LXN0eWxlJ10gPyBbJ2ZvbnQtc3R5bGUnLCAnZm9udC13ZWlnaHQnLCAnZm9udC1zaXplJywgJ2ZvbnQtZmFtaWx5J10gOiBbJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknXTtcbiAgICAgICAgdmFyIHN0eWxlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IFN0cmluZyhjc3NbYXR0cnNbaV1dKTtcblxuICAgICAgICAgICAgaWYgKGF0dHIgJiYgYXR0ciAhPSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLnB1c2goYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlOiAkLmZuXG4gICAgICogalF1ZXJ5IG5hbWVzcGFjZSB0byBhdHRhY2ggZnVuY3Rpb25zIHRvIGpRdWVyeSBlbGVtZW50cy5cbiAgICAgKiAgXG4gICAgICovXG5cbiAgICAkLmZuLmpxcGxvdFRvSW1hZ2VDYW52YXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB4X29mZnNldCA9IChvcHRpb25zLnhfb2Zmc2V0ID09IG51bGwpID8gMCA6IG9wdGlvbnMueF9vZmZzZXQ7XG4gICAgICAgIHZhciB5X29mZnNldCA9IChvcHRpb25zLnlfb2Zmc2V0ID09IG51bGwpID8gMCA6IG9wdGlvbnMueV9vZmZzZXQ7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgPT0gbnVsbCkgPyAncmdiKDI1NSwyNTUsMjU1KScgOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICBpZiAoJCh0aGlzKS53aWR0aCgpID09IDAgfHwgJCh0aGlzKS5oZWlnaHQoKSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4Y2FudmFzIGFuZCBoZW5jZSBJRSA8IDkgZG8gbm90IHN1cHBvcnQgdG9EYXRhVVJMIGFuZCBjYW5ub3QgZXhwb3J0IGltYWdlcy5cbiAgICAgICAgaWYgKCQuanFwbG90LnVzZV9leGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBuZXdDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB2YXIgaCA9ICQodGhpcykub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgIHZhciB3ID0gJCh0aGlzKS5vdXRlcldpZHRoKHRydWUpO1xuICAgICAgICB2YXIgb2ZmcyA9ICQodGhpcykub2Zmc2V0KCk7XG4gICAgICAgIHZhciBwbG90bGVmdCA9IG9mZnMubGVmdDtcbiAgICAgICAgdmFyIHBsb3R0b3AgPSBvZmZzLnRvcDtcbiAgICAgICAgdmFyIHRyYW5zeCA9IDAsIHRyYW5zeSA9IDA7XG5cbiAgICAgICAgLy8gaGF2ZSB0byBjaGVjayBpZiBhbnkgZWxlbWVudHMgYXJlIGhhbmdpbmcgb3V0c2lkZSBvZiBwbG90IGFyZWEgYmVmb3JlIHJlbmRlcmluZyxcbiAgICAgICAgLy8gc2luY2UgY2hhbmdpbmcgd2lkdGggb2YgY2FudmFzIHdpbGwgZXJhc2UgY2FudmFzLlxuXG4gICAgICAgIHZhciBjbHNlcyA9IFsnanFwbG90LXRhYmxlLWxlZ2VuZCcsICdqcXBsb3QteGF4aXMtdGljaycsICdqcXBsb3QteDJheGlzLXRpY2snLCAnanFwbG90LXlheGlzLXRpY2snLCAnanFwbG90LXkyYXhpcy10aWNrJywgJ2pxcGxvdC15M2F4aXMtdGljaycsIFxuICAgICAgICAnanFwbG90LXk0YXhpcy10aWNrJywgJ2pxcGxvdC15NWF4aXMtdGljaycsICdqcXBsb3QteTZheGlzLXRpY2snLCAnanFwbG90LXk3YXhpcy10aWNrJywgJ2pxcGxvdC15OGF4aXMtdGljaycsICdqcXBsb3QteTlheGlzLXRpY2snLFxuICAgICAgICAnanFwbG90LXhheGlzLWxhYmVsJywgJ2pxcGxvdC14MmF4aXMtbGFiZWwnLCAnanFwbG90LXlheGlzLWxhYmVsJywgJ2pxcGxvdC15MmF4aXMtbGFiZWwnLCAnanFwbG90LXkzYXhpcy1sYWJlbCcsICdqcXBsb3QteTRheGlzLWxhYmVsJywgXG4gICAgICAgICdqcXBsb3QteTVheGlzLWxhYmVsJywgJ2pxcGxvdC15NmF4aXMtbGFiZWwnLCAnanFwbG90LXk3YXhpcy1sYWJlbCcsICdqcXBsb3QteThheGlzLWxhYmVsJywgJ2pxcGxvdC15OWF4aXMtbGFiZWwnIF07XG5cbiAgICAgICAgdmFyIHRlbXB0b3AsIHRlbXBsZWZ0LCB0ZW1wYm90dG9tLCB0ZW1wcmlnaHQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCcuJytjbHNlc1tpXSkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0ZW1wdG9wID0gJCh0aGlzKS5vZmZzZXQoKS50b3AgLSBwbG90dG9wO1xuICAgICAgICAgICAgICAgIHRlbXBsZWZ0ID0gJCh0aGlzKS5vZmZzZXQoKS5sZWZ0IC0gcGxvdGxlZnQ7XG4gICAgICAgICAgICAgICAgdGVtcHJpZ2h0ID0gdGVtcGxlZnQgKyAkKHRoaXMpLm91dGVyV2lkdGgodHJ1ZSkgKyB0cmFuc3g7XG4gICAgICAgICAgICAgICAgdGVtcGJvdHRvbSA9IHRlbXB0b3AgKyAkKHRoaXMpLm91dGVySGVpZ2h0KHRydWUpICsgdHJhbnN5O1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGVmdCA8IC10cmFuc3gpIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHcgLSB0cmFuc3ggLSB0ZW1wbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnN4ID0gLXRlbXBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcHRvcCA8IC10cmFuc3kpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IGggLSB0cmFuc3kgLSB0ZW1wdG9wO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3kgPSAtIHRlbXB0b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wcmlnaHQgPiB3KSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSB0ZW1wcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wYm90dG9tID4gaCkge1xuICAgICAgICAgICAgICAgICAgICBoID0gIHRlbXBib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdDYW52YXMud2lkdGggPSB3ICsgTnVtYmVyKHhfb2Zmc2V0KTtcbiAgICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IGggKyBOdW1iZXIoeV9vZmZzZXQpO1xuXG4gICAgICAgIHZhciBuZXdDb250ZXh0ID0gbmV3Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgXG5cbiAgICAgICAgbmV3Q29udGV4dC5zYXZlKCk7XG4gICAgICAgIG5ld0NvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBuZXdDb250ZXh0LmZpbGxSZWN0KDAsMCwgbmV3Q2FudmFzLndpZHRoLCBuZXdDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgbmV3Q29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgbmV3Q29udGV4dC50cmFuc2xhdGUodHJhbnN4LCB0cmFuc3kpO1xuICAgICAgICBuZXdDb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgbmV3Q29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5laGVpZ2h0KGVsKSB7XG4gICAgICAgICAgICB2YXIgbGluZWhlaWdodCA9IHBhcnNlSW50KCQoZWwpLmNzcygnbGluZS1oZWlnaHQnKSwgMTApO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4obGluZWhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBsaW5laGVpZ2h0ID0gcGFyc2VJbnQoJChlbCkuY3NzKCdmb250LXNpemUnKSwgMTApICogMS4yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmVoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZVdyYXBwZWRUZXh0IChlbCwgY29udGV4dCwgdGV4dCwgbGVmdCwgdG9wLCBjYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgdmFyIGxpbmVoZWlnaHQgPSBnZXRMaW5laGVpZ2h0KGVsKTtcbiAgICAgICAgICAgIHZhciB0YWd3aWR0aCA9ICQoZWwpLmlubmVyV2lkdGgoKTtcbiAgICAgICAgICAgIHZhciB0YWdoZWlnaHQgPSAkKGVsKS5pbm5lckhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgdmFyIHdsID0gd29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHcgPSAnJztcbiAgICAgICAgICAgIHZhciBicmVha3MgPSBbXTtcbiAgICAgICAgICAgIHZhciB0ZW1wdG9wID0gdG9wO1xuICAgICAgICAgICAgdmFyIHRlbXBsZWZ0ID0gbGVmdDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHdsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3ICs9IHdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1lYXN1cmVUZXh0KHcpLndpZHRoID4gdGFnd2lkdGggJiYgdy5sZW5ndGggPiB3b3Jkc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmVha3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2VudGVyIHRleHQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKCQoZWwpLmNzcygndGV4dEFsaWduJykgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsZWZ0ID0gbGVmdCArIChjYW52YXNXaWR0aCAtIGNvbnRleHQubWVhc3VyZVRleHQodykud2lkdGgpLzIgIC0gdHJhbnN4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRlbXBsZWZ0LCB0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IHdvcmRzLnNsaWNlKDAsIGJyZWFrc1swXSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRlciB0ZXh0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmICgkKGVsKS5jc3MoJ3RleHRBbGlnbicpID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGVmdCA9IGxlZnQgKyAoY2FudmFzV2lkdGggLSBjb250ZXh0Lm1lYXN1cmVUZXh0KHcpLndpZHRoKS8yICAtIHRyYW5zeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dCh3LCB0ZW1wbGVmdCwgdGVtcHRvcCk7XG4gICAgICAgICAgICAgICAgdGVtcHRvcCArPSBsaW5laGVpZ2h0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MSwgbD1icmVha3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB3ID0gd29yZHMuc2xpY2UoYnJlYWtzW2ktMV0sIGJyZWFrc1tpXSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjZW50ZXIgdGV4dCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoZWwpLmNzcygndGV4dEFsaWduJykgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGVmdCA9IGxlZnQgKyAoY2FudmFzV2lkdGggLSBjb250ZXh0Lm1lYXN1cmVUZXh0KHcpLndpZHRoKS8yICAtIHRyYW5zeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHcsIHRlbXBsZWZ0LCB0ZW1wdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcHRvcCArPSBsaW5laGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ID0gd29yZHMuc2xpY2UoYnJlYWtzW2ktMV0sIHdvcmRzLmxlbmd0aCkuam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRlciB0ZXh0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmICgkKGVsKS5jc3MoJ3RleHRBbGlnbicpID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGVmdCA9IGxlZnQgKyAoY2FudmFzV2lkdGggLSBjb250ZXh0Lm1lYXN1cmVUZXh0KHcpLndpZHRoKS8yICAtIHRyYW5zeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dCh3LCB0ZW1wbGVmdCwgdGVtcHRvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9qcXBUb0ltYWdlKGVsLCB4X29mZnNldCwgeV9vZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciB0YWduYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIHAgPSAkKGVsKS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBcIlwiKSA6IGVsLmN1cnJlbnRTdHlsZTsgLy8gZm9yIElFIDwgOVxuICAgICAgICAgICAgdmFyIGxlZnQgPSB4X29mZnNldCArIHAubGVmdCArIHBhcnNlSW50KGNzcy5tYXJnaW5MZWZ0LCAxMCkgKyBwYXJzZUludChjc3MuYm9yZGVyTGVmdFdpZHRoLCAxMCkgKyBwYXJzZUludChjc3MucGFkZGluZ0xlZnQsIDEwKTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB5X29mZnNldCArIHAudG9wICsgcGFyc2VJbnQoY3NzLm1hcmdpblRvcCwgMTApICsgcGFyc2VJbnQoY3NzLmJvcmRlclRvcFdpZHRoLCAxMCkrIHBhcnNlSW50KGNzcy5wYWRkaW5nVG9wLCAxMCk7XG4gICAgICAgICAgICB2YXIgdyA9IG5ld0NhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIC8vIHZhciBsZWZ0ID0geF9vZmZzZXQgKyBwLmxlZnQgKyAkKGVsKS5jc3MoJ21hcmdpbkxlZnQnKSArICQoZWwpLmNzcygnYm9yZGVyTGVmdFdpZHRoJykgXG5cbiAgICAgICAgICAgIC8vIHNvbWVob3cgaW4gaGVyZSwgZm9yIGRpdnMgd2l0aGluIGRpdnMsIHRoZSB3aWR0aCBvZiB0aGUgaW5uZXIgZGl2IHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGNhbnZhcy5cblxuICAgICAgICAgICAgaWYgKCh0YWduYW1lID09ICdkaXYnIHx8IHRhZ25hbWUgPT0gJ3NwYW4nKSAmJiAhJChlbCkuaGFzQ2xhc3MoJ2pxcGxvdC1oaWdobGlnaHRlci10b29sdGlwJykgJiYgISQoZWwpLmhhc0NsYXNzKCdqcXBsb3QtY2FudmFzT3ZlcmxheS10b29sdGlwJykpIHtcbiAgICAgICAgICAgICAgICAkKGVsKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qcXBUb0ltYWdlKHRoaXMsIGxlZnQsIHRvcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAkKGVsKS5qcXBsb3RDaGlsZFRleHQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuZm9udCA9ICQoZWwpLmpxcGxvdEdldENvbXB1dGVkRm9udFN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuZmlsbFN0eWxlID0gJChlbCkuY3NzKCdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV3JhcHBlZFRleHQoZWwsIG5ld0NvbnRleHQsIHRleHQsIGxlZnQsIHRvcCwgdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN0YW5kYXJkIHRhYmxlIGxlZ2VuZFxuXG4gICAgICAgICAgICBlbHNlIGlmICh0YWduYW1lID09PSAndGFibGUnICYmICQoZWwpLmhhc0NsYXNzKCdqcXBsb3QtdGFibGUtbGVnZW5kJykpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnN0cm9rZVN0eWxlID0gJChlbCkuY3NzKCdib3JkZXItdG9wLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgbmV3Q29udGV4dC5maWxsU3R5bGUgPSAkKGVsKS5jc3MoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmZpbGxSZWN0KGxlZnQsIHRvcCwgJChlbCkuaW5uZXJXaWR0aCgpLCAkKGVsKS5pbm5lckhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoJChlbCkuY3NzKCdib3JkZXItdG9wLXdpZHRoJyksIDEwKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgJChlbCkuaW5uZXJXaWR0aCgpLCAkKGVsKS5pbm5lckhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFsbCB0aGUgc3dhdGNoZXNcbiAgICAgICAgICAgICAgICAkKGVsKS5maW5kKCdkaXYuanFwbG90LXRhYmxlLWxlZ2VuZC1zd2F0Y2gtb3V0bGluZScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZmlyc3QgZGl2IGFuZCBzdHJva2UgaXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnN0cm9rZVN0eWxlID0gZWxlbS5jc3MoJ2JvcmRlci10b3AtY29sb3InKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBsZWZ0ICsgZWxlbS5wb3NpdGlvbigpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdG9wICsgZWxlbS5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5zdHJva2VSZWN0KGwsIHQsIGVsZW0uaW5uZXJXaWR0aCgpLCBlbGVtLmlubmVySGVpZ2h0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyBmaWxsIHRoZSBzd2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGwgKz0gcGFyc2VJbnQoZWxlbS5jc3MoJ3BhZGRpbmctbGVmdCcpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHQgKz0gcGFyc2VJbnQoZWxlbS5jc3MoJ3BhZGRpbmctdG9wJyksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBlbGVtLmlubmVySGVpZ2h0KCkgLSAyICogcGFyc2VJbnQoZWxlbS5jc3MoJ3BhZGRpbmctdG9wJyksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBlbGVtLmlubmVyV2lkdGgoKSAtIDIgKiBwYXJzZUludChlbGVtLmNzcygncGFkZGluZy1sZWZ0JyksIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3dhdGNoID0gZWxlbS5jaGlsZHJlbignZGl2LmpxcGxvdC10YWJsZS1sZWdlbmQtc3dhdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuZmlsbFN0eWxlID0gc3dhdGNoLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmZpbGxSZWN0KGwsIHQsIHcsIGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbm93IGFkZCB0ZXh0XG5cbiAgICAgICAgICAgICAgICAkKGVsKS5maW5kKCd0ZC5qcXBsb3QtdGFibGUtbGVnZW5kLWxhYmVsJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gbGVmdCArIGVsZW0ucG9zaXRpb24oKS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRvcCArIGVsZW0ucG9zaXRpb24oKS50b3AgKyBwYXJzZUludChlbGVtLmNzcygncGFkZGluZy10b3AnKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmZvbnQgPSBlbGVtLmpxcGxvdEdldENvbXB1dGVkRm9udFN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuZmlsbFN0eWxlID0gZWxlbS5jc3MoJ2NvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV3JhcHBlZFRleHQoZWxlbSwgbmV3Q29udGV4dCwgZWxlbS50ZXh0KCksIGwsIHQsIHcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmICh0YWduYW1lID09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGV4dC5kcmF3SW1hZ2UoZWwsIGxlZnQsIHRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfanFwVG9JbWFnZSh0aGlzLCB4X29mZnNldCwgeV9vZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0NhbnZhcztcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJuIHRoZSByYXcgaW1hZ2UgZGF0YSBzdHJpbmcuXG4gICAgLy8gU2hvdWxkIHdvcmsgb24gY2FudmFzIHN1cHBvcnRpbmcgYnJvd3NlcnMuXG4gICAgJC5mbi5qcXBsb3RUb0ltYWdlU3RyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgaW1nQ2FudmFzID0gJCh0aGlzKS5qcXBsb3RUb0ltYWdlQ2FudmFzKG9wdGlvbnMpO1xuICAgICAgICBpZiAoaW1nQ2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1nQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJldHVybiBhIERPTSA8aW1nPiBlbGVtZW50IGFuZCByZXR1cm4gaXQuXG4gICAgLy8gU2hvdWxkIHdvcmsgb24gY2FudmFzIHN1cHBvcnRpbmcgYnJvd3NlcnMuXG4gICAgJC5mbi5qcXBsb3RUb0ltYWdlRWxlbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICB2YXIgc3RyID0gJCh0aGlzKS5qcXBsb3RUb0ltYWdlU3RyKG9wdGlvbnMpO1xuICAgICAgICBlbGVtLnNyYyA9IHN0cjtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfTtcblxuICAgIC8vIHJldHVybiBhIHN0cmluZyBmb3IgYW4gPGltZz4gZWxlbWVudCBhbmQgcmV0dXJuIGl0LlxuICAgIC8vIFNob3VsZCB3b3JrIG9uIGNhbnZhcyBzdXBwb3J0aW5nIGJyb3dzZXJzLlxuICAgICQuZm4uanFwbG90VG9JbWFnZUVsZW1TdHIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdHIgPSAnPGltZyBzcmM9JyskKHRoaXMpLmpxcGxvdFRvSW1hZ2VTdHIob3B0aW9ucykrJyAvPic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8vIE5vdCBndWFyYW50ZWVkIHRvIHdvcmssIGV2ZW4gb24gY2FudmFzIHN1cHBvcnRpbmcgYnJvd3NlcnMgZHVlIHRvIFxuICAgIC8vIGxpbWl0YXRpb25zIHdpdGggbG9jYXRpb24uaHJlZiBhbmQgYnJvd3NlciBzdXBwb3J0LlxuICAgICQuZm4uanFwbG90U2F2ZUltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbWdEYXRhID0gJCh0aGlzKS5qcXBsb3RUb0ltYWdlU3RyKHt9KTtcbiAgICAgICAgaWYgKGltZ0RhdGEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaW1nRGF0YS5yZXBsYWNlKFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2Uvb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gTm90IGd1YXJhbnRlZWQgdG8gd29yaywgZXZlbiBvbiBjYW52YXMgc3VwcG9ydGluZyBicm93c2VycyBkdWUgdG9cbiAgICAvLyBsaW1pdGF0aW9ucyB3aXRoIHdpbmRvdy5vcGVuIGFuZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAkLmZuLmpxcGxvdFZpZXdJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW1nU3RyID0gJCh0aGlzKS5qcXBsb3RUb0ltYWdlRWxlbVN0cih7fSk7XG4gICAgICAgIHZhciBpbWdEYXRhID0gJCh0aGlzKS5qcXBsb3RUb0ltYWdlU3RyKHt9KTtcbiAgICAgICAgaWYgKGltZ1N0cikge1xuICAgICAgICAgICAgdmFyIHcgPSB3aW5kb3cub3BlbignJyk7XG4gICAgICAgICAgICB3LmRvY3VtZW50Lm9wZW4oXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICB3LmRvY3VtZW50LndyaXRlKGltZ1N0cik7XG4gICAgICAgICAgICB3LmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgICAgICB3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG5cblxuXG4gICAgLyoqIFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxwPk9iamVjdCB3aXRoIGV4dGVuZGVkIGRhdGUgcGFyc2luZyBhbmQgZm9ybWF0dGluZyBjYXBhYmlsaXRpZXMuXG4gICAgICogVGhpcyBsaWJyYXJ5IGJvcnJvd3MgbWFueSBjb25jZXB0cyBhbmQgaWRlYXMgZnJvbSB0aGUgRGF0ZSBJbnN0YW5jZSBcbiAgICAgKiBNZXRob2RzIGJ5IEtlbiBTbnlkZXIgYWxvbmcgd2l0aCBzb21lIHBhcnRzIG9mIEtlbidzIGFjdHVhbCBjb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPmpzRGF0ZSB0YWtlcyBhIGRpZmZlcmVudCBhcHByb2FjaCBieSBub3QgZXh0ZW5kaW5nIHRoZSBidWlsdC1pbiBcbiAgICAgKiBEYXRlIE9iamVjdCwgaW1wcm92aW5nIGRhdGUgcGFyc2luZywgYWxsb3dpbmcgZm9yIG11bHRpcGxlIGZvcm1hdHRpbmcgXG4gICAgICogc3ludGF4ZXMgYW5kIG11bHRpcGxlIGFuZCBtb3JlIGVhc2lseSBleHBhbmRhYmxlIGxvY2FsaXphdGlvbi48L3A+XG4gICAgICogXG4gICAgICogQGF1dGhvciBDaHJpcyBMZW9uZWxsb1xuICAgICAqIEBkYXRlICNkYXRlI1xuICAgICAqIEB2ZXJzaW9uICNWRVJTSU9OI1xuICAgICAqIEBjb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBDaHJpcyBMZW9uZWxsb1xuICAgICAqIGpzRGF0ZSBpcyBjdXJyZW50bHkgYXZhaWxhYmxlIGZvciB1c2UgaW4gYWxsIHBlcnNvbmFsIG9yIGNvbW1lcmNpYWwgcHJvamVjdHMgXG4gICAgICogdW5kZXIgYm90aCB0aGUgTUlUIGFuZCBHUEwgdmVyc2lvbiAyLjAgbGljZW5zZXMuIFRoaXMgbWVhbnMgdGhhdCB5b3UgY2FuIFxuICAgICAqIGNob29zZSB0aGUgbGljZW5zZSB0aGF0IGJlc3Qgc3VpdHMgeW91ciBwcm9qZWN0IGFuZCB1c2UgaXQgYWNjb3JkaW5nbHkuXG4gICAgICogXG4gICAgICogPHA+S2VuJ3Mgb3JpZ2luYWwgRGF0ZSBJbnN0YW5jZSBNZXRob2RzIGFuZCBjb3B5cmlnaHQgbm90aWNlOjwvcD5cbiAgICAgKiA8cHJlPlxuICAgICAqIEtlbiBTbnlkZXIgKGtlbiBkIHNueWRlciBhdCBnbWFpbCBkb3QgY29tKVxuICAgICAqIDIwMDgtMDktMTBcbiAgICAgKiB2ZXJzaW9uIDIuMC4yIChodHRwOi8va2VuZHNueWRlci5jb20vc2FuZGJveC9kYXRlLykgICAgIFxuICAgICAqIENyZWF0aXZlIENvbW1vbnMgQXR0cmlidXRpb24gTGljZW5zZSAzLjAgKGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzMuMC8pXG4gICAgICogPC9wcmU+XG4gICAgICogXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUganNEYXRlXG4gICAgICogQHBhcmFtICB7U3RyaW5nIHwgTnVtYmVyIHwgQXJyYXkgfCBEYXRlJm5ic3A7T2JqZWN0IHwgT3B0aW9ucyZuYnNwO09iamVjdH0gYXJndW1lbnRzIE9wdGlvbmFsIGFyZ3VtZW50cywgZWl0aGVyIGEgcGFyc2FibGUgZGF0ZS90aW1lIHN0cmluZyxcbiAgICAgKiBhIEphdmFTY3JpcHQgdGltZXN0YW1wLCBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGZvcm0gW3llYXIsIG1vbnRoLCBkYXksIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHNdLFxuICAgICAqIGEgRGF0ZSBvYmplY3QsIG9yIGFuIG9wdGlvbnMgb2JqZWN0IG9mIGZvcm0ge3N5bnRheDogXCJwZXJsXCIsIGRhdGU6c29tZSBEYXRlfSB3aGVyZSBhbGwgb3B0aW9ucyBhcmUgb3B0aW9uYWwuXG4gICAgICovXG4gICAgIFxuICAgIHZhciBqc0RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgICAgIHRoaXMuc3ludGF4ID0ganNEYXRlLmNvbmZpZy5zeW50YXg7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBcImpzRGF0ZVwiO1xuICAgICAgICB0aGlzLnByb3h5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMubG9jYWxlID0ganNEYXRlLnJlZ2lvbmFsLmdldExvY2FsZSgpO1xuICAgICAgICB0aGlzLmZvcm1hdFN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLmRlZmF1bHRDZW50dXJ5ID0ganNEYXRlLmNvbmZpZy5kZWZhdWx0Q2VudHVyeTtcblxuICAgICAgICBzd2l0Y2ggKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIG90aGVyIG9iamVjdHMgZWl0aGVyIHdvbid0IGhhdmUgYSBfdHlwZSBwcm9wZXJ0eSBvcixcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IGRvLCBpdCBzaG91bGRuJ3QgYmUgc2V0IHRvIFwianNEYXRlXCIsIHNvXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGFuIG9wdGlvbnMgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKGdldF90eXBlKGFyZ3VtZW50c1swXSkgPT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiBhcmd1bWVudHNbMF0uX3R5cGUgIT0gXCJqc0RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW50YXggPSBvcHRzLnN5bnRheCB8fCB0aGlzLnN5bnRheDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0Q2VudHVyeSA9IG9wdHMuZGVmYXVsdENlbnR1cnkgfHwgdGhpcy5kZWZhdWx0Q2VudHVyeTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm94eSA9IGpzRGF0ZS5jcmVhdGVEYXRlKG9wdHMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3h5ID0ganNEYXRlLmNyZWF0ZURhdGUoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSB0aGUgY3VycmVudCBkYXRlL3RpbWU/XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eS5zZXRGdWxsWWVhci5hcHBseSggdGhpcy5wcm94eSwgYS5zbGljZSgwLDMpICk7XG4gICAgICAgICAgICAgICAgaWYgKCBhLnNsaWNlKDMpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm94eS5zZXRIb3Vycy5hcHBseSggdGhpcy5wcm94eSwgYS5zbGljZSgzKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgb24gdGhlIHBhZ2UuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRMb2NhbGUgVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSBbZW5dLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW50YXggVGhlIGRlZmF1bHQgc3ludGF4IHRvIHVzZSBbcGVybF0uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRDZW50dXJ5IFRoZSBkZWZhdWx0IGNlbnRyeSBmb3IgMiBkaWdpdCBkYXRlcy5cbiAgICAgKi9cbiAgICBqc0RhdGUuY29uZmlnID0ge1xuICAgICAgICBkZWZhdWx0TG9jYWxlOiAnZW4nLFxuICAgICAgICBzeW50YXg6ICdwZXJsJyxcbiAgICAgICAgZGVmYXVsdENlbnR1cnk6IDE5MDBcbiAgICB9O1xuICAgICAgICBcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJiaXRyYXJ5IGFtb3VudCB0byB0aGUgY3VycmVudGx5IHN0b3JlZCBkYXRlXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bml0XG4gICAgICogQHJldHVybnMge2pzRGF0ZX0gICAgICAgXG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSBtdWx0aXBsaWVyc1t1bml0XSB8fCBtdWx0aXBsaWVycy5kYXk7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5LnNldFRpbWUodGhpcy5wcm94eS5nZXRUaW1lKCkgKyAoZmFjdG9yICogbnVtYmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWN0b3IuYWRkKHRoaXMsIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAgICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGpxcGxvdC5kYXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIGRhdGVcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7anNEYXRlfVxuICAgICAqLyAgXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcganNEYXRlKHRoaXMucHJveHkuZ2V0VGltZSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVVEMgVGltZVpvbmUgT2Zmc2V0IG9mIHRoaXMgZGF0ZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRVdGNPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBqc0RhdGUgYW5kIGFub3RoZXIgZGF0ZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3wgTnVtYmVyfCBBcnJheXwganNEYXRlJm5ic3A7T2JqZWN0fCBEYXRlJm5ic3A7T2JqZWN0fSBkYXRlT2JqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVuaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RGVjaW1hbFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiB1bml0cyBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXMuXG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uKGRhdGVPYmosIHVuaXQsIGFsbG93RGVjaW1hbCkge1xuICAgICAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhIERhdGUgb2JqZWN0XG4gICAgICAgIGRhdGVPYmogPSBuZXcganNEYXRlKGRhdGVPYmopO1xuICAgICAgICBpZiAoZGF0ZU9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHRoZSBtdWx0aXBseWluZyBmYWN0b3IgaW50ZWdlciBvciBmYWN0b3IgZnVuY3Rpb25cbiAgICAgICAgdmFyIGZhY3RvciA9IG11bHRpcGxpZXJzW3VuaXRdIHx8IG11bHRpcGxpZXJzLmRheTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG11bHRpcGx5XG4gICAgICAgICAgICB2YXIgdW5pdERpZmYgPSAodGhpcy5wcm94eS5nZXRUaW1lKCkgLSBkYXRlT2JqLnByb3h5LmdldFRpbWUoKSkgLyBmYWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciB1bml0RGlmZiA9IGZhY3Rvci5kaWZmKHRoaXMucHJveHksIGRhdGVPYmoucHJveHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGRlY2ltYWxzIGFyZSBub3QgYWxsb3dlZCwgcm91bmQgdG93YXJkIHplcm9cbiAgICAgICAgcmV0dXJuIChhbGxvd0RlY2ltYWwgPyB1bml0RGlmZiA6IE1hdGhbdW5pdERpZmYgPiAwID8gJ2Zsb29yJyA6ICdjZWlsJ10odW5pdERpZmYpKTsgICAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFiYnJldmlhdGVkIG5hbWUgb2YgdGhlIGN1cnJlbnQgd2VlayBkYXlcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqLyAgIFxuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLmdldEFiYnJEYXlOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBqc0RhdGUucmVnaW9uYWxbdGhpcy5sb2NhbGVdW1wiZGF5TmFtZXNTaG9ydFwiXVt0aGlzLnByb3h5LmdldERheSgpXTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWJicmV2aWF0ZWQgbmFtZSBvZiB0aGUgY3VycmVudCBtb250aFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0QWJick1vbnRoTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ganNEYXRlLnJlZ2lvbmFsW3RoaXMubG9jYWxlXVtcIm1vbnRoTmFtZXNTaG9ydFwiXVt0aGlzLnByb3h5LmdldE1vbnRoKCldO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IFVQUEVSIENBU0UgQU0gb3IgUE0gZm9yIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLmdldEFNUE0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IGxvd2VyIGNhc2UgYW0gb3IgcG0gZm9yIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLmdldEFtUG0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0SG91cnMoKSA+PSAxMiA/ICdwbScgOiAnYW0nO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjZW50dXJ5ICgxOSBmb3IgMjB0aCBDZW50dXJ5KVxuICAgICAqXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IENlbnR1cnkgKDE5IGZvciAyMHRoIGNlbnR1cnkpLlxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0Q2VudHVyeSA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMucHJveHkuZ2V0RnVsbFllYXIoKS8xMDAsIDEwKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LmdldERhdGUoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXREYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0RGF5KCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERheSBvZiB3ZWVrIDEgKE1vbmRheSkgdGhydSA3IChTdW5kYXkpXG4gICAgICogXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9IERheSBvZiB3ZWVrIDEgKE1vbmRheSkgdGhydSA3IChTdW5kYXkpXG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXREYXlPZldlZWsgPSBmdW5jdGlvbigpIHsgXG4gICAgICAgIHZhciBkb3cgPSB0aGlzLnByb3h5LmdldERheSgpOyBcbiAgICAgICAgcmV0dXJuIGRvdz09PTA/Nzpkb3c7IFxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHllYXJcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn0gMSAtIDM2NiwgZGF5IG9mIHRoZSB5ZWFyXG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXREYXlPZlllYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLnByb3h5O1xuICAgICAgICB2YXIgbXMgPSBkIC0gbmV3IERhdGUoJycgKyBkLmdldEZ1bGxZZWFyKCkgKyAnLzEvMSBHTVQnKTtcbiAgICAgICAgbXMgKz0gZC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwO1xuICAgICAgICBkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1zLzYwMDAwLzYwLzI0LCAxMCkrMTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCB3ZWVrIGRheVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovICBcbiAgICAgXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXREYXlOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBqc0RhdGUucmVnaW9uYWxbdGhpcy5sb2NhbGVdW1wiZGF5TmFtZXNcIl1bdGhpcy5wcm94eS5nZXREYXkoKV07XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSBnaXZlbiB5ZWFyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdCBTdW5kYXkgYXMgdGhlIGZpcnN0IHdlZWtcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn0gV2VlayBudW1iZXIgKDEzIGZvciB0aGUgMTN0aCBmdWxsIHdlZWsgb2YgdGhlIHllYXIpLlxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFdlZWtPZlllYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLnByb3h5O1xuICAgICAgICB2YXIgZG95ID0gdGhpcy5nZXREYXlPZlllYXIoKTtcbiAgICAgICAgdmFyIHJkb3cgPSA2LWQuZ2V0RGF5KCk7XG4gICAgICAgIHZhciB3b3kgPSBwYXJzZUludCgoZG95K3Jkb3cpLzcsIDEwKTtcbiAgICAgICAgcmV0dXJuIHdveTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRGdWxsWWVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5nZXRGdWxsWWVhcigpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBHTVQgb2Zmc2V0IGluIGhvdXJzIGFuZCBtaW51dGVzIChlLmcuICswNjozMClcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLmdldEdtdE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBkaXZpZGUgdGhlIG1pbnV0ZXMgb2Zmc2V0IGJ5IDYwXG4gICAgICAgIHZhciBob3VycyA9IHRoaXMucHJveHkuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwO1xuICAgICAgICAvLyBkZWNpZGUgaWYgd2UgYXJlIGFoZWFkIG9mIG9yIGJlaGluZCBHTVRcbiAgICAgICAgdmFyIHByZWZpeCA9IGhvdXJzIDwgMCA/ICcrJyA6ICctJztcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGlmIGFueVxuICAgICAgICBob3VycyA9IE1hdGguYWJzKGhvdXJzKTtcbiAgICAgICAgLy8gYWRkIHRoZSArLy0gdG8gdGhlIHBhZGRlZCBudW1iZXIgb2YgaG91cnMgdG8gOiB0byB0aGUgcGFkZGVkIG1pbnV0ZXNcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIGFkZFplcm9zKE1hdGguZmxvb3IoaG91cnMpLCAyKSArICc6JyArIGFkZFplcm9zKChob3VycyAlIDEpICogNjAsIDIpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBEYXRlIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICBqc0RhdGUucHJvdG90eXBlLmdldEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LmdldEhvdXJzKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgaG91ciBvbiBhIDEyLWhvdXIgc2NoZW1lXG4gICAgICogXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnMxMiAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhvdXJzID0gdGhpcy5wcm94eS5nZXRIb3VycygpO1xuICAgICAgICByZXR1cm4gaG91cnMgPiAxMiA/IGhvdXJzIC0gMTIgOiAoaG91cnMgPT0gMCA/IDEyIDogaG91cnMpO1xuICAgIH07XG4gICAgXG4gICAgXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRJc29XZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5wcm94eTtcbiAgICAgICAgdmFyIHdveSA9IHRoaXMuZ2V0V2Vla09mWWVhcigpO1xuICAgICAgICB2YXIgZG93MV8xID0gKG5ldyBEYXRlKCcnICsgZC5nZXRGdWxsWWVhcigpICsgJy8xLzEnKSkuZ2V0RGF5KCk7XG4gICAgICAgIC8vIEZpcnN0IHdlZWsgaXMgMDEgYW5kIG5vdCAwMCBhcyBpbiB0aGUgY2FzZSBvZiAlVSBhbmQgJVcsXG4gICAgICAgIC8vIHNvIHdlIGFkZCAxIHRvIHRoZSBmaW5hbCByZXN1bHQgZXhjZXB0IGlmIGRheSAxIG9mIHRoZSB5ZWFyXG4gICAgICAgIC8vIGlzIGEgTW9uZGF5ICh0aGVuICVXIHJldHVybnMgMDEpLlxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc3VidHJhY3QgMSBpZiB0aGUgZGF5IDEgb2YgdGhlIHllYXIgaXMgXG4gICAgICAgIC8vIEZyaWRheS1TdW5kYXksIHNvIHRoZSByZXN1bHRpbmcgZXF1YXRpb24gYmVjb21lczpcbiAgICAgICAgdmFyIGlkb3cgPSB3b3kgKyAoZG93MV8xID4gNCB8fCBkb3cxXzEgPD0gMSA/IDAgOiAxKTtcbiAgICAgICAgaWYoaWRvdyA9PSA1MyAmJiAobmV3IERhdGUoJycgKyBkLmdldEZ1bGxZZWFyKCkgKyAnLzEyLzMxJykpLmdldERheSgpIDwgNClcbiAgICAgICAge1xuICAgICAgICAgICAgaWRvdyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpZG93ID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBkID0gbmV3IGpzRGF0ZShuZXcgRGF0ZSgnJyArIChkLmdldEZ1bGxZZWFyKCktMSkgKyAnLzEyLzMxJykpO1xuICAgICAgICAgICAgaWRvdyA9IGQuZ2V0SXNvV2VlaygpO1xuICAgICAgICB9XG4gICAgICAgIGQgPSBudWxsO1xuICAgICAgICByZXR1cm4gaWRvdztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRNaWxsaXNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5nZXRNaW51dGVzKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0TW9udGgoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBtb250aFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0TW9udGhOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBqc0RhdGUucmVnaW9uYWxbdGhpcy5sb2NhbGVdW1wibW9udGhOYW1lc1wiXVt0aGlzLnByb3h5LmdldE1vbnRoKCldO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgbW9udGgsIDEtMTJcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICAgXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRNb250aE51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5nZXRNb250aCgpICsgMTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRTZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LmdldFNlY29uZHMoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHByb3BlciB0d28tZGlnaXQgeWVhciBpbnRlZ2VyXG4gICAgICogXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0U2hvcnRZZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LmdldFllYXIoKSAlIDEwMDtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LmdldFRpbWUoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGltZXpvbmUgYWJicmV2aWF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBYmJyZXZpYXRpb24gZm9yIHRoZSB0aW1lem9uZVxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0VGltZXpvbmVBYmJyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LnRvU3RyaW5nKCkucmVwbGFjZSgvXi4qXFwoKFteKV0rKVxcKSQvLCAnJDEnKTsgXG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJyb3dzZXItcmVwb3J0ZWQgbmFtZSBmb3IgdGhlIGN1cnJlbnQgdGltZXpvbmUgKGUuZy4gTURULCBNb3VudGFpbiBEYXlsaWdodCBUaW1lKVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5nZXRUaW1lem9uZU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gLyg/OlxcKCguKylcXCkkfCAoW0EtWl17M30pICkvLmV4ZWModGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICdHTVQnICsgdGhpcy5nZXRHbXRPZmZzZXQoKTtcbiAgICB9OyBcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0VGltZXpvbmVPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB9O1xuICAgIFxuICAgIFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIGdpdmVuIHllYXIsIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IE1vbmRheSBhcyB0aGUgZmlyc3Qgd2Vla1xuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfSBXZWVrIG51bWJlciAoMTMgZm9yIHRoZSAxM3RoIHdlZWsgb2YgdGhlIHllYXIpLlxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0V2Vla09mWWVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG95ID0gdGhpcy5nZXREYXlPZlllYXIoKTtcbiAgICAgICAgdmFyIHJkb3cgPSA3IC0gdGhpcy5nZXREYXlPZldlZWsoKTtcbiAgICAgICAgdmFyIHdveSA9IHBhcnNlSW50KChkb3krcmRvdykvNywgMTApO1xuICAgICAgICByZXR1cm4gd295O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRhdGUgYXMgYSBVbml4IHRpbWVzdGFtcFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLmdldFVuaXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5wcm94eS5nZXRUaW1lKCkgLyAxMDAwLCAwKTtcbiAgICB9OyBcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5nZXRZZWFyKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBkYXRlIG9uZSBkYXkgYWhlYWQgKG9yIGFueSBvdGhlciB1bml0KVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IE9wdGlvbmFsLCB5ZWFyIHwgbW9udGggfCBkYXkgfCB3ZWVrIHwgaG91ciB8IG1pbnV0ZSB8IHNlY29uZCB8IG1pbGxpc2Vjb25kXG4gICAgICogQHJldHVybnMge2pzRGF0ZX1cbiAgICAgKi9cbiAgICAgXG4gICAganNEYXRlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24odW5pdCkge1xuICAgICAgICB1bml0ID0gdW5pdCB8fCAnZGF5JztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hZGQoMSwgdW5pdCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGpzRGF0ZSBpbnN0YW5jZSB0byBhIG5ldyBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nIHwgTnVtYmVyIHwgQXJyYXkgfCBEYXRlIE9iamVjdCB8IGpzRGF0ZSBPYmplY3QgfCBPcHRpb25zIE9iamVjdH0gYXJndW1lbnRzIE9wdGlvbmFsIGFyZ3VtZW50cywgXG4gICAgICogZWl0aGVyIGEgcGFyc2FibGUgZGF0ZS90aW1lIHN0cmluZyxcbiAgICAgKiBhIEphdmFTY3JpcHQgdGltZXN0YW1wLCBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGZvcm0gW3llYXIsIG1vbnRoLCBkYXksIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHNdLFxuICAgICAqIGEgRGF0ZSBvYmplY3QsIGpzRGF0ZSBPYmplY3Qgb3IgYW4gb3B0aW9ucyBvYmplY3Qgb2YgZm9ybSB7c3ludGF4OiBcInBlcmxcIiwgZGF0ZTpzb21lIERhdGV9IHdoZXJlIGFsbCBvcHRpb25zIGFyZSBvcHRpb25hbC5cbiAgICAgKi9cbiAgICBqc0RhdGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMucHJveHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIG90aGVyIG9iamVjdHMgZWl0aGVyIHdvbid0IGhhdmUgYSBfdHlwZSBwcm9wZXJ0eSBvcixcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IGRvLCBpdCBzaG91bGRuJ3QgYmUgc2V0IHRvIFwianNEYXRlXCIsIHNvXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGFuIG9wdGlvbnMgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKGdldF90eXBlKGFyZ3VtZW50c1swXSkgPT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiBhcmd1bWVudHNbMF0uX3R5cGUgIT0gXCJqc0RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW50YXggPSBvcHRzLnN5bnRheCB8fCB0aGlzLnN5bnRheDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0Q2VudHVyeSA9IG9wdHMuZGVmYXVsdENlbnR1cnkgfHwgdGhpcy5kZWZhdWx0Q2VudHVyeTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm94eSA9IGpzRGF0ZS5jcmVhdGVEYXRlKG9wdHMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3h5ID0ganNEYXRlLmNyZWF0ZURhdGUoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSB0aGUgY3VycmVudCBkYXRlL3RpbWVcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5LnNldEZ1bGxZZWFyLmFwcGx5KCB0aGlzLnByb3h5LCBhLnNsaWNlKDAsMykgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGEuc2xpY2UoMykubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3h5LnNldEhvdXJzLmFwcGx5KCB0aGlzLnByb3h5LCBhLnNsaWNlKDMpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF5IG9mIHRoZSBtb250aCBmb3IgYSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGRheVZhbHVlIEFuIGludGVnZXIgZnJvbSAxIHRvIDMxLCByZXByZXNlbnRpbmcgdGhlIGRheSBvZiB0aGUgbW9udGguIFxuICAgICAqL1xuICAgIGpzRGF0ZS5wcm90b3R5cGUuc2V0RGF0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5wcm94eS5zZXREYXRlKG4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZ1bGwgeWVhciBmb3IgYSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHllYXJWYWx1ZSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiB0aGUgeWVhciwgZm9yIGV4YW1wbGUsIDE5OTUuICBcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1vbnRoVmFsdWUgT3B0aW9uYWwsIGJldHdlZW4gMCBhbmQgMTEgcmVwcmVzZW50aW5nIHRoZSBtb250aHMgSmFudWFyeSB0aHJvdWdoIERlY2VtYmVyLiAgXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkYXlWYWx1ZSBPcHRpb25hbCwgYmV0d2VlbiAxIGFuZCAzMSByZXByZXNlbnRpbmcgdGhlIGRheSBvZiB0aGUgbW9udGguIElmIHlvdSBzcGVjaWZ5IHRoZSBkYXlWYWx1ZSBwYXJhbWV0ZXIsIHlvdSBtdXN0IGFsc28gc3BlY2lmeSB0aGUgbW9udGhWYWx1ZS4gXG4gICAgICovXG4gICAganNEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb3h5LnNldEZ1bGxZZWFyLmFwcGx5KHRoaXMucHJveHksIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaG91cnMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBob3Vyc1ZhbHVlIEFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyMywgcmVwcmVzZW50aW5nIHRoZSBob3VyLiAgXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtaW51dGVzVmFsdWUgT3B0aW9uYWwsIEFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1OSwgcmVwcmVzZW50aW5nIHRoZSBtaW51dGVzLiAgXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzZWNvbmRzVmFsdWUgT3B0aW9uYWwsIEFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1OSwgcmVwcmVzZW50aW5nIHRoZSBzZWNvbmRzLiBcbiAgICAgKiBJZiB5b3Ugc3BlY2lmeSB0aGUgc2Vjb25kc1ZhbHVlIHBhcmFtZXRlciwgeW91IG11c3QgYWxzbyBzcGVjaWZ5IHRoZSBtaW51dGVzVmFsdWUuICBcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1zVmFsdWUgT3B0aW9uYWwsIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5LCByZXByZXNlbnRpbmcgdGhlIG1pbGxpc2Vjb25kcy4gXG4gICAgICogSWYgeW91IHNwZWNpZnkgdGhlIG1zVmFsdWUgcGFyYW1ldGVyLCB5b3UgbXVzdCBhbHNvIHNwZWNpZnkgdGhlIG1pbnV0ZXNWYWx1ZSBhbmQgc2Vjb25kc1ZhbHVlLiBcbiAgICAgKi9cbiAgICBqc0RhdGUucHJvdG90eXBlLnNldEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJveHkuc2V0SG91cnMuYXBwbHkodGhpcy5wcm94eSwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqLyBcbiAgICBqc0RhdGUucHJvdG90eXBlLnNldE1pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5wcm94eS5zZXRNaWxsaXNlY29uZHMobik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBEYXRlIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi8gXG4gICAganNEYXRlLnByb3RvdHlwZS5zZXRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJveHkuc2V0TWludXRlcy5hcHBseSh0aGlzLnByb3h5LCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuc2V0TW9udGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcm94eS5zZXRNb250aC5hcHBseSh0aGlzLnByb3h5LCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgRGF0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovIFxuICAgIGpzRGF0ZS5wcm90b3R5cGUuc2V0U2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb3h5LnNldFNlY29uZHMuYXBwbHkodGhpcy5wcm94eSwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqLyBcbiAgICBqc0RhdGUucHJvdG90eXBlLnNldFRpbWUgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMucHJveHkuc2V0VGltZShuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIERhdGUgZnVuY3Rpb25hbGl0eVxuICAgICAqLyBcbiAgICBqc0RhdGUucHJvdG90eXBlLnNldFllYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcm94eS5zZXRZZWFyLmFwcGx5KHRoaXMucHJveHksIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRTdHJpbmcgQSBmb3JtYXQgc3RyaW5nLiAgXG4gICAgICogU2VlOiB7QGxpbmsganNEYXRlLmZvcm1hdHN9LlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IERhdGUgU3RyaW5nLlxuICAgICAqL1xuICAgICAgICAgICAgXG4gICAganNEYXRlLnByb3RvdHlwZS5zdHJmdGltZSA9IGZ1bmN0aW9uKGZvcm1hdFN0cmluZykge1xuICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcgfHwgdGhpcy5mb3JtYXRTdHJpbmcgfHwganNEYXRlLnJlZ2lvbmFsW3RoaXMubG9jYWxlXVsnZm9ybWF0U3RyaW5nJ107XG4gICAgICAgIHJldHVybiBqc0RhdGUuc3RyZnRpbWUodGhpcywgZm9ybWF0U3RyaW5nLCB0aGlzLnN5bnRheCk7XG4gICAgfTtcbiAgICAgICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMganNEYXRlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBEYXRlIHN0cmluZy5cbiAgICAgKi9cbiAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAgICAgXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY3VycmVudCBkYXRlIHRvIGFuIDgtZGlnaXQgaW50ZWdlciAoJVklbSVkKVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgICBcbiAgICBqc0RhdGUucHJvdG90eXBlLnRvWW1kSW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm94eS5nZXRGdWxsWWVhcigpICogMTAwMDApICsgKHRoaXMuZ2V0TW9udGhOdW1iZXIoKSAqIDEwMCkgKyB0aGlzLnByb3h5LmdldERhdGUoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgSG9sZHMgbG9jYWxpemF0aW9ucyBmb3IgbW9udGgvZGF5IG5hbWVzLlxuICAgICAqIDxwPmpzRGF0ZSBhdHRlbXB0cyB0byBkZXRlY3QgbG9jYWxlIHdoZW4gbG9hZGVkIGFuZCBkZWZhdWx0cyB0byAnZW4nLlxuICAgICAqIElmIGEgbG9jYWxpemF0aW9uIGlzIGRldGVjdGVkIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUsIGpzRGF0ZSBkZWZhdWx0cyB0byAnZW4nLlxuICAgICAqIEFkZGl0aW9uYWwgbG9jYWxpemF0aW9ucyBjYW4gYmUgYWRkZWQgYWZ0ZXIganNEYXRlIGxvYWRzLiAgQWZ0ZXIgYWRkaW5nIGEgbG9jYWxpemF0aW9uLFxuICAgICAqIGNhbGwgdGhlIGpzRGF0ZS5yZWdpb25hbC5nZXRMb2NhbGUoKSBtZXRob2QuICBDdXJyZW50bHksIGVuLCBmciBhbmQgZGUgYXJlIGRlZmluZWQuPC9wPlxuICAgICAqIFxuICAgICAqIDxwPkxvY2FsaXphdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QgYW5kIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGRlZmluZWQ6ICBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGRheU5hbWVzLCBkYXlOYW1lc1Nob3J0IGFuZCBMb2NhbGl6YXRpb25zIGFyZSBhZGRlZCBsaWtlOjwvcD5cbiAgICAgKiA8cHJlIGNsYXNzPVwiY29kZVwiPlxuICAgICAqIGpzRGF0ZS5yZWdpb25hbFsnZW4nXSA9IHtcbiAgICAgKiBtb250aE5hbWVzICAgICAgOiAnSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcicuc3BsaXQoJyAnKSxcbiAgICAgKiBtb250aE5hbWVzU2hvcnQgOiAnSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWMnLnNwbGl0KCcgJyksXG4gICAgICogZGF5TmFtZXMgICAgICAgIDogJ1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5Jy5zcGxpdCgnICcpLFxuICAgICAqIGRheU5hbWVzU2hvcnQgICA6ICdTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXQnLnNwbGl0KCcgJylcbiAgICAgKiB9O1xuICAgICAqIDwvcHJlPlxuICAgICAqIDxwPkFmdGVyIGFkZGluZyBsb2NhbGl6YXRpb25zLCBjYWxsIDxjb2RlPmpzRGF0ZS5yZWdpb25hbC5nZXRMb2NhbGUoKTs8L2NvZGU+IHRvIHVwZGF0ZSB0aGUgbG9jYWxlIHNldHRpbmcgd2l0aCB0aGVcbiAgICAgKiBuZXcgbG9jYWxpemF0aW9ucy48L3A+XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5yZWdpb25hbCA9IHtcbiAgICAgICAgJ2VuJzoge1xuICAgICAgICAgICAgbW9udGhOYW1lczogWydKYW51YXJ5JywnRmVicnVhcnknLCdNYXJjaCcsJ0FwcmlsJywnTWF5JywnSnVuZScsJ0p1bHknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPY3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAnZnInOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ0phbnZpZXInLCdGw6l2cmllcicsJ01hcnMnLCdBdnJpbCcsJ01haScsJ0p1aW4nLCdKdWlsbGV0JywnQW/Du3QnLCdTZXB0ZW1icmUnLCdPY3RvYnJlJywnTm92ZW1icmUnLCdEw6ljZW1icmUnXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGw6l2JywnTWFyJywnQXZyJywnTWFpJywnSnVuJywnSnVsJywnQW/DuycsJ1NlcCcsJ09jdCcsJ05vdicsJ0TDqWMnXSxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ0RpbWFuY2hlJywnTHVuZGknLCdNYXJkaScsJ01lcmNyZWRpJywnSmV1ZGknLCdWZW5kcmVkaScsJ1NhbWVkaSddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydEaW0nLCdMdW4nLCdNYXInLCdNZXInLCdKZXUnLCdWZW4nLCdTYW0nXSxcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZzogJyVZLSVtLSVkICVIOiVNOiVTJ1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgJ2RlJzoge1xuICAgICAgICAgICAgbW9udGhOYW1lczogWydKYW51YXInLCdGZWJydWFyJywnTcOkcnonLCdBcHJpbCcsJ01haScsJ0p1bmknLCdKdWxpJywnQXVndXN0JywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGV6ZW1iZXInXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNw6RyJywnQXByJywnTWFpJywnSnVuJywnSnVsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGV6J10sXG4gICAgICAgICAgICBkYXlOYW1lczogWydTb25udGFnJywnTW9udGFnJywnRGllbnN0YWcnLCdNaXR0d29jaCcsJ0Rvbm5lcnN0YWcnLCdGcmVpdGFnJywnU2Ftc3RhZyddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydTbycsJ01vJywnRGknLCdNaScsJ0RvJywnRnInLCdTYSddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAnZXMnOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ0VuZXJvJywnRmVicmVybycsJ01hcnpvJywnQWJyaWwnLCdNYXlvJywnSnVuaW8nLCAnSnVsaW8nLCdBZ29zdG8nLCdTZXB0aWVtYnJlJywnT2N0dWJyZScsJ05vdmllbWJyZScsJ0RpY2llbWJyZSddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0VuZScsJ0ZlYicsJ01hcicsJ0FicicsJ01heScsJ0p1bicsICdKdWwnLCdBZ28nLCdTZXAnLCdPY3QnLCdOb3YnLCdEaWMnXSxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ0RvbWluZ28nLCdMdW5lcycsJ01hcnRlcycsJ01pJmVhY3V0ZTtyY29sZXMnLCdKdWV2ZXMnLCdWaWVybmVzJywnUyZhYWN1dGU7YmFkbyddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydEb20nLCdMdW4nLCdNYXInLCdNaSZlYWN1dGU7JywnSnV2JywnVmllJywnUyZhYWN1dGU7YiddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAncnUnOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ9Cv0L3QstCw0YDRjCcsJ9Ck0LXQstGA0LDQu9GMJywn0JzQsNGA0YInLCfQkNC/0YDQtdC70YwnLCfQnNCw0LknLCfQmNGO0L3RjCcsJ9CY0Y7Qu9GMJywn0JDQstCz0YPRgdGCJywn0KHQtdC90YLRj9Cx0YDRjCcsJ9Ce0LrRgtGP0LHRgNGMJywn0J3QvtGP0LHRgNGMJywn0JTQtdC60LDQsdGA0YwnXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWyfQr9C90LInLCfQpNC10LInLCfQnNCw0YAnLCfQkNC/0YAnLCfQnNCw0LknLCfQmNGO0L0nLCfQmNGO0LsnLCfQkNCy0LMnLCfQodC10L0nLCfQntC60YInLCfQndC+0Y8nLCfQlNC10LonXSxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ9Cy0L7RgdC60YDQtdGB0LXQvdGM0LUnLCfQv9C+0L3QtdC00LXQu9GM0L3QuNC6Jywn0LLRgtC+0YDQvdC40LonLCfRgdGA0LXQtNCwJywn0YfQtdGC0LLQtdGA0LMnLCfQv9GP0YLQvdC40YbQsCcsJ9GB0YPQsdCx0L7RgtCwJ10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ9Cy0YHQuicsJ9C/0L3QtCcsJ9Cy0YLRgCcsJ9GB0YDQtCcsJ9GH0YLQsicsJ9C/0YLQvScsJ9GB0LHRgiddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAnYXInOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ9mD2KfZhtmI2YYg2KfZhNir2KfZhtmKJywgJ9i02KjYp9i3JywgJ9ii2LDYp9ixJywgJ9mG2YrYs9in2YYnLCAn2KLYsNin2LEnLCAn2K3YstmK2LHYp9mGJywn2KrZhdmI2LInLCAn2KLYqCcsICfYo9mK2YTZiNmEJywgICAn2KrYtNix2YrZhiDYp9mE2KPZiNmEJywgJ9iq2LTYsdmK2YYg2KfZhNir2KfZhtmKJywgJ9mD2KfZhtmI2YYg2KfZhNij2YjZhCddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzcnLCc4JywnOScsJzEwJywnMTEnLCcxMiddLFxuICAgICAgICAgICAgZGF5TmFtZXM6IFsn2KfZhNiz2KjYqicsICfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJ10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ9iz2KjYqicsICfYo9it2K8nLCAn2KfYq9mG2YrZhicsICfYq9mE2KfYq9in2KEnLCAn2KPYsdio2LnYp9ihJywgJ9iu2YXZitizJywgJ9is2YXYudipJ10sXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmc6ICclWS0lbS0lZCAlSDolTTolUydcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICdwdCc6IHtcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsnSmFuZWlybycsJ0ZldmVyZWlybycsJ01hciZjY2VkaWw7bycsJ0FicmlsJywnTWFpbycsJ0p1bmhvJywnSnVsaG8nLCdBZ29zdG8nLCdTZXRlbWJybycsJ091dHVicm8nLCdOb3ZlbWJybycsJ0RlemVtYnJvJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmV2JywnTWFyJywnQWJyJywnTWFpJywnSnVuJywnSnVsJywnQWdvJywnU2V0JywnT3V0JywnTm92JywnRGV6J10sXG4gICAgICAgICAgICBkYXlOYW1lczogWydEb21pbmdvJywnU2VndW5kYS1mZWlyYScsJ1RlciZjY2VkaWw7YS1mZWlyYScsJ1F1YXJ0YS1mZWlyYScsJ1F1aW50YS1mZWlyYScsJ1NleHRhLWZlaXJhJywnUyZhYWN1dGU7YmFkbyddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydEb20nLCdTZWcnLCdUZXInLCdRdWEnLCdRdWknLCdTZXgnLCdTJmFhY3V0ZTtiJ10sXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmc6ICclWS0lbS0lZCAlSDolTTolUycgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICdwdC1CUic6IHtcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsnSmFuZWlybycsJ0ZldmVyZWlybycsJ01hciZjY2VkaWw7bycsJ0FicmlsJywnTWFpbycsJ0p1bmhvJywgJ0p1bGhvJywnQWdvc3RvJywnU2V0ZW1icm8nLCdPdXR1YnJvJywnTm92ZW1icm8nLCdEZXplbWJybyddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZldicsJ01hcicsJ0FicicsJ01haScsJ0p1bicsJ0p1bCcsJ0FnbycsJ1NldCcsJ091dCcsJ05vdicsJ0RleiddLFxuICAgICAgICAgICAgZGF5TmFtZXM6IFsnRG9taW5nbycsJ1NlZ3VuZGEtZmVpcmEnLCdUZXImY2NlZGlsO2EtZmVpcmEnLCdRdWFydGEtZmVpcmEnLCdRdWludGEtZmVpcmEnLCdTZXh0YS1mZWlyYScsJ1MmYWFjdXRlO2JhZG8nXSxcbiAgICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IFsnRG9tJywnU2VnJywnVGVyJywnUXVhJywnUXVpJywnU2V4JywnUyZhYWN1dGU7YiddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAncGwnOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ1N0eWN6ZcWEJywnTHV0eScsJ01hcnplYycsJ0t3aWVjaWXFhCcsJ01haicsJ0N6ZXJ3aWVjJywnTGlwaWVjJywnU2llcnBpZcWEJywnV3J6ZXNpZcWEJywnUGHFumR6aWVybmlrJywnTGlzdG9wYWQnLCdHcnVkemllxYQnXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWydTdHknLCAnTHV0JywgJ01hcicsICdLd2knLCAnTWFqJywgJ0N6ZScsJ0xpcCcsICdTaWUnLCAnV3J6JywgJ1BhxbonLCAnTGlzJywgJ0dydSddLFxuICAgICAgICAgICAgZGF5TmFtZXM6IFsnTmllZHppZWxhJywgJ1BvbmllZHppYcWCZWsnLCAnV3RvcmVrJywgJ8Wacm9kYScsICdDendhcnRlaycsICdQacSFdGVrJywgJ1NvYm90YSddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydOaScsICdQbicsICdXdCcsICfFmnInLCAnQ3onLCAnUHQnLCAnU2InXSxcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZzogJyVZLSVtLSVkICVIOiVNOiVTJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdubCc6IHtcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsnSmFudWFyaScsJ0ZlYnJ1YXJpJywnTWFhcnQnLCdBcHJpbCcsJ01laScsJ0p1bmknLCdKdWx5JywnQXVndXN0dXMnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01laScsJ0p1bicsJ0p1bCcsJ0F1ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuICAgICAgICAgICAgZGF5TmFtZXM6JywnWydab25kYWcnLCdNYWFuZGFnJywnRGluc2RhZycsJ1dvZW5zZGFnJywnRG9uZGVyZGFnJywnVnJpamRhZycsJ1phdGVyZGFnJ10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ1pvJywnTWEnLCdEaScsJ1dvJywnRG8nLCdWcicsJ1phJ10sXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmc6ICclWS0lbS0lZCAlSDolTTolUydcbiAgICAgICAgfSxcblxuICAgICAgICAnc3YnOiB7XG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ2phbnVhcmknLCdmZWJydWFyaScsJ21hcnMnLCdhcHJpbCcsJ21haicsJ2p1bmknLCdqdWxpJywnYXVndXN0aScsJ3NlcHRlbWJlcicsJ29rdG9iZXInLCdub3ZlbWJlcicsJ2RlY2VtYmVyJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IFsnamFuJywnZmViJywnbWFyJywnYXByJywnbWFqJywnanVuJywnanVsJywnYXVnJywnc2VwJywnb2t0Jywnbm92JywnZGVjJ10sXG4gICAgICAgICAgICBkYXlOYW1lczogWydzw7ZuZGFnJywnbcOlbmRhZycsJ3Rpc2RhZycsJ29uc2RhZycsJ3RvcnNkYWcnLCdmcmVkYWcnLCdsw7ZyZGFnJ10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ3PDtm4nLCdtw6VuJywndGlzJywnb25zJywndG9yJywnZnJlJywnbMO2ciddLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nOiAnJVktJW0tJWQgJUg6JU06JVMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2l0Jzoge1xuICAgICAgICAgICAgbW9udGhOYW1lczogWydHZW5uYWlvJywnRmViYnJhaW8nLCdNYXJ6bycsJ0FwcmlsZScsJ01hZ2dpbycsJ0dpdWdubycsJ0x1Z2xpbycsJ0Fnb3N0bycsJ1NldHRlbWJyZScsJ090dG9icmUnLCdOb3ZlbWJyZScsJ0RpY2VtYnJlJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IFsnR2VuJywnRmViJywnTWFyJywnQXByJywnTWFnJywnR2l1JywnTHVnJywnQWdvJywnU2V0JywnT3R0JywnTm92JywnRGljJ10sXG4gICAgICAgICAgICBkYXlOYW1lczogWydEb21lbmljYScsJ0x1bmVkaScsJ01hcnRlZGknLCdNZXJjb2xlZGknLCdHaW92ZWRpJywnVmVuZXJkaScsJ1NhYmF0byddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydEb20nLCdMdW4nLCdNYXInLCdNZXInLCdHaW8nLCdWZW4nLCdTYWInXSxcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZzogJyVkLSVtLSVZICVIOiVNOiVTJ1xuICAgICAgICB9XG4gICAgXG4gICAgfTtcbiAgICBcbiAgICAvLyBTZXQgZW5nbGlzaCB2YXJpYW50cyB0byAnZW4nXG4gICAganNEYXRlLnJlZ2lvbmFsWydlbi1VUyddID0ganNEYXRlLnJlZ2lvbmFsWydlbi1HQiddID0ganNEYXRlLnJlZ2lvbmFsWydlbiddO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIHVzZXJzIGxvY2FsZSBiYXNlZCBvbiB0aGUgbGFuZyBhdHRyaWJ1dGUgb2YgdGhlIGh0bWwgcGFnZS4gIERlZmF1bHRzIHRvICdlbidcbiAgICAgKiBpZiBpdCBjYW5ub3QgZmlndXJlIG91dCBhIGxvY2FsZSBvZiBpZiB0aGUgbG9jYWxlIGRvZXMgbm90IGhhdmUgYSBsb2NhbGl6YXRpb24gZGVmaW5lZC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsb2NhbGVcbiAgICAgKi9cbiAgICAgXG4gICAganNEYXRlLnJlZ2lvbmFsLmdldExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSBqc0RhdGUuY29uZmlnLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoIGRvY3VtZW50ICYmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJykgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXS5sYW5nICkge1xuICAgICAgICAgICAgbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0ubGFuZztcbiAgICAgICAgICAgIGlmICghanNEYXRlLnJlZ2lvbmFsLmhhc093blByb3BlcnR5KGwpKSB7XG4gICAgICAgICAgICAgICAgbCA9IGpzRGF0ZS5jb25maWcuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBtcyBpbiBkYXlcbiAgICB2YXIgZGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICBcbiAgICAvLyBwYWRkIGEgbnVtYmVyIHdpdGggemVyb3NcbiAgICB2YXIgYWRkWmVyb3MgPSBmdW5jdGlvbihudW0sIGRpZ2l0cykge1xuICAgICAgICBudW0gPSBTdHJpbmcobnVtKTtcbiAgICAgICAgdmFyIGkgPSBkaWdpdHMgLSBudW0ubGVuZ3RoO1xuICAgICAgICB2YXIgcyA9IFN0cmluZyhNYXRoLnBvdygxMCwgaSkpLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gcy5jb25jYXQobnVtKTtcbiAgICB9O1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb25zIHVzZWQgZm9yIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2VzIGJldHdlZW4gZGF0ZXMuXG4gICAgLy8gVGhpcyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBLZW4gU255ZGVyJ3Mgd29yay5cbiAgICB2YXIgbXVsdGlwbGllcnMgPSB7XG4gICAgICAgIG1pbGxpc2Vjb25kOiAxLFxuICAgICAgICBzZWNvbmQ6IDEwMDAsXG4gICAgICAgIG1pbnV0ZTogNjAgKiAxMDAwLFxuICAgICAgICBob3VyOiA2MCAqIDYwICogMTAwMCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIHdlZWs6IDcgKiBkYXksXG4gICAgICAgIG1vbnRoOiB7XG4gICAgICAgICAgICAvLyBhZGQgYSBudW1iZXIgb2YgbW9udGhzXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGQsIG51bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhbnkgeWVhcnMgbmVlZGVkIChpbmNyZW1lbnRzIG9mIDEyKVxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXJzLnllYXIuYWRkKGQsIE1hdGhbbnVtYmVyID4gMCA/ICdmbG9vcicgOiAnY2VpbCddKG51bWJlciAvIDEyKSk7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgcHJvcGVybHkgd3JhcCBiZXR3ZW4gRGVjZW1iZXIgYW5kIEphbnVhcnlcbiAgICAgICAgICAgICAgICAvLyAxMSAlIDEyID0gMTFcbiAgICAgICAgICAgICAgICAvLyAxMiAlIDEyID0gMFxuICAgICAgICAgICAgICAgIHZhciBwcmV2TW9udGggPSBkLmdldE1vbnRoKCkgKyAobnVtYmVyICUgMTIpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TW9udGggPT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vbnRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZC5zZXRZZWFyKGQuZ2V0RnVsbFllYXIoKSArIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldk1vbnRoID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNb250aCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBkLnNldFllYXIoZC5nZXRGdWxsWWVhcigpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgocHJldk1vbnRoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG51bWJlciBvZiBtb250aHMgYmV0d2VlbiB0d28gRGF0ZSBvYmplY3RzIChkZWNpbWFsIHRvIHRoZSBuZWFyZXN0IGRheSlcbiAgICAgICAgICAgIGRpZmY6IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbnVtYmVyIG9mIHllYXJzXG4gICAgICAgICAgICAgICAgdmFyIGRpZmZZZWFycyA9IGQxLmdldEZ1bGxZZWFyKCkgLSBkMi5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBtb250aHNcbiAgICAgICAgICAgICAgICB2YXIgZGlmZk1vbnRocyA9IGQxLmdldE1vbnRoKCkgLSBkMi5nZXRNb250aCgpICsgKGRpZmZZZWFycyAqIDEyKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG51bWJlciBvZiByZW1haW5pbmcgZGF5c1xuICAgICAgICAgICAgICAgIHZhciBkaWZmRGF5cyA9IGQxLmdldERhdGUoKSAtIGQyLmdldERhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIG1vbnRoIGRpZmZlcmVuY2Ugd2l0aCB0aGUgZGF5cyBkaWZmZXJlbmNlIGFzIGEgZGVjaW1hbFxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmTW9udGhzICsgKGRpZmZEYXlzIC8gMzApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5ZWFyOiB7XG4gICAgICAgICAgICAvLyBhZGQgYSBudW1iZXIgb2YgeWVhcnNcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oZCwgbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZC5zZXRZZWFyKGQuZ2V0RnVsbFllYXIoKSArIE1hdGhbbnVtYmVyID4gMCA/ICdmbG9vcicgOiAnY2VpbCddKG51bWJlcikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbnVtYmVyIG9mIHllYXJzIGJldHdlZW4gdHdvIERhdGUgb2JqZWN0cyAoZGVjaW1hbCB0byB0aGUgbmVhcmVzdCBkYXkpXG4gICAgICAgICAgICBkaWZmOiBmdW5jdGlvbihkMSwgZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlwbGllcnMubW9udGguZGlmZihkMSwgZDIpIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICAgIFxuICAgIH07XG4gICAgLy9cbiAgICAvLyBBbGlhcyBlYWNoIG11bHRpcGxpZXIgd2l0aCBhbiAncycgdG8gYWxsb3cgJ3llYXInIGFuZCAneWVhcnMnIGZvciBleGFtcGxlLlxuICAgIC8vIFRoaXMgY29tZXMgZnJvbSBLZW4gU255ZGVycyB3b3JrLlxuICAgIC8vXG4gICAgZm9yICh2YXIgdW5pdCBpbiBtdWx0aXBsaWVycykge1xuICAgICAgICBpZiAodW5pdC5zdWJzdHJpbmcodW5pdC5sZW5ndGggLSAxKSAhPSAncycpIHsgLy8gSUUgd2lsbCBpdGVyYXRlIG5ld2x5IGFkZGVkIHByb3BlcnRpZXMgOnxcbiAgICAgICAgICAgIG11bHRpcGxpZXJzW3VuaXQgKyAncyddID0gbXVsdGlwbGllcnNbdW5pdF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9cbiAgICAvLyB0YWtlIGEganNEYXRlIGluc3RhbmNlIGFuZCBhIGZvcm1hdCBjb2RlIGFuZCByZXR1cm4gdGhlIGZvcm1hdHRlZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgbW9kaWZpZWQgdmVyc2lvbiBvZiBLZW4gU255ZGVyJ3MgbWV0aG9kLlxuICAgIC8vXG4gICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGQsIGNvZGUsIHN5bnRheCkge1xuICAgICAgICAvLyBpZiBzaG9yY3V0IGNvZGVzIGFyZSB1c2VkLCByZWN1cnNpdmVseSBleHBhbmQgdGhvc2UuXG4gICAgICAgIGlmIChqc0RhdGUuZm9ybWF0c1tzeW50YXhdW1wic2hvcnRjdXRzXCJdW2NvZGVdKSB7XG4gICAgICAgICAgICByZXR1cm4ganNEYXRlLnN0cmZ0aW1lKGQsIGpzRGF0ZS5mb3JtYXRzW3N5bnRheF1bXCJzaG9ydGN1dHNcIl1bY29kZV0sIHN5bnRheCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGZvcm1hdCBjb2RlIGZ1bmN0aW9uIGFuZCBhZGRaZXJvcygpIGFyZ3VtZW50XG4gICAgICAgICAgICB2YXIgZ2V0dGVyID0gKGpzRGF0ZS5mb3JtYXRzW3N5bnRheF1bXCJjb2Rlc1wiXVtjb2RlXSB8fCAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBuYnIgPSBkWydnZXQnICsgZ2V0dGVyWzBdXSA/IGRbJ2dldCcgKyBnZXR0ZXJbMF1dKCkgOiAnJztcbiAgICAgICAgICAgIGlmIChnZXR0ZXJbMV0pIHtcbiAgICAgICAgICAgICAgICBuYnIgPSBhZGRaZXJvcyhuYnIsIGdldHRlclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmJyO1xuICAgICAgICB9ICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIFN0YXRpYyBmdW5jdGlvbiBmb3IgY29udmVydCBhIGRhdGUgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gZm9ybWF0LiAgQWxzbyBhY3RzIGFzIG5hbWVzcGFjZSBmb3Igc3RyZnRpbWUgZm9ybWF0IGNvZGVzLlxuICAgICAqIDxwPnN0cmZ0aW1lIGZvcm1hdHRpbmcgY2FuIGJlIGFjY29tcGxpc2hlZCB3aXRob3V0IGNyZWF0aW5nIGEganNEYXRlIG9iamVjdCBieSBjYWxsaW5nIGpzRGF0ZS5zdHJmdGltZSgpOjwvcD5cbiAgICAgKiA8cHJlIGNsYXNzPVwiY29kZVwiPlxuICAgICAqIHZhciBmb3JtYXR0ZWREYXRlID0ganNEYXRlLnN0cmZ0aW1lKCdGZWIgOCwgMjAwNiA4OjQ4OjMyJywgJyVZLSVtLSVkICVIOiVNOiVTJyk7XG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBBcnJheSB8IGpzRGF0ZSZuYnNwO09iamVjdCB8IERhdGUmbmJzcDtPYmplY3R9IGRhdGUgQSBwYXJzYWJsZSBkYXRlIHN0cmluZywgSmF2YVNjcmlwdCB0aW1lIHN0YW1wLCBBcnJheSBvZiBmb3JtIFt5ZWFyLCBtb250aCwgZGF5LCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzXSwganNEYXRlIE9iamVjdCBvciBEYXRlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0U3RyaW5nIFN0cmluZyB3aXRoIGVtYmVkZGVkIGRhdGUgZm9ybWF0dGluZyBjb2Rlcy4gIFxuICAgICAqIFNlZToge0BsaW5rIGpzRGF0ZS5mb3JtYXRzfS4gXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheCBPcHRpb25hbCBzeW50YXggdG8gdXNlIFtkZWZhdWx0IHBlcmxdLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhbGUgT3B0aW9uYWwgbG9jYWxlIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBGb3JtYXR0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGUuXG4gICAgKi9cbiAgICAvL1xuICAgIC8vIExvZ2ljIGFzIGltcGxlbWVudGVkIGhlcmUgaXMgdmVyeSBzaW1pbGFyIHRvIEtlbiBTbnlkZXIncyBEYXRlIEluc3RhbmNlIE1ldGhvZHMuXG4gICAgLy9cbiAgICBqc0RhdGUuc3RyZnRpbWUgPSBmdW5jdGlvbihkLCBmb3JtYXRTdHJpbmcsIHN5bnRheCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBzeW4gPSAncGVybCc7XG4gICAgICAgIHZhciBsb2MgPSBqc0RhdGUucmVnaW9uYWwuZ2V0TG9jYWxlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBjaGVjayBpZiBzeW50YXggYW5kIGxvY2FsZSBhcmUgYXZhaWxhYmxlIG9yIHJldmVyc2VkXG4gICAgICAgIGlmIChzeW50YXggJiYganNEYXRlLmZvcm1hdHMuaGFzT3duUHJvcGVydHkoc3ludGF4KSkge1xuICAgICAgICAgICAgc3luID0gc3ludGF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN5bnRheCAmJiBqc0RhdGUucmVnaW9uYWwuaGFzT3duUHJvcGVydHkoc3ludGF4KSkge1xuICAgICAgICAgICAgbG9jID0gc3ludGF4O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobG9jYWxlICYmIGpzRGF0ZS5mb3JtYXRzLmhhc093blByb3BlcnR5KGxvY2FsZSkpIHtcbiAgICAgICAgICAgIHN5biA9IGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2NhbGUgJiYganNEYXRlLnJlZ2lvbmFsLmhhc093blByb3BlcnR5KGxvY2FsZSkpIHtcbiAgICAgICAgICAgIGxvYyA9IGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGdldF90eXBlKGQpICE9IFwiW29iamVjdCBPYmplY3RdXCIgfHwgZC5fdHlwZSAhPSBcImpzRGF0ZVwiKSB7XG4gICAgICAgICAgICBkID0gbmV3IGpzRGF0ZShkKTtcbiAgICAgICAgICAgIGQubG9jYWxlID0gbG9jO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9ybWF0U3RyaW5nKSB7XG4gICAgICAgICAgICBmb3JtYXRTdHJpbmcgPSBkLmZvcm1hdFN0cmluZyB8fCBqc0RhdGUucmVnaW9uYWxbbG9jXVsnZm9ybWF0U3RyaW5nJ107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB0aGUgZm9ybWF0IHN0cmluZyB0byB5ZWFyLW1vbnRoLWRheVxuICAgICAgICB2YXIgc291cmNlID0gZm9ybWF0U3RyaW5nIHx8ICclWS0lbS0lZCcsIFxuICAgICAgICAgICAgcmVzdWx0ID0gJycsIFxuICAgICAgICAgICAgbWF0Y2g7XG4gICAgICAgIC8vIHJlcGxhY2UgZWFjaCBmb3JtYXQgY29kZVxuICAgICAgICB3aGlsZSAoc291cmNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9IHNvdXJjZS5tYXRjaChqc0RhdGUuZm9ybWF0c1tzeW5dLmNvZGVzLm1hdGNoZXIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChtYXRjaFsxXSB8fCAnJykgKyBmb3JtYXQoZCwgbWF0Y2hbMl0sIHN5bik7XG4gICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdCBjb2RlcyBhbmQgZm9ybWF0IHNob3J0Y3V0cy4gIFwicGVybFwiIGFuZCBcInBocFwiIGZvcm1hdCBjb2RlcyBcbiAgICAgKiBhbmQgc2hvcnRjdXRzIGFyZSBkZWZpbmVkIGJ5IGRlZmF1bHQuICBBZGRpdGlvbmFsIGNvZGVzIGFuZCBzaG9ydGN1dHMgY2FuIGJlXG4gICAgICogYWRkZWQgbGlrZTpcbiAgICAgKiBcbiAgICAgKiA8cHJlIGNsYXNzPVwiY29kZVwiPlxuICAgICAqIGpzRGF0ZS5mb3JtYXRzW1wicGVybFwiXSA9IHtcbiAgICAgKiAgICAgXCJjb2Rlc1wiOiB7XG4gICAgICogICAgICAgICBtYXRjaGVyOiAvc29tZXJlZ2V4LyxcbiAgICAgKiAgICAgICAgIFk6IFwiZnVsbFllYXJcIiwgIC8vIG5hbWUgb2YgXCJnZXRcIiBtZXRob2Qgd2l0aG91dCB0aGUgXCJnZXRcIixcbiAgICAgKiAgICAgICAgIC4uLiwgICAgICAgICAgICAvLyBtb3JlIGNvZGVzXG4gICAgICogICAgIH0sXG4gICAgICogICAgIFwic2hvcnRjdXRzXCI6IHtcbiAgICAgKiAgICAgICAgIEY6ICclWS0lbS0lZCcsXG4gICAgICogICAgICAgICAuLi4sICAgICAgICAgICAgLy8gbW9yZSBzaG9ydGN1dHNcbiAgICAgKiAgICAgfVxuICAgICAqIH07XG4gICAgICogPC9wcmU+XG4gICAgICogXG4gICAgICogPHA+QWRkaXRpb25hbGx5LCBJU08gYW5kIFNRTCBzaG9ydGN1dHMgYXJlIGRlZmluZWQgYW5kIGNhbiBiZSBhY2Nlc3NlcyB2aWE6XG4gICAgICogPGNvZGU+anNEYXRlLmZvcm1hdHMuSVNPPC9jb2RlPiBhbmQgPGNvZGU+anNEYXRlLmZvcm1hdHMuU1FMPC9jb2RlPlxuICAgICAqL1xuICAgIFxuICAgIGpzRGF0ZS5mb3JtYXRzID0ge1xuICAgICAgICBJU086JyVZLSVtLSVkVCVIOiVNOiVTLiVOJUcnLFxuICAgICAgICBTUUw6JyVZLSVtLSVkICVIOiVNOiVTJ1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUGVybCBmb3JtYXQgY29kZXMgYW5kIHNob3J0Y3V0cyBmb3Igc3RyZnRpbWUuXG4gICAgICogXG4gICAgICogQSBoYXNoIChvYmplY3QpIG9mIGNvZGVzIHdoZXJlIGVhY2ggY29kZSBtdXN0IGJlIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBtZW1iZXIgaXMgXG4gICAgICogdGhlIG5hbWUgb2YgYSBEYXRlLnByb3RvdHlwZSBvciBqc0RhdGUucHJvdG90eXBlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICAgKiBhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBtZW1iZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIHRvIHBhc3MgdG8gYWRkWmVyb3MoKVxuICAgICAqIFxuICAgICAqIDxwPlRoZSBmb2xsb3dpbmcgZm9ybWF0IGNvZGVzIGFyZSBkZWZpbmVkOjwvcD5cbiAgICAgKiBcbiAgICAgKiA8cHJlIGNsYXNzPVwiY29kZVwiPlxuICAgICAqIENvZGUgICAgUmVzdWx0ICAgICAgICAgICAgICAgICAgICBEZXNjcmlwdGlvblxuICAgICAqID09IFllYXJzID09ICAgICAgICAgICBcbiAgICAgKiAlWSAgICAgIDIwMDggICAgICAgICAgICAgICAgICAgICAgRm91ci1kaWdpdCB5ZWFyXG4gICAgICogJXkgICAgICAwOCAgICAgICAgICAgICAgICAgICAgICAgIFR3by1kaWdpdCB5ZWFyXG4gICAgICogXG4gICAgICogPT0gTW9udGhzID09ICAgICAgICAgIFxuICAgICAqICVtICAgICAgMDkgICAgICAgICAgICAgICAgICAgICAgICBUd28tZGlnaXQgbW9udGhcbiAgICAgKiAlI20gICAgIDkgICAgICAgICAgICAgICAgICAgICAgICAgT25lIG9yIHR3by1kaWdpdCBtb250aFxuICAgICAqICVCICAgICAgU2VwdGVtYmVyICAgICAgICAgICAgICAgICBGdWxsIG1vbnRoIG5hbWVcbiAgICAgKiAlYiAgICAgIFNlcCAgICAgICAgICAgICAgICAgICAgICAgQWJicmV2aWF0ZWQgbW9udGggbmFtZVxuICAgICAqIFxuICAgICAqID09IERheXMgPT0gICAgICAgICAgICBcbiAgICAgKiAlZCAgICAgIDA1ICAgICAgICAgICAgICAgICAgICAgICAgVHdvLWRpZ2l0IGRheSBvZiBtb250aFxuICAgICAqICUjZCAgICAgNSAgICAgICAgICAgICAgICAgICAgICAgICBPbmUgb3IgdHdvLWRpZ2l0IGRheSBvZiBtb250aFxuICAgICAqICVlICAgICAgNSAgICAgICAgICAgICAgICAgICAgICAgICBPbmUgb3IgdHdvLWRpZ2l0IGRheSBvZiBtb250aFxuICAgICAqICVBICAgICAgU3VuZGF5ICAgICAgICAgICAgICAgICAgICBGdWxsIG5hbWUgb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xuICAgICAqICVhICAgICAgU3VuICAgICAgICAgICAgICAgICAgICAgICBBYmJyZXZpYXRlZCBuYW1lIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgKiAldyAgICAgIDAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWsgKDAgPSBTdW5kYXksIDYgPSBTYXR1cmRheSlcbiAgICAgKiBcbiAgICAgKiA9PSBIb3VycyA9PSAgICAgICAgICAgXG4gICAgICogJUggICAgICAyMyAgICAgICAgICAgICAgICAgICAgICAgIEhvdXJzIGluIDI0LWhvdXIgZm9ybWF0ICh0d28gZGlnaXRzKVxuICAgICAqICUjSCAgICAgMyAgICAgICAgICAgICAgICAgICAgICAgICBIb3VycyBpbiAyNC1ob3VyIGludGVnZXIgZm9ybWF0IChvbmUgb3IgdHdvIGRpZ2l0cylcbiAgICAgKiAlSSAgICAgIDExICAgICAgICAgICAgICAgICAgICAgICAgSG91cnMgaW4gMTItaG91ciBmb3JtYXQgKHR3byBkaWdpdHMpXG4gICAgICogJSNJICAgICAzICAgICAgICAgICAgICAgICAgICAgICAgIEhvdXJzIGluIDEyLWhvdXIgaW50ZWdlciBmb3JtYXQgKG9uZSBvciB0d28gZGlnaXRzKVxuICAgICAqICVwICAgICAgUE0gICAgICAgICAgICAgICAgICAgICAgICBBTSBvciBQTVxuICAgICAqIFxuICAgICAqID09IE1pbnV0ZXMgPT0gICAgICAgICBcbiAgICAgKiAlTSAgICAgIDA5ICAgICAgICAgICAgICAgICAgICAgICAgTWludXRlcyAodHdvIGRpZ2l0cylcbiAgICAgKiAlI00gICAgIDkgICAgICAgICAgICAgICAgICAgICAgICAgTWludXRlcyAob25lIG9yIHR3byBkaWdpdHMpXG4gICAgICogXG4gICAgICogPT0gU2Vjb25kcyA9PSAgICAgICAgIFxuICAgICAqICVTICAgICAgMDIgICAgICAgICAgICAgICAgICAgICAgICBTZWNvbmRzICh0d28gZGlnaXRzKVxuICAgICAqICUjUyAgICAgMiAgICAgICAgICAgICAgICAgICAgICAgICBTZWNvbmRzIChvbmUgb3IgdHdvIGRpZ2l0cylcbiAgICAgKiAlcyAgICAgIDEyMDY1Njc2MjU3MjMgICAgICAgICAgICAgVW5peCB0aW1lc3RhbXAgKFNlY29uZHMgcGFzdCAxOTcwLTAxLTAxIDAwOjAwOjAwKVxuICAgICAqIFxuICAgICAqID09IE1pbGxpc2Vjb25kcyA9PSAgICBcbiAgICAgKiAlTiAgICAgIDAwOCAgICAgICAgICAgICAgICAgICAgICAgTWlsbGlzZWNvbmRzICh0aHJlZSBkaWdpdHMpXG4gICAgICogJSNOICAgICA4ICAgICAgICAgICAgICAgICAgICAgICAgIE1pbGxpc2Vjb25kcyAob25lIHRvIHRocmVlIGRpZ2l0cylcbiAgICAgKiBcbiAgICAgKiA9PSBUaW1lem9uZSA9PSAgICAgICAgXG4gICAgICogJU8gICAgICAzNjAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UgaW4gbWludXRlcyBiZXR3ZWVuIGxvY2FsIHRpbWUgYW5kIEdNVFxuICAgICAqICVaICAgICAgTW91bnRhaW4gU3RhbmRhcmQgVGltZSAgICBOYW1lIG9mIHRpbWV6b25lIGFzIHJlcG9ydGVkIGJ5IGJyb3dzZXJcbiAgICAgKiAlRyAgICAgIDA2OjAwICAgICAgICAgICAgICAgICAgICAgSG91cnMgYW5kIG1pbnV0ZXMgYmV0d2VlbiBHTVRcbiAgICAgKiBcbiAgICAgKiA9PSBTaG9ydGN1dHMgPT0gICAgICAgXG4gICAgICogJUYgICAgICAyMDA4LTAzLTI2ICAgICAgICAgICAgICAgICVZLSVtLSVkXG4gICAgICogJVQgICAgICAwNTowNjozMCAgICAgICAgICAgICAgICAgICVIOiVNOiVTXG4gICAgICogJVggICAgICAwNTowNjozMCAgICAgICAgICAgICAgICAgICVIOiVNOiVTXG4gICAgICogJXggICAgICAwMy8yNi8wOCAgICAgICAgICAgICAgICAgICVtLyVkLyV5XG4gICAgICogJUQgICAgICAwMy8yNi8wOCAgICAgICAgICAgICAgICAgICVtLyVkLyV5XG4gICAgICogJSNjICAgICBXZWQgTWFyIDI2IDE1OjMxOjAwIDIwMDggICVhICViICVlICVIOiVNOiVTICVZXG4gICAgICogJXYgICAgICAzLVNlcC0yMDA4ICAgICAgICAgICAgICAgICVlLSViLSVZXG4gICAgICogJVIgICAgICAxNTozMSAgICAgICAgICAgICAgICAgICAgICVIOiVNXG4gICAgICogJXIgICAgICAwMzozMTowMCBQTSAgICAgICAgICAgICAgICVJOiVNOiVTICVwXG4gICAgICogXG4gICAgICogPT0gQ2hhcmFjdGVycyA9PSAgICAgIFxuICAgICAqICVuICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgTmV3bGluZVxuICAgICAqICV0ICAgICAgXFx0ICAgICAgICAgICAgICAgICAgICAgICAgVGFiXG4gICAgICogJSUgICAgICAlICAgICAgICAgICAgICAgICAgICAgICAgIFBlcmNlbnQgU3ltYm9sXG4gICAgICogPC9wcmU+XG4gICAgICogXG4gICAgICogPHA+Rm9ybWF0dGluZyBzaG9ydGN1dHMgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgaW50byB0aGVpciBsb25nZXIgdmVyc2lvbi5cbiAgICAgKiBCZSBzdXJlIHRoYXQgZm9ybWF0IHNob3J0Y3V0cyBkbyBub3QgcmVmZXIgdG8gdGhlbXNlbHZlczogdGhpcyB3aWxsIGNhdXNlIGFuIGluZmluaXRlIGxvb3AuPC9wPlxuICAgICAqIFxuICAgICAqIDxwPkZvcm1hdCBjb2RlcyBhbmQgZm9ybWF0IHNob3J0Y3V0cyBjYW4gYmUgcmVkZWZpbmVkIGFmdGVyIHRoZSBqc0RhdGVcbiAgICAgKiBtb2R1bGUgaXMgaW1wb3J0ZWQuPC9wPlxuICAgICAqIFxuICAgICAqIDxwPk5vdGUgdGhhdCBpZiB5b3UgcmVkZWZpbmUgdGhlIHdob2xlIGhhc2ggKG9iamVjdCksIHlvdSBtdXN0IHN1cHBseSBhIFwibWF0Y2hlclwiXG4gICAgICogcmVnZXggZm9yIHRoZSBwYXJzZXIuICBUaGUgZGVmYXVsdCBtYXRjaGVyIGlzOjwvcD5cbiAgICAgKiBcbiAgICAgKiA8Y29kZT4vKCklKCM/KCV8W2Etel0pKS9pPC9jb2RlPlxuICAgICAqIFxuICAgICAqIDxwPndoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBQZXJsIHN5bnRheCB1c2VkIGJ5IGRlZmF1bHQuPC9wPlxuICAgICAqIFxuICAgICAqIDxwPkJ5IGN1c3RvbWl6aW5nIHRoZSBtYXRjaGVyIGFuZCBmb3JtYXQgY29kZXMsIG5lYXJseSBhbnkgc3RyZnRpbWUgZnVuY3Rpb25hbGl0eSBpcyBwb3NzaWJsZS48L3A+XG4gICAgICovXG4gICAgIFxuICAgIGpzRGF0ZS5mb3JtYXRzLnBlcmwgPSB7XG4gICAgICAgIGNvZGVzOiB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMi1wYXJ0IHJlZ2V4IG1hdGNoZXIgZm9yIGZvcm1hdCBjb2Rlc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGZpcnN0IG1hdGNoIG11c3QgYmUgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIGNvZGUgKHRvIGFjY291bnQgZm9yIGVzY2FwaW5nKVxuICAgICAgICAgICAgLy8gc2Vjb25kIG1hdGNoIG11c3QgYmUgdGhlIGZvcm1hdCBjb2RlIGNoYXJhY3RlcihzKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIG1hdGNoZXI6IC8oKSUoIz8oJXxbYS16XSkpL2ksXG4gICAgICAgICAgICAvLyB5ZWFyXG4gICAgICAgICAgICBZOiAnRnVsbFllYXInLFxuICAgICAgICAgICAgeTogJ1Nob3J0WWVhci4yJyxcbiAgICAgICAgICAgIC8vIG1vbnRoXG4gICAgICAgICAgICBtOiAnTW9udGhOdW1iZXIuMicsXG4gICAgICAgICAgICAnI20nOiAnTW9udGhOdW1iZXInLFxuICAgICAgICAgICAgQjogJ01vbnRoTmFtZScsXG4gICAgICAgICAgICBiOiAnQWJick1vbnRoTmFtZScsXG4gICAgICAgICAgICAvLyBkYXlcbiAgICAgICAgICAgIGQ6ICdEYXRlLjInLFxuICAgICAgICAgICAgJyNkJzogJ0RhdGUnLFxuICAgICAgICAgICAgZTogJ0RhdGUnLFxuICAgICAgICAgICAgQTogJ0RheU5hbWUnLFxuICAgICAgICAgICAgYTogJ0FiYnJEYXlOYW1lJyxcbiAgICAgICAgICAgIHc6ICdEYXknLFxuICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgIEg6ICdIb3Vycy4yJyxcbiAgICAgICAgICAgICcjSCc6ICdIb3VycycsXG4gICAgICAgICAgICBJOiAnSG91cnMxMi4yJyxcbiAgICAgICAgICAgICcjSSc6ICdIb3VyczEyJyxcbiAgICAgICAgICAgIHA6ICdBTVBNJyxcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIE06ICdNaW51dGVzLjInLFxuICAgICAgICAgICAgJyNNJzogJ01pbnV0ZXMnLFxuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgUzogJ1NlY29uZHMuMicsXG4gICAgICAgICAgICAnI1MnOiAnU2Vjb25kcycsXG4gICAgICAgICAgICBzOiAnVW5peCcsXG4gICAgICAgICAgICAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIE46ICdNaWxsaXNlY29uZHMuMycsXG4gICAgICAgICAgICAnI04nOiAnTWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgIC8vIHRpbWV6b25lXG4gICAgICAgICAgICBPOiAnVGltZXpvbmVPZmZzZXQnLFxuICAgICAgICAgICAgWjogJ1RpbWV6b25lTmFtZScsXG4gICAgICAgICAgICBHOiAnR210T2Zmc2V0JyAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzaG9ydGN1dHM6IHtcbiAgICAgICAgICAgIC8vIGRhdGVcbiAgICAgICAgICAgIEY6ICclWS0lbS0lZCcsXG4gICAgICAgICAgICAvLyB0aW1lXG4gICAgICAgICAgICBUOiAnJUg6JU06JVMnLFxuICAgICAgICAgICAgWDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgIC8vIGxvY2FsIGZvcm1hdCBkYXRlXG4gICAgICAgICAgICB4OiAnJW0vJWQvJXknLFxuICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgIC8vIGxvY2FsIGZvcm1hdCBleHRlbmRlZFxuICAgICAgICAgICAgJyNjJzogJyVhICViICVlICVIOiVNOiVTICVZJyxcbiAgICAgICAgICAgIC8vIGxvY2FsIGZvcm1hdCBzaG9ydFxuICAgICAgICAgICAgdjogJyVlLSViLSVZJyxcbiAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICByOiAnJUk6JU06JVMgJXAnLFxuICAgICAgICAgICAgLy8gdGFiIGFuZCBuZXdsaW5lXG4gICAgICAgICAgICB0OiAnXFx0JyxcbiAgICAgICAgICAgIG46ICdcXG4nLFxuICAgICAgICAgICAgJyUnOiAnJSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUEhQIGZvcm1hdCBjb2RlcyBhbmQgc2hvcnRjdXRzIGZvciBzdHJmdGltZS5cbiAgICAgKiBcbiAgICAgKiBBIGhhc2ggKG9iamVjdCkgb2YgY29kZXMgd2hlcmUgZWFjaCBjb2RlIG11c3QgYmUgYW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IG1lbWJlciBpcyBcbiAgICAgKiB0aGUgbmFtZSBvZiBhIERhdGUucHJvdG90eXBlIG9yIGpzRGF0ZS5wcm90b3R5cGUgZnVuY3Rpb24gdG8gY2FsbFxuICAgICAqIGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIG1lbWJlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgdG8gcGFzcyB0byBhZGRaZXJvcygpXG4gICAgICogXG4gICAgICogPHA+VGhlIGZvbGxvd2luZyBmb3JtYXQgY29kZXMgYXJlIGRlZmluZWQ6PC9wPlxuICAgICAqIFxuICAgICAqIDxwcmUgY2xhc3M9XCJjb2RlXCI+XG4gICAgICogQ29kZSAgICBSZXN1bHQgICAgICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uXG4gICAgICogPT09IERheXMgPT09ICAgICAgICBcbiAgICAgKiAlYSAgICAgIFN1biB0aHJvdWdoIFNhdCAgICAgICAgICAgQW4gYWJicmV2aWF0ZWQgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5XG4gICAgICogJUEgICAgICBTdW5kYXkgLSBTYXR1cmRheSAgICAgICAgIEEgZnVsbCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXlcbiAgICAgKiAlZCAgICAgIDAxIHRvIDMxICAgICAgICAgICAgICAgICAgVHdvLWRpZ2l0IGRheSBvZiB0aGUgbW9udGggKHdpdGggbGVhZGluZyB6ZXJvcylcbiAgICAgKiAlZSAgICAgIDEgdG8gMzEgICAgICAgICAgICAgICAgICAgRGF5IG9mIHRoZSBtb250aCwgd2l0aCBhIHNwYWNlIHByZWNlZGluZyBzaW5nbGUgZGlnaXRzLlxuICAgICAqICVqICAgICAgMDAxIHRvIDM2NiAgICAgICAgICAgICAgICBEYXkgb2YgdGhlIHllYXIsIDMgZGlnaXRzIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAqICV1ICAgICAgMSAtIDcgKE1vbiAtIFN1bikgICAgICAgICBJU08tODYwMSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgKiAldyAgICAgIDAgLSA2IChTdW4gLSBTYXQpICAgICAgICAgTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICogPT09IFdlZWsgPT09ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICogJVUgICAgICAxMyAgICAgICAgICAgICAgICAgICAgICAgIEZ1bGwgV2VlayBudW1iZXIsIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IFN1bmRheSBhcyB0aGUgZmlyc3Qgd2Vla1xuICAgICAqICVWICAgICAgMDEgdGhyb3VnaCA1MyAgICAgICAgICAgICBJU08tODYwMToxOTg4IHdlZWsgbnVtYmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIGF0IGxlYXN0IDQgd2Vla2RheXMsIHdpdGggTW9uZGF5IGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgd2Vla1xuICAgICAqICVXICAgICAgNDYgICAgICAgICAgICAgICAgICAgICAgICBBIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHdlZWsgb2YgdGhlIHllYXIsIFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGluZyB3aXRoIHRoZSBmaXJzdCBNb25kYXkgYXMgdGhlIGZpcnN0IHdlZWtcbiAgICAgKiA9PT0gTW9udGggPT09ICAgICAgICAgICAgICAgICAgICBcbiAgICAgKiAlYiAgICAgIEphbiB0aHJvdWdoIERlYyAgICAgICAgICAgQWJicmV2aWF0ZWQgbW9udGggbmFtZSwgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgICAqICVCICAgICAgSmFudWFyeSAtIERlY2VtYmVyICAgICAgICBGdWxsIG1vbnRoIG5hbWUsIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICAgKiAlaCAgICAgIEphbiB0aHJvdWdoIERlYyAgICAgICAgICAgQWJicmV2aWF0ZWQgbW9udGggbmFtZSwgYmFzZWQgb24gdGhlIGxvY2FsZSAoYW4gYWxpYXMgb2YgJWIpXG4gICAgICogJW0gICAgICAwMSAtIDEyIChKYW4gLSBEZWMpICAgICAgIFR3byBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9udGhcbiAgICAgKiBcbiAgICAgKiA9PT0gWWVhciA9PT0gICAgICAgICAgICAgICAgICAgICBcbiAgICAgKiAlQyAgICAgIDE5ICAgICAgICAgICAgICAgICAgICAgICAgVHdvIGRpZ2l0IGNlbnR1cnkgKHllYXIvMTAwLCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlcilcbiAgICAgKiAleSAgICAgIDA5IGZvciAyMDA5ICAgICAgICAgICAgICAgVHdvIGRpZ2l0IHllYXJcbiAgICAgKiAlWSAgICAgIDIwMzggICAgICAgICAgICAgICAgICAgICAgRm91ciBkaWdpdCB5ZWFyXG4gICAgICogXG4gICAgICogPT09IFRpbWUgPT09ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICogJUggICAgICAwMCB0aHJvdWdoIDIzICAgICAgICAgICAgIFR3byBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaG91ciBpbiAyNC1ob3VyIGZvcm1hdFxuICAgICAqICVJICAgICAgMDEgdGhyb3VnaCAxMiAgICAgICAgICAgICBUd28gZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhvdXIgaW4gMTItaG91ciBmb3JtYXRcbiAgICAgKiAlbCAgICAgIDEgdGhyb3VnaCAxMiAgICAgICAgICAgICAgSG91ciBpbiAxMi1ob3VyIGZvcm1hdCwgd2l0aCBhIHNwYWNlIHByZWNlZWRpbmcgc2luZ2xlIGRpZ2l0c1xuICAgICAqICVNICAgICAgMDAgdGhyb3VnaCA1OSAgICAgICAgICAgICBUd28gZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1pbnV0ZVxuICAgICAqICVwICAgICAgQU0vUE0gICAgICAgICAgICAgICAgICAgICBVUFBFUi1DQVNFICdBTScgb3IgJ1BNJyBiYXNlZCBvbiB0aGUgZ2l2ZW4gdGltZVxuICAgICAqICVQICAgICAgYW0vcG0gICAgICAgICAgICAgICAgICAgICBsb3dlci1jYXNlICdhbScgb3IgJ3BtJyBiYXNlZCBvbiB0aGUgZ2l2ZW4gdGltZVxuICAgICAqICVyICAgICAgMDk6MzQ6MTcgUE0gICAgICAgICAgICAgICBTYW1lIGFzICVJOiVNOiVTICVwXG4gICAgICogJVIgICAgICAwMDozNSAgICAgICAgICAgICAgICAgICAgIFNhbWUgYXMgJUg6JU1cbiAgICAgKiAlUyAgICAgIDAwIHRocm91Z2ggNTkgICAgICAgICAgICAgVHdvIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWNvbmRcbiAgICAgKiAlVCAgICAgIDIxOjM0OjE3ICAgICAgICAgICAgICAgICAgU2FtZSBhcyAlSDolTTolU1xuICAgICAqICVYICAgICAgMDM6NTk6MTYgICAgICAgICAgICAgICAgICBQcmVmZXJyZWQgdGltZSByZXByZXNlbnRhdGlvbiBiYXNlZCBvbiBsb2NhbGUsIHdpdGhvdXQgdGhlIGRhdGVcbiAgICAgKiAleiAgICAgIC0wNTAwIG9yIEVTVCAgICAgICAgICAgICAgRWl0aGVyIHRoZSB0aW1lIHpvbmUgb2Zmc2V0IGZyb20gVVRDIG9yIHRoZSBhYmJyZXZpYXRpb25cbiAgICAgKiAlWiAgICAgIC0wNTAwIG9yIEVTVCAgICAgICAgICAgICAgVGhlIHRpbWUgem9uZSBvZmZzZXQvYWJicmV2aWF0aW9uIG9wdGlvbiBOT1QgZ2l2ZW4gYnkgJXpcbiAgICAgKiBcbiAgICAgKiA9PT0gVGltZSBhbmQgRGF0ZSA9PT0gICAgICAgICAgICBcbiAgICAgKiAlRCAgICAgIDAyLzA1LzA5ICAgICAgICAgICAgICAgICAgU2FtZSBhcyAlbS8lZC8leVxuICAgICAqICVGICAgICAgMjAwOS0wMi0wNSAgICAgICAgICAgICAgICBTYW1lIGFzICVZLSVtLSVkIChjb21tb25seSB1c2VkIGluIGRhdGFiYXNlIGRhdGVzdGFtcHMpXG4gICAgICogJXMgICAgICAzMDU4MTUyMDAgICAgICAgICAgICAgICAgIFVuaXggRXBvY2ggVGltZSB0aW1lc3RhbXAgKHNhbWUgYXMgdGhlIHRpbWUoKSBmdW5jdGlvbilcbiAgICAgKiAleCAgICAgIDAyLzA1LzA5ICAgICAgICAgICAgICAgICAgUHJlZmVycmVkIGRhdGUgcmVwcmVzZW50YXRpb24sIHdpdGhvdXQgdGhlIHRpbWVcbiAgICAgKiBcbiAgICAgKiA9PT0gTWlzY2VsbGFuZW91cyA9PT0gICAgICAgICAgICBcbiAgICAgKiAlbiAgICAgICAgLS0tICAgICAgICAgICAgICAgICAgICAgQSBuZXdsaW5lIGNoYXJhY3RlciAoXFxuKVxuICAgICAqICV0ICAgICAgICAtLS0gICAgICAgICAgICAgICAgICAgICBBIFRhYiBjaGFyYWN0ZXIgKFxcdClcbiAgICAgKiAlJSAgICAgICAgLS0tICAgICAgICAgICAgICAgICAgICAgQSBsaXRlcmFsIHBlcmNlbnRhZ2UgY2hhcmFjdGVyICglKVxuICAgICAqIDwvcHJlPlxuICAgICAqL1xuIFxuICAgIGpzRGF0ZS5mb3JtYXRzLnBocCA9IHtcbiAgICAgICAgY29kZXM6IHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyLXBhcnQgcmVnZXggbWF0Y2hlciBmb3IgZm9ybWF0IGNvZGVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZmlyc3QgbWF0Y2ggbXVzdCBiZSB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgY29kZSAodG8gYWNjb3VudCBmb3IgZXNjYXBpbmcpXG4gICAgICAgICAgICAvLyBzZWNvbmQgbWF0Y2ggbXVzdCBiZSB0aGUgZm9ybWF0IGNvZGUgY2hhcmFjdGVyKHMpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbWF0Y2hlcjogLygpJSgoJXxbYS16XSkpL2ksXG4gICAgICAgICAgICAvLyBkYXlcbiAgICAgICAgICAgIGE6ICdBYmJyRGF5TmFtZScsXG4gICAgICAgICAgICBBOiAnRGF5TmFtZScsXG4gICAgICAgICAgICBkOiAnRGF0ZS4yJyxcbiAgICAgICAgICAgIGU6ICdEYXRlJyxcbiAgICAgICAgICAgIGo6ICdEYXlPZlllYXIuMycsXG4gICAgICAgICAgICB1OiAnRGF5T2ZXZWVrJyxcbiAgICAgICAgICAgIHc6ICdEYXknLFxuICAgICAgICAgICAgLy8gd2Vla1xuICAgICAgICAgICAgVTogJ0Z1bGxXZWVrT2ZZZWFyLjInLFxuICAgICAgICAgICAgVjogJ0lzb1dlZWsuMicsXG4gICAgICAgICAgICBXOiAnV2Vla09mWWVhci4yJyxcbiAgICAgICAgICAgIC8vIG1vbnRoXG4gICAgICAgICAgICBiOiAnQWJick1vbnRoTmFtZScsXG4gICAgICAgICAgICBCOiAnTW9udGhOYW1lJyxcbiAgICAgICAgICAgIG06ICdNb250aE51bWJlci4yJyxcbiAgICAgICAgICAgIGg6ICdBYmJyTW9udGhOYW1lJyxcbiAgICAgICAgICAgIC8vIHllYXJcbiAgICAgICAgICAgIEM6ICdDZW50dXJ5LjInLFxuICAgICAgICAgICAgeTogJ1Nob3J0WWVhci4yJyxcbiAgICAgICAgICAgIFk6ICdGdWxsWWVhcicsXG4gICAgICAgICAgICAvLyB0aW1lXG4gICAgICAgICAgICBIOiAnSG91cnMuMicsXG4gICAgICAgICAgICBJOiAnSG91cnMxMi4yJyxcbiAgICAgICAgICAgIGw6ICdIb3VyczEyJyxcbiAgICAgICAgICAgIHA6ICdBTVBNJyxcbiAgICAgICAgICAgIFA6ICdBbVBtJyxcbiAgICAgICAgICAgIE06ICdNaW51dGVzLjInLFxuICAgICAgICAgICAgUzogJ1NlY29uZHMuMicsXG4gICAgICAgICAgICBzOiAnVW5peCcsXG4gICAgICAgICAgICBPOiAnVGltZXpvbmVPZmZzZXQnLFxuICAgICAgICAgICAgejogJ0dtdE9mZnNldCcsXG4gICAgICAgICAgICBaOiAnVGltZXpvbmVBYmJyJ1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgc2hvcnRjdXRzOiB7XG4gICAgICAgICAgICBEOiAnJW0vJWQvJXknLFxuICAgICAgICAgICAgRjogJyVZLSVtLSVkJyxcbiAgICAgICAgICAgIFQ6ICclSDolTTolUycsXG4gICAgICAgICAgICBYOiAnJUg6JU06JVMnLFxuICAgICAgICAgICAgeDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICByOiAnJUk6JU06JVMgJXAnLFxuICAgICAgICAgICAgdDogJ1xcdCcsXG4gICAgICAgICAgICBuOiAnXFxuJyxcbiAgICAgICAgICAgICclJzogJyUnXG4gICAgICAgIH1cbiAgICB9OyAgIFxuICAgIC8vXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB0aGUgbG9naWMgaW1wbGVtZW50ZWQgaGVyZSBpcyBzaW1pbGFyIHRvIEtlbiBTbnlkZXIncyBEYXRlIEluc3RhbmNlIE1ldGhvZHMuXG4gICAgLy8gSSB1c2UgaGlzIGlkZWEgb2YgYSBzZXQgb2YgcGFyc2VycyB3aGljaCBjYW4gYmUgcmVndWxhciBleHByZXNzaW9ucyBvciBmdW5jdGlvbnMsXG4gICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggdGhvc2UsIGFuZCB0aGVuIHNlZWluZyBpZiBEYXRlLnBhcnNlKCkgd2lsbCBjcmVhdGUgYSBkYXRlLlxuICAgIC8vIFRoZSBwYXJzZXIgZXhwcmVzc2lvbnMgYW5kIGZ1bmN0aW9ucyBhcmUgYSBsaXR0bGUgZGlmZmVyZW50IGFuZCBzb21lIGJ1Z3MgaGF2ZSBiZWVuXG4gICAgLy8gd29ya2VkIG91dC4gIEFsc28sIGEgbG90IG9mIFwicHJlLXBhcnNpbmdcIiBpcyBkb25lIHRvIGZpeCBpbXBsZW1lbnRhdGlvblxuICAgIC8vIHZhcmlhdGlvbnMgb2YgRGF0ZS5wYXJzZSgpIGJldHdlZW4gYnJvd3NlcnMuXG4gICAgLy9cbiAgICBqc0RhdGUuY3JlYXRlRGF0ZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBtdWx0aXBsZSBhcmd1bWVudHMsIHRyeSBEYXRlIGNvbnN0cnVjdG9yXG4gICAgICAgIGlmIChkYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYWxyZWFkeSBhIGRhdGUgb2JqZWN0LCByZXR1cm4gaXRcbiAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodHlwZW9mIGRhdGUgPT0gJ251bWJlcicpIHJldHVybiBuZXcgRGF0ZShkYXRlICogMTAwMCk7XG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gaW50ZWdlciwgaW50ZXJwcmV0IGl0IGFzIGEgamF2YXNjcmlwdCB0aW1lc3RhbXBcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEJlZm9yZSBwYXNzaW5nIHN0cmluZ3MgaW50byBEYXRlLnBhcnNlKCksIGhhdmUgdG8gbm9ybWFsaXplIHRoZW0gZm9yIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAgICAgICAgLy8gSWYgc3RyaW5ncyBhcmUgbm90IGZvcm1hdHRlZCBzdGFjY29yZGluZyB0byB0aGUgRWNtYVNjcmlwdCBzcGVjLCByZXN1bHRzIGZyb20gRGF0ZSBwYXJzZSB3aWxsIGJlIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudC4gIFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6IFxuICAgICAgICAvLyAgKiBGRiBhbmQgT3BlcmEgYXNzdW1lIDIgZGlnaXQgZGF0ZXMgYXJlIHByZSB5MmssIENob21lIGFzc3VtZXMgPDUwIGlzIHByZSB5MmssIDUwKyBpcyAyMXN0IGNlbnR1cnkuICBcbiAgICAgICAgLy8gICogQ2hyb21lIHdpbGwgY29ycmVjdGx5IHBhcnNlICcxOTg0LTEtMjUnIGludG8gbG9jYWx0aW1lLCBGRiBhbmQgT3BlcmEgd2lsbCBub3QgcGFyc2UuXG4gICAgICAgIC8vICAqIEJvdGggRkYsIENocm9tZSBhbmQgT3BlcmEgd2lsbCBwYXJzZSAnMTk4NC8xLzI1JyBpbnRvIGxvY2FsdGltZS5cbiAgICAgICAgXG4gICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgdmFyIHBhcnNhYmxlID0gU3RyaW5nKGRhdGUpLnJlcGxhY2UoL15cXHMqKC4rKVxccyokL2csICckMScpO1xuICAgICAgICBcbiAgICAgICAgLy8gcmVwbGFjZSBkYWhzZXMgKC0pIHdpdGggc2xhc2hlcyAoLykgaW4gZGF0ZXMgbGlrZSBuW25ubl0vbltuXS9uW25ubl1cbiAgICAgICAgcGFyc2FibGUgPSBwYXJzYWJsZS5yZXBsYWNlKC9eKFswLTldezEsNH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSw0fSkvLCBcIiQxLyQyLyQzXCIpO1xuICAgICAgICBcbiAgICAgICAgLy8vLy8vLy8vXG4gICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgZm9yICcxNS1EZWMtMDknIGFsc28uXG4gICAgICAgIC8vIEZGIHdpbGwgbm90IHBhcnNlLCBidXQgQ2hyb21lIHdpbGwuXG4gICAgICAgIC8vIENocm9tZSB3aWxsIHNldCBkYXRlIHRvIDIwMDkgYXMgd2VsbC5cbiAgICAgICAgLy8vLy8vLy8vXG4gICAgICAgIFxuICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgJ2RkLW1tbS15eXl5JyBvciAnZGQvbW1tL3l5eXknIGxpa2UgJzE1LURlYy0yMDEwJ1xuICAgICAgICBwYXJzYWJsZSA9IHBhcnNhYmxlLnJlcGxhY2UoL14oM1swMV18WzAtMl0/XFxkKVstXFwvXShbYS16XXszLH0pWy1cXC9dKFxcZHs0fSkvaSwgXCIkMSAkMiAkM1wiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE5vdyBjaGVjayBmb3IgJ2RkLW1tbS15eScgb3IgJ2RkL21tbS95eScgYW5kIG5vcm1hbGl6ZSB5ZWFycyB0byBkZWZhdWx0IGNlbnR1cnkuXG4gICAgICAgIHZhciBtYXRjaCA9IHBhcnNhYmxlLm1hdGNoKC9eKDNbMDFdfFswLTJdP1xcZClbLVxcL10oW2Etel17Myx9KVstXFwvXShcXGR7Mn0pXFxEKi9pKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHZhciBtMyA9IHBhcnNlRmxvYXQobWF0Y2hbM10pO1xuICAgICAgICAgICAgdmFyIG55ID0ganNEYXRlLmNvbmZpZy5kZWZhdWx0Q2VudHVyeSArIG0zO1xuICAgICAgICAgICAgbnkgPSBTdHJpbmcobnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBub3cgcmVwbGFjZSAyIGRpZ2l0IHllYXIgd2l0aCA0IGRpZ2l0IHllYXJcbiAgICAgICAgICAgIHBhcnNhYmxlID0gcGFyc2FibGUucmVwbGFjZSgvXigzWzAxXXxbMC0yXT9cXGQpWy1cXC9dKFthLXpdezMsfSlbLVxcL10oXFxkezJ9KVxcRCovaSwgbWF0Y2hbMV0gKycgJysgbWF0Y2hbMl0gKycgJysgbnkpO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciAnMS8xOS83MCA4OjE0UE0nXG4gICAgICAgIC8vIHdoZXJlIHN0YXJ0cyB3aXRoIG1tL2RkL3l5IG9yIHl5L21tL2RkIGFuZCBoYXZlIHNvbWV0aGluZyBhZnRlclxuICAgICAgICAvLyBDaGVjayBpZiAxc3QgcG9zdGlpb24gaXMgZ3JlYXRlciB0aGFuIDMxLCBhc3N1bWUgaXQgaXMgeWVhci5cbiAgICAgICAgLy8gQXNzbWUgYWxsIDIgZGlnaXQgeWVhcnMgYXJlIDE5MDAncy5cbiAgICAgICAgLy8gRmluYWxseSwgY2hhbmdlIHRoZW0gaW50byBVUyBzdHlsZSBtbS9kZC95eXl5IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgICAgbWF0Y2ggPSBwYXJzYWJsZS5tYXRjaCgvXihbMC05XXsxLDJ9KVstXFwvXShbMC05XXsxLDJ9KVstXFwvXShbMC05XXsxLDJ9KVteMC05XS8pO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gaDEocGFyc2FibGUsIG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbTEgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIHZhciBtMiA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgdmFyIG0zID0gcGFyc2VGbG9hdChtYXRjaFszXSk7XG4gICAgICAgICAgICB2YXIgY2VudCA9IGpzRGF0ZS5jb25maWcuZGVmYXVsdENlbnR1cnk7XG4gICAgICAgICAgICB2YXIgbnksIG5kLCBubSwgc3RyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobTEgPiAzMSkgeyAvLyBmaXJzdCBudW1iZXIgaXMgYSB5ZWFyXG4gICAgICAgICAgICAgICAgbmQgPSBtMztcbiAgICAgICAgICAgICAgICBubSA9IG0yO1xuICAgICAgICAgICAgICAgIG55ID0gY2VudCArIG0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBlbHNlIHsgLy8gbGFzdCBudW1iZXIgaXMgdGhlIHllYXJcbiAgICAgICAgICAgICAgICBuZCA9IG0yO1xuICAgICAgICAgICAgICAgIG5tID0gbTE7XG4gICAgICAgICAgICAgICAgbnkgPSBjZW50ICsgbTM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0ciA9IG5tKycvJytuZCsnLycrbnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG5vdyByZXBsYWNlIDIgZGlnaXQgeWVhciB3aXRoIDQgZGlnaXQgeWVhclxuICAgICAgICAgICAgcmV0dXJuICBwYXJzYWJsZS5yZXBsYWNlKC9eKFswLTldezEsMn0pWy1cXC9dKFswLTldezEsMn0pWy1cXC9dKFswLTldezEsMn0pLywgc3RyKTtcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBwYXJzYWJsZSA9IGgxKHBhcnNhYmxlLCBtYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE5vdyBjaGVjayBmb3IgJzEvMTkvNzAnIHdpdGggbm90aGluZyBhZnRlciBhbmQgZG8gYXMgYWJvdmVcbiAgICAgICAgdmFyIG1hdGNoID0gcGFyc2FibGUubWF0Y2goL14oWzAtOV17MSwyfSlbLVxcL10oWzAtOV17MSwyfSlbLVxcL10oWzAtOV17MSwyfSkkLyk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcGFyc2FibGUgPSBoMShwYXJzYWJsZSwgbWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBqc0RhdGUubWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgcGF0dGVybixcbiAgICAgICAgICAgIG1zLFxuICAgICAgICAgICAgY3VycmVudCA9IHBhcnNhYmxlLFxuICAgICAgICAgICAgb2JqO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXMgPSBEYXRlLnBhcnNlKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihtcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0dGVybiA9IGpzRGF0ZS5tYXRjaGVyc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcGF0dGVybi5jYWxsKGpzRGF0ZSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJzYWJsZS5yZXBsYWNlKHBhdHRlcm5bMF0sIHBhdHRlcm5bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfTtcbiAgICBcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBIYW5keSBzdGF0aWMgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gdGhlIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGguXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB5ZWFyIFllYXJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1vbnRoIE1vbnRoICgxLTEyKVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfSBOdW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGguXG4gICAgKi9cbiAgICAvL1xuICAgIC8vIGhhbmR5IHV0aWxpdHkgbWV0aG9kIEJvcnJvd2VkIHJpZ2h0IGZyb20gS2VuIFNueWRlcidzIERhdGUgSW5zdGFuY2UgTWVodG9kcy5cbiAgICAvLyBcbiAgICBqc0RhdGUuZGF5c0luTW9udGggPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAobW9udGggPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIDEsIDI5KS5nZXREYXRlKCkgPT0gMjkgPyAyOSA6IDI4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLDMxLHVuZGVmaW5lZCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV1bbW9udGhdO1xuICAgIH07XG5cblxuICAgIC8vXG4gICAgLy8gQW4gQXJyYXkgb2YgcmVndWxhciBleHByZXNzaW9ucyBvciBmdW5jdGlvbnMgdGhhdCB3aWxsIGF0dGVtcHQgdG8gbWF0Y2ggdGhlIGRhdGUgc3RyaW5nLlxuICAgIC8vIEZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggc2NvcGUgb2YgYSBqc0RhdGUgaW5zdGFuY2UuXG4gICAgLy9cbiAgICBqc0RhdGUubWF0Y2hlcnMgPSBbXG4gICAgICAgIC8vIGNvbnZlcnQgZGQubW1tLnl5eXkgdG8gbW0vZGQveXl5eSAod29ybGQgZGF0ZSB0byBVUyBkYXRlKS5cbiAgICAgICAgWy8oM1swMV18WzAtMl1cXGQpXFxzKlxcLlxccyooMVswLTJdfDBcXGQpXFxzKlxcLlxccyooWzEtOV1cXGR7M30pLywgJyQyLyQxLyQzJ10sXG4gICAgICAgIC8vIGNvbnZlcnQgeXl5eS1tbS1kZCB0byBtbS9kZC95eXl5IChJU08gZGF0ZSB0byBVUyBkYXRlKS5cbiAgICAgICAgWy8oWzEtOV1cXGR7M30pXFxzKi1cXHMqKDFbMC0yXXwwXFxkKVxccyotXFxzKigzWzAxXXxbMC0yXVxcZCkvLCAnJDIvJDMvJDEnXSxcbiAgICAgICAgLy8gSGFuZGxlIDEyIGhvdXIgb3IgMjQgaG91ciB0aW1lIHdpdGggbWlsbGlzZWNvbmRzIGFtL3BtIGFuZCBvcHRpb25hbCBkYXRlIHBhcnQuXG4gICAgICAgIGZ1bmN0aW9uKHN0cikgeyBcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXig/OiguKylcXHMrKT8oWzAxMl0/XFxkKSg/OlxccypcXDpcXHMqKFxcZFxcZCkpPyg/OlxccypcXDpcXHMqKFxcZFxcZChcXC5cXGQqKT8pKT9cXHMqKGFtfHBtKT9cXHMqJC9pKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgIG9wdC4gZGF0ZSAgICAgIGhvdXIgICAgICAgb3B0LiBtaW51dGUgICAgIG9wdC4gc2Vjb25kICAgICAgIG9wdC4gbXNlYyAgIG9wdC4gYW0gb3IgcG1cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuY3JlYXRlRGF0ZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbNl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IG1hdGNoWzZdLnRvTG93ZXJDYXNlKCkgPT0gJ2FtJyA/IChob3VyID09IDEyID8gMCA6IGhvdXIpIDogKGhvdXIgPT0gMTIgPyAxMiA6IGhvdXIgKyAxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQuc2V0SG91cnMoaG91ciwgcGFyc2VJbnQobWF0Y2hbM10gfHwgMCwgMTApLCBwYXJzZUludChtYXRjaFs0XSB8fCAwLCAxMCksICgocGFyc2VGbG9hdChtYXRjaFs1XSB8fCAwKSkgfHwgMCkqMTAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBIYW5kbGUgSVNPIHRpbWVzdGFtcCB3aXRoIHRpbWUgem9uZS5cbiAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goL14oPzooLispKVtUfFxccytdKFswMTJdXFxkKSg/OlxcOihcXGRcXGQpKSg/OlxcOihcXGRcXGQpKSg/OlxcLlxcZCspKFtcXCtcXC1dXFxkXFxkXFw6XFxkXFxkKSQvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmNyZWF0ZURhdGUobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBob3VyID0gcGFyc2VGbG9hdChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgZC5zZXRIb3Vycyhob3VyLCBwYXJzZUludChtYXRjaFszXSwgMTApLCBwYXJzZUludChtYXRjaFs0XSwgMTApLCBwYXJzZUZsb2F0KG1hdGNoWzVdKSoxMDAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYW1iaWd1b3VzIHN0cmluZ3MgbGlrZSAxMi84LzIyLlxuICAgICAgICAvLyBVc2UgRkYgZGF0ZSBhc3N1bXB0aW9uIHRoYXQgMiBkaWdpdCB5ZWFycyBhcmUgMjB0aCBjZW50dXJ5IChpLmUuIDE5MDAncykuXG4gICAgICAgIC8vIFRoaXMgbWF5IGJlIHJlZHVuZGFudCB3aXRoIHByZSBwcm9jZXNzaW5nIG9mIGRhdGUgYWxyZWFkeSBwZXJmb3JtZWQuXG4gICAgICAgIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC9eKFswLTNdP1xcZClcXHMqWy1cXC8uXFxzXXsxfVxccyooW2EtekEtWl17Myw5fSlcXHMqWy1cXC8uXFxzXXsxfVxccyooWzAtM10/XFxkKSQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudCA9IGpzRGF0ZS5jb25maWcuZGVmYXVsdENlbnR1cnk7XG4gICAgICAgICAgICAgICAgdmFyIG0xID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgdmFyIG0zID0gcGFyc2VGbG9hdChtYXRjaFszXSk7XG4gICAgICAgICAgICAgICAgdmFyIG55LCBuZCwgbm07XG4gICAgICAgICAgICAgICAgaWYgKG0xID4gMzEpIHsgLy8gZmlyc3QgbnVtYmVyIGlzIGEgeWVhclxuICAgICAgICAgICAgICAgICAgICBuZCA9IG0zO1xuICAgICAgICAgICAgICAgICAgICBueSA9IGNlbnQgKyBtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGxhc3QgbnVtYmVyIGlzIHRoZSB5ZWFyXG4gICAgICAgICAgICAgICAgICAgIG5kID0gbTE7XG4gICAgICAgICAgICAgICAgICAgIG55ID0gY2VudCArIG0zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbm0gPSBpbkFycmF5KG1hdGNoWzJdLCBqc0RhdGUucmVnaW9uYWxbanNEYXRlLnJlZ2lvbmFsLmdldExvY2FsZSgpXVtcIm1vbnRoTmFtZXNTaG9ydFwiXSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG5tID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5tID0gaW5BcnJheShtYXRjaFsyXSwganNEYXRlLnJlZ2lvbmFsW2pzRGF0ZS5yZWdpb25hbC5nZXRMb2NhbGUoKV1bXCJtb250aE5hbWVzXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkLnNldEZ1bGxZZWFyKG55LCBubSwgbmQpO1xuICAgICAgICAgICAgICAgIGQuc2V0SG91cnMoMCwwLDAsMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICBcbiAgICBdO1xuXG4gICAgLy9cbiAgICAvLyBJIHRoaW5rIEpvaG4gUmVpc2lnIHB1Ymxpc2hlZCB0aGlzIG1ldGhvZCBvbiBoaXMgYmxvZywgZWpvaG4uXG4gICAgLy9cbiAgICBmdW5jdGlvbiBpbkFycmF5KCBlbGVtLCBhcnJheSApIHtcbiAgICAgICAgaWYgKCBhcnJheS5pbmRleE9mICkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoIGVsZW0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIGFycmF5WyBpIF0gPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIFxuICAgIC8vXG4gICAgLy8gVGhhbmtzIHRvIEthbmdheCwgQ2hyaXN0aWFuIFNjaWJlcnJhcyBhbmQgU3RhY2sgT3ZlcmZsb3cgZm9yIHRoaXMgbWV0aG9kLlxuICAgIC8vXG4gICAgZnVuY3Rpb24gZ2V0X3R5cGUodGhpbmcpe1xuICAgICAgICBpZih0aGluZz09PW51bGwpIHJldHVybiBcIltvYmplY3QgTnVsbF1cIjsgLy8gc3BlY2lhbCBjYXNlXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIH1cbiAgICBcbiAgICAkLmpzRGF0ZSA9IGpzRGF0ZTtcblxuICAgICAgXG4gICAgLyoqXG4gICAgICogSmF2YVNjcmlwdCBwcmludGYvc3ByaW50ZiBmdW5jdGlvbnMuXG4gICAgICogXG4gICAgICogVGhpcyBjb2RlIGhhcyBiZWVuIGFkYXB0ZWQgZnJvbSB0aGUgcHVibGljbHkgYXZhaWxhYmxlIHNwcmludGYgbWV0aG9kc1xuICAgICAqIGJ5IEFzaCBTZWFybGUuIEhpcyBvcmlnaW5hbCBoZWFkZXIgZm9sbG93czpcbiAgICAgKlxuICAgICAqICAgICBUaGlzIGNvZGUgaXMgdW5yZXN0cmljdGVkOiB5b3UgYXJlIGZyZWUgdG8gdXNlIGl0IGhvd2V2ZXIgeW91IGxpa2UuXG4gICAgICogICAgIFxuICAgICAqICAgICBUaGUgZnVuY3Rpb25zIHNob3VsZCB3b3JrIGFzIGV4cGVjdGVkLCBwZXJmb3JtaW5nIGxlZnQgb3IgcmlnaHQgYWxpZ25tZW50LFxuICAgICAqICAgICB0cnVuY2F0aW5nIHN0cmluZ3MsIG91dHB1dHRpbmcgbnVtYmVycyB3aXRoIGEgcmVxdWlyZWQgcHJlY2lzaW9uIGV0Yy5cbiAgICAgKlxuICAgICAqICAgICBGb3IgY29tcGxleCBjYXNlcywgdGhlc2UgZnVuY3Rpb25zIGZvbGxvdyB0aGUgUGVybCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgKiAgICAgKHMpcHJpbnRmLCBhbGxvd2luZyBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIG91dC1vZi1vcmRlciwgYW5kIHRvIHNldCB0aGVcbiAgICAgKiAgICAgcHJlY2lzaW9uIG9yIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJhc2VkIG9uIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGZpeGVkXG4gICAgICogICAgIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiAgICAgU2VlIGh0dHA6Ly9wZXJsZG9jLnBlcmwub3JnL2Z1bmN0aW9ucy9zcHJpbnRmLmh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiAgICAgSW1wbGVtZW50ZWQ6XG4gICAgICogICAgIC0gemVybyBhbmQgc3BhY2UtcGFkZGluZ1xuICAgICAqICAgICAtIHJpZ2h0IGFuZCBsZWZ0LWFsaWdubWVudCxcbiAgICAgKiAgICAgLSBiYXNlIFggcHJlZml4IChiaW5hcnksIG9jdGFsIGFuZCBoZXgpXG4gICAgICogICAgIC0gcG9zaXRpdmUgbnVtYmVyIHByZWZpeFxuICAgICAqICAgICAtIChtaW5pbXVtKSB3aWR0aFxuICAgICAqICAgICAtIHByZWNpc2lvbiAvIHRydW5jYXRpb24gLyBtYXhpbXVtIHdpZHRoXG4gICAgICogICAgIC0gb3V0IG9mIG9yZGVyIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICogICAgIE5vdCBpbXBsZW1lbnRlZCAoeWV0KTpcbiAgICAgKiAgICAgLSB2ZWN0b3IgZmxhZ1xuICAgICAqICAgICAtIHNpemUgKGJ5dGVzLCB3b3JkcywgbG9uZy13b3JkcyBldGMuKVxuICAgICAqICAgICBcbiAgICAgKiAgICAgV2lsbCBub3QgaW1wbGVtZW50OlxuICAgICAqICAgICAtICVuIG9yICVwIChubyBwYXNzLWJ5LXJlZmVyZW5jZSBpbiBKYXZhU2NyaXB0KVxuICAgICAqXG4gICAgICogICAgIEB2ZXJzaW9uIDIwMDcuMDQuMjdcbiAgICAgKiAgICAgQGF1dGhvciBBc2ggU2VhcmxlIFxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gc2VlIHRoZSBvcmlnaW5hbCB3b3JrIGFuZCBjb21tZW50cyBvbiBoaXMgYmxvZzpcbiAgICAgKiBodHRwOi8vaGV4bWVuLmNvbS9ibG9nLzIwMDcvMDMvcHJpbnRmLXNwcmludGYvXG4gICAgICogaHR0cDovL2hleG1lbi5jb20vanMvc3ByaW50Zi5qc1xuICAgICAqL1xuICAgICBcbiAgICAgLyoqXG4gICAgICAqIEBNb2RpZmljYXRpb25zIDIwMDkuMDUuMjZcbiAgICAgICogQGF1dGhvciBDaHJpcyBMZW9uZWxsb1xuICAgICAgKiBcbiAgICAgICogQWRkZWQgJXAgJVAgc3BlY2lmaWVyXG4gICAgICAqIEFjdHMgbGlrZSAlZyBvciAlRyBidXQgd2lsbCBub3QgYWRkIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHRoZSBvdXRwdXQgdGhhbiBwcmVzZW50IGluIHRoZSBpbnB1dC5cbiAgICAgICogRXhhbXBsZTpcbiAgICAgICogRm9ybWF0OiAnJS4zcCcsIElucHV0OiAwLjAxMiwgT3V0cHV0OiAwLjAxMlxuICAgICAgKiBGb3JtYXQ6ICclLjNnJywgSW5wdXQ6IDAuMDEyLCBPdXRwdXQ6IDAuMDEyMFxuICAgICAgKiBGb3JtYXQ6ICclLjRwJywgSW5wdXQ6IDEyLjAsIE91dHB1dDogMTIuMFxuICAgICAgKiBGb3JtYXQ6ICclLjRnJywgSW5wdXQ6IDEyLjAsIE91dHB1dDogMTIuMDBcbiAgICAgICogRm9ybWF0OiAnJS40cCcsIElucHV0OiA0LjMyMWUtNSwgT3V0cHV0OiA0LjMyMWUtNVxuICAgICAgKiBGb3JtYXQ6ICclLjRnJywgSW5wdXQ6IDQuMzIxZS01LCBPdXRwdXQ6IDQuMzIxMGUtNVxuICAgICAgKiBcbiAgICAgICogRXhhbXBsZTpcbiAgICAgICogPj4+ICQuanFwbG90LnNwcmludGYoJyUuMmYsICVkJywgMjMuMzQ1MiwgNDMuMjMpXG4gICAgICAqIFwiMjMuMzUsIDQzXCJcbiAgICAgICogPj4+ICQuanFwbG90LnNwcmludGYoXCJubyB2YWx1ZTogJW4sIGRlY2ltYWwgd2l0aCB0aG91c2FuZHMgc2VwYXJhdG9yOiAlJ2RcIiwgMjMuMzQ1MiwgNDMzNTI0KVxuICAgICAgKiBcIm5vIHZhbHVlOiAsIGRlY2ltYWwgd2l0aCB0aG91c2FuZHMgc2VwYXJhdG9yOiA0MzMsNTI0XCJcbiAgICAgICovXG4gICAgJC5qcXBsb3Quc3ByaW50ZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBwYWQoc3RyLCBsZW4sIGNociwgbGVmdEp1c3RpZnkpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gKHN0ci5sZW5ndGggPj0gbGVuKSA/ICcnIDogQXJyYXkoMSArIGxlbiAtIHN0ci5sZW5ndGggPj4+IDApLmpvaW4oY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0SnVzdGlmeSA/IHN0ciArIHBhZGRpbmcgOiBwYWRkaW5nICsgc3RyO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0aG91c2FuZF9zZXBhcmF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlX3N0ciA9IG5ldyBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0xMDsgaT4wOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVfc3RyID09ICh2YWx1ZV9zdHIgPSB2YWx1ZV9zdHIucmVwbGFjZSgvXihcXGQrKShcXGR7M30pLywgXCIkMVwiKyQuanFwbG90LnNwcmludGYudGhvdXNhbmRzU2VwYXJhdG9yK1wiJDJcIikpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZV9zdHI7IFxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQsIGh0bWxTcGFjZSkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBtaW5XaWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGNoYXIgPSAnICc7XG4gICAgICAgICAgICAgICAgaWYgKGh0bWxTcGFjZSkgeyBzcGNoYXIgPSAnJm5ic3A7JzsgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0SnVzdGlmeSB8fCAhemVyb1BhZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhZCh2YWx1ZSwgbWluV2lkdGgsIHNwY2hhciwgbGVmdEp1c3RpZnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgKyBwYWQoJycsIGRpZmYsICcwJywgdHJ1ZSkgKyB2YWx1ZS5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRCYXNlWCh2YWx1ZSwgYmFzZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCwgaHRtbFNwYWNlKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYXN0cyBuZWdhdGl2ZSBudW1iZXJzIHRvIHBvc2l0aXZlIG9uZXNcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCAmJiBudW1iZXIgJiYgeycyJzogJzBiJywgJzgnOiAnMCcsICcxNic6ICcweCd9W2Jhc2VdIHx8ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBwYWQobnVtYmVyLnRvU3RyaW5nKGJhc2UpLCBwcmVjaXNpb24gfHwgMCwgJzAnLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQsIGh0bWxTcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRTdHJpbmcodmFsdWUsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkLCBodG1sU3BhY2UpIHtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCAnJywgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkLCBodG1sU3BhY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMsIGkgPSAwLCBmb3JtYXQgPSBhW2krK107XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKCQuanFwbG90LnNwcmludGYucmVnZXgsIGZ1bmN0aW9uKHN1YnN0cmluZywgdmFsdWVJbmRleCwgZmxhZ3MsIG1pbldpZHRoLCBfLCBwcmVjaXNpb24sIHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzdWJzdHJpbmcgPT0gJyUlJykgeyByZXR1cm4gJyUnOyB9XG5cbiAgICAgICAgICAgIC8vIHBhcnNlIGZsYWdzXG4gICAgICAgICAgICB2YXIgbGVmdEp1c3RpZnkgPSBmYWxzZSwgcG9zaXRpdmVQcmVmaXggPSAnJywgemVyb1BhZCA9IGZhbHNlLCBwcmVmaXhCYXNlWCA9IGZhbHNlLCBodG1sU3BhY2UgPSBmYWxzZSwgdGhvdXNhbmRTZXBhcmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgZmxhZ3MgJiYgaiA8IGZsYWdzLmxlbmd0aDsgaisrKSBzd2l0Y2ggKGZsYWdzLmNoYXJBdChqKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJyAnOiBwb3NpdGl2ZVByZWZpeCA9ICcgJzsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6IHBvc2l0aXZlUHJlZml4ID0gJysnOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICctJzogbGVmdEp1c3RpZnkgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcwJzogemVyb1BhZCA9IHRydWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyMnOiBwcmVmaXhCYXNlWCA9IHRydWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyYnOiBodG1sU3BhY2UgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXCcnOiB0aG91c2FuZFNlcGFyYXRpb24gPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBtYXkgYmUgbnVsbCwgdW5kZWZpbmVkLCBlbXB0eS1zdHJpbmcgb3IgcmVhbCB2YWx1ZWRcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gaWdub3JlIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlc1xuXG4gICAgICAgICAgICBpZiAoIW1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSAwO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKG1pbldpZHRoID09ICcqJykge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gK2FbaSsrXTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIGlmIChtaW5XaWR0aC5jaGFyQXQoMCkgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSArYVttaW5XaWR0aC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gK21pbldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3RlOiB1bmRvY3VtZW50ZWQgcGVybCBmZWF0dXJlOlxuICAgICAgICAgICAgaWYgKG1pbldpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gLW1pbldpZHRoO1xuICAgICAgICAgICAgICAgIGxlZnRKdXN0aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShtaW5XaWR0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyQuanFwbG90LnNwcmludGY6IChtaW5pbXVtLSl3aWR0aCBtdXN0IGJlIGZpbml0ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9ICdmRmVFJy5pbmRleE9mKHR5cGUpID4gLTEgPyA2IDogKHR5cGUgPT0gJ2QnKSA/IDAgOiB2b2lkKDApO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWNpc2lvbiA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSArYVtpKytdO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWNpc2lvbi5jaGFyQXQoMCkgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gK2FbcHJlY2lzaW9uLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gK3ByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ3JhYiB2YWx1ZSB1c2luZyB2YWx1ZUluZGV4IGlmIHJlcXVpcmVkP1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbmRleCA/IGFbdmFsdWVJbmRleC5zbGljZSgwLCAtMSldIDogYVtpKytdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3MnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyaW5nKFN0cmluZyh2YWx1ZSksIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkLCBodG1sU3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYyc6IHJldHVybiBmb3JtYXRTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgrdmFsdWUpLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCwgaHRtbFNwYWNlKTtcbiAgICAgICAgICAgIGNhc2UgJ2InOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDIsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCxodG1sU3BhY2UpO1xuICAgICAgICAgICAgY2FzZSAnbyc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgOCwgcHJlZml4QmFzZVgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkLCBodG1sU3BhY2UpO1xuICAgICAgICAgICAgY2FzZSAneCc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgMTYsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCwgaHRtbFNwYWNlKTtcbiAgICAgICAgICAgIGNhc2UgJ1gnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDE2LCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQsIGh0bWxTcGFjZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ3UnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDEwLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQsIGh0bWxTcGFjZSk7XG4gICAgICAgICAgICBjYXNlICdpJzoge1xuICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoK3ZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVQcmVmaXg7XG4gICAgICAgICAgICAgIHZhciBudW1iZXJfc3RyID0gdGhvdXNhbmRTZXBhcmF0aW9uID8gdGhvdXNhbmRfc2VwYXJhdGUoU3RyaW5nKE1hdGguYWJzKG51bWJlcikpKTogU3RyaW5nKE1hdGguYWJzKG51bWJlcikpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHBhZChudW1iZXJfc3RyLCBwcmVjaXNpb24sICcwJywgZmFsc2UpO1xuICAgICAgICAgICAgICAvL3ZhbHVlID0gcHJlZml4ICsgcGFkKFN0cmluZyhNYXRoLmFicyhudW1iZXIpKSwgcHJlY2lzaW9uLCAnMCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkLCBodG1sU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZCc6IHtcbiAgICAgICAgICAgICAgdmFyIG51bWJlciA9IE1hdGgucm91bmQoK3ZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IG51bWJlciA8IDAgPyAnLScgOiBwb3NpdGl2ZVByZWZpeDtcbiAgICAgICAgICAgICAgdmFyIG51bWJlcl9zdHIgPSB0aG91c2FuZFNlcGFyYXRpb24gPyB0aG91c2FuZF9zZXBhcmF0ZShTdHJpbmcoTWF0aC5hYnMobnVtYmVyKSkpOiBTdHJpbmcoTWF0aC5hYnMobnVtYmVyKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gcHJlZml4ICsgcGFkKG51bWJlcl9zdHIsIHByZWNpc2lvbiwgJzAnLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgemVyb1BhZCwgaHRtbFNwYWNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlciA9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVQcmVmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFsndG9FeHBvbmVudGlhbCcsICd0b0ZpeGVkJywgJ3RvUHJlY2lzaW9uJ11bJ2VmZycuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFRyYW5zZm9ybSA9IFsndG9TdHJpbmcnLCAndG9VcHBlckNhc2UnXVsnZUVmRmdHJy5pbmRleE9mKHR5cGUpICUgMl07XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlcl9zdHIgPSBNYXRoLmFicyhudW1iZXIpW21ldGhvZF0ocHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgZGVjaW1hbCBtYXJrIHByb3Blcmx5IGJ5IHNwbGl0dGluZyB0aGUgbnVtYmVyIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVjaW1hbE1hcmssIGFwcGx5aW5nIHRob3VzYW5kcyBzZXBhcmF0b3IsIGFuZCB0aGVuIHBsYWNpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgIGJhY2sgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbnVtYmVyX3N0ci50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0gPSB0aG91c2FuZFNlcGFyYXRpb24gPyB0aG91c2FuZF9zZXBhcmF0ZShwYXJ0c1swXSkgOiBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICBudW1iZXJfc3RyID0gcGFydHMuam9pbigkLmpxcGxvdC5zcHJpbnRmLmRlY2ltYWxNYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIG51bWJlcl9zdHI7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGp1c3RpZmllZCA9IGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkLCBodG1sU3BhY2UpW3RleHRUcmFuc2Zvcm1dKCk7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp1c3RpZmllZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG51bWJlciBpcyBhIG51bWJlclxuICAgICAgICAgICAgICAgIHZhciBudW1iZXIgPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbnVtYmVyIDwgMCA/ICctJyA6IHBvc2l0aXZlUHJlZml4O1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gU3RyaW5nKE51bWJlcihNYXRoLmFicyhudW1iZXIpKS50b0V4cG9uZW50aWFsKCkpLnNwbGl0KC9lfEUvKTtcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSAocGFydHNbMF0uaW5kZXhPZignLicpICE9IC0xKSA/IHBhcnRzWzBdLmxlbmd0aCAtIDEgOiBTdHJpbmcobnVtYmVyKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHplcm9zID0gKHBhcnRzWzFdIDwgMCkgPyAtcGFydHNbMV0gLSAxIDogMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobnVtYmVyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNkICsgemVyb3MgIDw9IHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBNYXRoLmFicyhudW1iZXIpLnRvUHJlY2lzaW9uKHNkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZCAgPD0gcHJlY2lzaW9uIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlZml4ICsgTWF0aC5hYnMobnVtYmVyKS50b0V4cG9uZW50aWFsKHNkLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBNYXRoLmFicyhudW1iZXIpLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlYyA9IChzZCA8PSBwcmVjaXNpb24pID8gc2QgOiBwcmVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlZml4ICsgTWF0aC5hYnMobnVtYmVyKS50b1ByZWNpc2lvbihwcmVjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBbJ3RvU3RyaW5nJywgJ3RvVXBwZXJDYXNlJ11bJ3BQJy5pbmRleE9mKHR5cGUpICUgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkLCBodG1sU3BhY2UpW3RleHRUcmFuc2Zvcm1dKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduJzogcmV0dXJuICcnO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHN1YnN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQuanFwbG90LnNwcmludGYudGhvdXNhbmRzU2VwYXJhdG9yID0gJywnO1xuICAgIC8vIFNwZWNpZmllcyB0aGUgZGVjaW1hbCBtYXJrIGZvciBmbG9hdGluZyBwb2ludCB2YWx1ZXMuIEJ5IGRlZmF1bHQgYSBwZXJpb2QgJy4nXG4gICAgLy8gaXMgdXNlZC4gSWYgeW91IGNoYW5nZSB0aGlzIHZhbHVlIHRvIGZvciBleGFtcGxlIGEgY29tbWEgYmUgc3VyZSB0byBhbHNvXG4gICAgLy8gY2hhbmdlIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIG9yIGVsc2UgdGhpcyB3b24ndCB3b3JrIHNpbmNlIGEgc2ltcGxlIFN0cmluZ1xuICAgIC8vIHJlcGxhY2UgaXMgdXNlZCAocmVwbGFjaW5nIGFsbCBwZXJpb2RzIHdpdGggdGhlIG1hcmsgc3BlY2lmaWVkIGhlcmUpLlxuICAgICQuanFwbG90LnNwcmludGYuZGVjaW1hbE1hcmsgPSAnLic7XG4gICAgXG4gICAgJC5qcXBsb3Quc3ByaW50Zi5yZWdleCA9IC8lJXwlKFxcZCtcXCQpPyhbLSsjMCZcXCcgXSopKFxcKlxcZCtcXCR8XFwqfFxcZCspPyhcXC4oXFwqXFxkK1xcJHxcXCp8XFxkKykpPyhbbkFzY2JveFh1aWRmZWdwRUdQXSkvZztcblxuICAgICQuanFwbG90LmdldFNpZ25pZmljYW50RmlndXJlcyA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICB2YXIgcGFydHMgPSBTdHJpbmcoTnVtYmVyKE1hdGguYWJzKG51bWJlcikpLnRvRXhwb25lbnRpYWwoKSkuc3BsaXQoL2V8RS8pO1xuICAgICAgICAvLyB0b3RhbCBzaWduaWZpY2FudCBkaWdpdHNcbiAgICAgICAgdmFyIHNkID0gKHBhcnRzWzBdLmluZGV4T2YoJy4nKSAhPSAtMSkgPyBwYXJ0c1swXS5sZW5ndGggLSAxIDogcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgemVyb3MgPSAocGFydHNbMV0gPCAwKSA/IC1wYXJ0c1sxXSAtIDEgOiAwO1xuICAgICAgICAvLyBleHBvbmVudFxuICAgICAgICB2YXIgZXhwbiA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICAgIC8vIGRpZ2l0cyB0byB0aGUgbGVmdCBvZiB0aGUgZGVjaW1hbCBwbGFjZVxuICAgICAgICB2YXIgZGxlZnQgPSAoZXhwbiArIDEgPiAwKSA/IGV4cG4gKyAxIDogMDtcbiAgICAgICAgLy8gZGlnaXRzIHRvIHRoZSByaWdodCBvZiB0aGUgZGVjaW1hbCBwbGFjZVxuICAgICAgICB2YXIgZHJpZ2h0ID0gKHNkIDw9IGRsZWZ0KSA/IDAgOiBzZCAtIGV4cG4gLSAxO1xuICAgICAgICByZXR1cm4ge3NpZ25pZmljYW50RGlnaXRzOiBzZCwgZGlnaXRzTGVmdDogZGxlZnQsIGRpZ2l0c1JpZ2h0OiBkcmlnaHQsIHplcm9zOiB6ZXJvcywgZXhwb25lbnQ6IGV4cG59IDtcbiAgICB9O1xuXG4gICAgJC5qcXBsb3QuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAkLmpxcGxvdC5nZXRTaWduaWZpY2FudEZpZ3VyZXMobnVtYmVyKS5kaWdpdHNSaWdodDtcbiAgICB9O1xuXG4gIFxuXG5cbiAgICB2YXIgYmFja0NvbXBhdCA9ICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZTtcblxuICAgICQuanFwbG90LmVmZmVjdHMgPSB7XG4gICAgICAgIGVmZmVjdDoge31cbiAgICB9O1xuXG4gICAgLy8gcHJlZml4IHVzZWQgZm9yIHN0b3JpbmcgZGF0YSBvbiAuZGF0YSgpXG4gICAgdmFyIGRhdGFTcGFjZSA9IFwianFwbG90LnN0b3JhZ2UuXCI7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRkZFQ1RTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICQuZXh0ZW5kKCAkLmpxcGxvdC5lZmZlY3RzLCB7XG4gICAgICAgIHZlcnNpb246IFwiMS45cHJlXCIsXG5cbiAgICAgICAgLy8gU2F2ZXMgYSBzZXQgb2YgcHJvcGVydGllcyBpbiBhIGRhdGEgc3RvcmFnZVxuICAgICAgICBzYXZlOiBmdW5jdGlvbiggZWxlbWVudCwgc2V0ICkge1xuICAgICAgICAgICAgZm9yKCB2YXIgaT0wOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggc2V0WyBpIF0gIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlICsgc2V0WyBpIF0sIGVsZW1lbnRbIDAgXS5zdHlsZVsgc2V0WyBpIF0gXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZXN0b3JlcyBhIHNldCBvZiBwcmV2aW91c2x5IHNhdmVkIHByb3BlcnRpZXMgZnJvbSBhIGRhdGEgc3RvcmFnZVxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbiggZWxlbWVudCwgc2V0ICkge1xuICAgICAgICAgICAgZm9yKCB2YXIgaT0wOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggc2V0WyBpIF0gIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCBzZXRbIGkgXSwgZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldE1vZGU6IGZ1bmN0aW9uKCBlbCwgbW9kZSApIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInRvZ2dsZVwiKSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IGVsLmlzKCBcIjpoaWRkZW5cIiApID8gXCJzaG93XCIgOiBcImhpZGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdyYXBzIHRoZSBlbGVtZW50IGFyb3VuZCBhIHdyYXBwZXIgdGhhdCBjb3BpZXMgcG9zaXRpb24gcHJvcGVydGllc1xuICAgICAgICBjcmVhdGVXcmFwcGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB3cmFwcGVkLCByZXR1cm4gaXRcbiAgICAgICAgICAgIGlmICggZWxlbWVudC5wYXJlbnQoKS5pcyggXCIudWktZWZmZWN0cy13cmFwcGVyXCIgKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3cmFwIHRoZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50Lm91dGVyV2lkdGgodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBlbGVtZW50LmNzcyggXCJmbG9hdFwiIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSAkKCBcIjxkaXY+PC9kaXY+XCIgKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoIFwidWktZWZmZWN0cy13cmFwcGVyXCIgKVxuICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzaXplIGluIGNhc2Ugd2lkdGgvaGVpZ2h0IGFyZSBkZWZpbmVkIGluICUgLSBGaXhlcyAjNTI0NVxuICAgICAgICAgICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgICAgZWxlbWVudC53cmFwKCB3cmFwcGVyICk7XG5cbiAgICAgICAgICAgIC8vIEZpeGVzICM3NTk1IC0gRWxlbWVudHMgbG9zZSBmb2N1cyB3aGVuIHdyYXBwZWQuXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnRbIDAgXSA9PT0gYWN0aXZlIHx8ICQuY29udGFpbnMoIGVsZW1lbnRbIDAgXSwgYWN0aXZlICkgKSB7XG4gICAgICAgICAgICAgICAgJCggYWN0aXZlICkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcHBlciA9IGVsZW1lbnQucGFyZW50KCk7IC8vSG90Zml4IGZvciBqUXVlcnkgMS40IHNpbmNlIHNvbWUgY2hhbmdlIGluIHdyYXAoKSBzZWVtcyB0byBhY3R1YWxseSBsb29zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnRcblxuICAgICAgICAgICAgLy8gdHJhbnNmZXIgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgd3JhcHBlclxuICAgICAgICAgICAgaWYgKCBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQoIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogZWxlbWVudC5jc3MoIFwiei1pbmRleFwiIClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkLmVhY2goWyBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiIF0sIGZ1bmN0aW9uKGksIHBvcykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1sgcG9zIF0gPSBlbGVtZW50LmNzcyggcG9zICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNOYU4oIHBhcnNlSW50KCBwcm9wc1sgcG9zIF0sIDEwICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyBwb3MgXSA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBcImF1dG9cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5jc3Moc2l6ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNzcyggcHJvcHMgKS5zaG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlV3JhcHBlcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50KCkucmVwbGFjZVdpdGgoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpeGVzICM3NTk1IC0gRWxlbWVudHMgbG9zZSBmb2N1cyB3aGVuIHdyYXBwZWQuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAkKCBhY3RpdmUgKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmV0dXJuIGFuIGVmZmVjdCBvcHRpb25zIG9iamVjdCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnM6XG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZUFyZ3VtZW50cyggZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgLy8gc2hvcnQgcGF0aCBmb3IgcGFzc2luZyBhbiBlZmZlY3Qgb3B0aW9ucyBvYmplY3Q6XG4gICAgICAgIGlmICggJC5pc1BsYWluT2JqZWN0KCBlZmZlY3QgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRvIGFuIG9iamVjdFxuICAgICAgICBlZmZlY3QgPSB7IGVmZmVjdDogZWZmZWN0IH07XG5cbiAgICAgICAgLy8gY2F0Y2ggKGVmZmVjdClcbiAgICAgICAgaWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRjaCAoZWZmZWN0LCBjYWxsYmFjaylcbiAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIHNwZWVkID0gbnVsbDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhdGNoIChlZmZlY3QsIHNwZWVkLCA/KVxuICAgICAgICBpZiAoICQudHlwZSggb3B0aW9ucyApID09PSBcIm51bWJlclwiIHx8ICQuZnguc3BlZWRzWyBvcHRpb25zIF0pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc3BlZWQ7XG4gICAgICAgICAgICBzcGVlZCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRjaCAoZWZmZWN0LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIHNwZWVkICkgKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNwZWVkO1xuICAgICAgICAgICAgc3BlZWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG9wdGlvbnMgdG8gZWZmZWN0XG4gICAgICAgIGlmICggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICQuZXh0ZW5kKCBlZmZlY3QsIG9wdGlvbnMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZWVkID0gc3BlZWQgfHwgb3B0aW9ucy5kdXJhdGlvbjtcbiAgICAgICAgZWZmZWN0LmR1cmF0aW9uID0gJC5meC5vZmYgPyAwIDogdHlwZW9mIHNwZWVkID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IHNwZWVkIDogc3BlZWQgaW4gJC5meC5zcGVlZHMgPyAkLmZ4LnNwZWVkc1sgc3BlZWQgXSA6ICQuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG4gICAgICAgIGVmZmVjdC5jb21wbGV0ZSA9IGNhbGxiYWNrIHx8IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgICAgICAgcmV0dXJuIGVmZmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFuZGFyZFNwZWVkKCBzcGVlZCApIHtcbiAgICAgICAgLy8gdmFsaWQgc3RhbmRhcmQgc3BlZWRzXG4gICAgICAgIGlmICggIXNwZWVkIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgc3BlZWQgXSApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52YWxpZCBzdHJpbmdzIC0gdHJlYXQgYXMgXCJub3JtYWxcIiBzcGVlZFxuICAgICAgICBpZiAoIHR5cGVvZiBzcGVlZCA9PT0gXCJzdHJpbmdcIiAmJiAhJC5qcXBsb3QuZWZmZWN0cy5lZmZlY3RbIHNwZWVkIF0gKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaW4gMi4wICgjNzExNSlcbiAgICAgICAgICAgIGlmICggYmFja0NvbXBhdCAmJiAkLmpxcGxvdC5lZmZlY3RzWyBzcGVlZCBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgICQuZm4uZXh0ZW5kKHtcbiAgICAgICAganFwbG90RWZmZWN0OiBmdW5jdGlvbiggZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuICAgICAgICAgICAgICAgIG1vZGUgPSBhcmdzLm1vZGUsXG4gICAgICAgICAgICAgICAgcXVldWUgPSBhcmdzLnF1ZXVlLFxuICAgICAgICAgICAgICAgIGVmZmVjdE1ldGhvZCA9ICQuanFwbG90LmVmZmVjdHMuZWZmZWN0WyBhcmdzLmVmZmVjdCBdLFxuXG4gICAgICAgICAgICAgICAgLy8gREVQUkVDQVRFRDogcmVtb3ZlIGluIDIuMCAoIzcxMTUpXG4gICAgICAgICAgICAgICAgb2xkRWZmZWN0TWV0aG9kID0gIWVmZmVjdE1ldGhvZCAmJiBiYWNrQ29tcGF0ICYmICQuanFwbG90LmVmZmVjdHNbIGFyZ3MuZWZmZWN0IF07XG5cbiAgICAgICAgICAgIGlmICggJC5meC5vZmYgfHwgISggZWZmZWN0TWV0aG9kIHx8IG9sZEVmZmVjdE1ldGhvZCApICkge1xuICAgICAgICAgICAgICAgIC8vIGRlbGVnYXRlIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGUuZy4sIC5zaG93KCkpIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWYgKCBtb2RlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1sgbW9kZSBdKCBhcmdzLmR1cmF0aW9uLCBhcmdzLmNvbXBsZXRlICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFyZ3MuY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5jb21wbGV0ZS5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcnVuKCBuZXh0ICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gJCggdGhpcyApLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBhcmdzLm1vZGU7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggY29tcGxldGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLmNhbGwoIGVsZW1bMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggbmV4dCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGRlbiBhbmQgbW9kZSBpcyBoaWRlLFxuICAgICAgICAgICAgICAgIC8vIG9yIGVsZW1lbnQgaXMgdmlzaWJsZSBhbmQgbW9kZSBpcyBzaG93XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLmlzKCBcIjpoaWRkZW5cIiApID8gbW9kZSA9PT0gXCJoaWRlXCIgOiBtb2RlID09PSBcInNob3dcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdE1ldGhvZC5jYWxsKCBlbGVtWzBdLCBhcmdzLCBkb25lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjaGVjayBpbiAyLjAsIGVmZmVjdE1ldGhvZCB3aWxsIGFsd2F5cyBiZSB0cnVlXG4gICAgICAgICAgICBpZiAoIGVmZmVjdE1ldGhvZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUgPT09IGZhbHNlID8gdGhpcy5lYWNoKCBydW4gKSA6IHRoaXMucXVldWUoIHF1ZXVlIHx8IFwiZnhcIiwgcnVuICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERFUFJFQ0FURUQ6IHJlbW92ZSBpbiAyLjAgKCM3MTE1KVxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRFZmZlY3RNZXRob2QuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBhcmdzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogYXJncy5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogYXJncy5tb2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIHZhciBydmVydGljYWwgPSAvdXB8ZG93bnx2ZXJ0aWNhbC8sXG4gICAgICAgIHJwb3NpdGl2ZW1vdGlvbiA9IC91cHxsZWZ0fHZlcnRpY2FsfGhvcml6b250YWwvO1xuXG4gICAgJC5qcXBsb3QuZWZmZWN0cy5lZmZlY3QuYmxpbmQgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcbiAgICAgICAgLy8gQ3JlYXRlIGVsZW1lbnRcbiAgICAgICAgdmFyIGVsID0gJCggdGhpcyApLFxuICAgICAgICAgICAgcHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG4gICAgICAgICAgICBtb2RlID0gJC5qcXBsb3QuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcInVwXCIsXG4gICAgICAgICAgICB2ZXJ0aWNhbCA9IHJ2ZXJ0aWNhbC50ZXN0KCBkaXJlY3Rpb24gKSxcbiAgICAgICAgICAgIHJlZiA9IHZlcnRpY2FsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIixcbiAgICAgICAgICAgIHJlZjIgPSB2ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIixcbiAgICAgICAgICAgIG1vdGlvbiA9IHJwb3NpdGl2ZW1vdGlvbi50ZXN0KCBkaXJlY3Rpb24gKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IHt9LFxuICAgICAgICAgICAgc2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuICAgICAgICAgICAgd3JhcHBlciwgZGlzdGFuY2UsIHRvcDtcblxuICAgICAgICAvLyAvLyBpZiBhbHJlYWR5IHdyYXBwZWQsIHRoZSB3cmFwcGVyJ3MgcHJvcGVydGllcyBhcmUgbXkgcHJvcGVydHkuICM2MjQ1XG4gICAgICAgIGlmICggZWwucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkgKSB7XG4gICAgICAgICAgICAkLmpxcGxvdC5lZmZlY3RzLnNhdmUoIGVsLnBhcmVudCgpLCBwcm9wcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5qcXBsb3QuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5zaG93KCk7XG4gICAgICAgIHRvcCA9IHBhcnNlSW50KGVsLmNzcygndG9wJyksIDEwKTtcbiAgICAgICAgd3JhcHBlciA9ICQuanFwbG90LmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlzdGFuY2UgPSB2ZXJ0aWNhbCA/IHdyYXBwZXJbIHJlZiBdKCkgKyB0b3AgOiB3cmFwcGVyWyByZWYgXSgpO1xuXG4gICAgICAgIGFuaW1hdGlvblsgcmVmIF0gPSBzaG93ID8gU3RyaW5nKGRpc3RhbmNlKSA6ICcwJztcbiAgICAgICAgaWYgKCAhbW90aW9uICkge1xuICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgICAuY3NzKCB2ZXJ0aWNhbCA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIsIDAgKVxuICAgICAgICAgICAgICAgIC5jc3MoIHZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiLCBcIlwiIClcbiAgICAgICAgICAgICAgICAuY3NzKHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9KTtcbiAgICAgICAgICAgIGFuaW1hdGlvblsgcmVmMiBdID0gc2hvdyA/ICcwJyA6IFN0cmluZyhkaXN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBzdGFydCBhdCAwIGlmIHdlIGFyZSBzaG93aW5nXG4gICAgICAgIGlmICggc2hvdyApIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY3NzKCByZWYsIDAgKTtcbiAgICAgICAgICAgIGlmICggISBtb3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jc3MoIHJlZjIsIGRpc3RhbmNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBBbmltYXRlXG4gICAgICAgIHdyYXBwZXIuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogby5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogby5lYXNpbmcsXG4gICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmpxcGxvdC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuICAgICAgICAgICAgICAgICQuanFwbG90LmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cGRhdGVkLWpxcGxvdC9kaXN0L2pxdWVyeS51cGRhdGVkLWpxcGxvdC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _jquery = __webpack_require__(/*! jquery */ 0);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _updatedJqplot = __webpack_require__(/*! updated-jqplot */ 1);\n\nvar jqplots = _interopRequireWildcard(_updatedJqplot);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar relations;\n\n\nwindow.addEventListener(\"load\", function load(event) {\n    window.removeEventListener(\"load\", load, false);\n    // Pas de cache sur les requte IMPORTANT !\n    console.log(jqplots);\n    _jquery2.default.ajaxSetup({ cache: false });\n\n    /***\n    \tOn dfinit ici les fonctions de base qui vont nous servir  la rcupration des donnes\n    \tJe ne dfinis que le GET ici, mais il est possible d'utiliser POST pour rcuprer ses donnes (on le verra dans un prochain TP)\n    ****/\n    function getRequest(url, callback) {\n        _jquery2.default.get(url, function (data) {\n            data = _jquery2.default.parseJSON(data);\n            callback(data);\n        });\n    }\n\n    /***************************************\n    \tQUESTION 1 : PIE CHART : Visite par marque\n    ****************************************/\n    getRequest(\"liste_amis_user.php?user=5\", function (data) {\n        relations = data;\n        cleanedData = data.map(function (item, index) {\n            return [item[2], index + 1];\n        });\n        var plot1 = _jquery2.default.jqplot(\"chart1\", [cleanedData], {\n            title: \"Nombre d'amis au fil du mois\",\n            axes: {\n                xaxis: {\n                    renderer: _jquery2.default.jqplot.DateAxisRenderer\n                }\n            },\n            series: [{ lineWidth: 4, markerOptions: { style: 'square' } }]\n        });\n        console.log(data);\n        console.log(cleanedData);\n    });\n}, false);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9pbmRleC5qcz80MmY2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZWxhdGlvbnM7XG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgKiBhcyBqcXBsb3RzIGZyb20gXCJ1cGRhdGVkLWpxcGxvdFwiO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gbG9hZChldmVudCl7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWQsIGZhbHNlKTtcbiAgXHQvLyBQYXMgZGUgY2FjaGUgc3VyIGxlcyByZXF1w6p0ZSBJTVBPUlRBTlQgIVxuICAgIGNvbnNvbGUubG9nKGpxcGxvdHMpO1xuICBcdCQuYWpheFNldHVwKHsgY2FjaGU6IGZhbHNlIH0pO1xuXG4gIFx0LyoqKlxuICBcdFx0T24gZMOpZmluaXQgaWNpIGxlcyBmb25jdGlvbnMgZGUgYmFzZSBxdWkgdm9udCBub3VzIHNlcnZpciDDoCBsYSByw6ljdXDDqXJhdGlvbiBkZXMgZG9ubsOpZXNcbiAgXHRcdEplIG5lIGTDqWZpbmlzIHF1ZSBsZSBHRVQgaWNpLCBtYWlzIGlsIGVzdCBwb3NzaWJsZSBkJ3V0aWxpc2VyIFBPU1QgcG91ciByw6ljdXDDqXJlciBzZXMgZG9ubsOpZXMgKG9uIGxlIHZlcnJhIGRhbnMgdW4gcHJvY2hhaW4gVFApXG4gIFx0KioqKi9cbiAgXHRmdW5jdGlvbiBnZXRSZXF1ZXN0KHVybCwgY2FsbGJhY2spIHtcbiAgXHRcdCQuZ2V0KHVybCwgZnVuY3Rpb24oZGF0YSkge1xuICBcdFx0XHRkYXRhID0gJC5wYXJzZUpTT04oZGF0YSk7XG4gIFx0XHRcdGNhbGxiYWNrKGRhdGEpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBcdFx0UVVFU1RJT04gMSA6IFBJRSBDSEFSVCA6IFZpc2l0ZSBwYXIgbWFycXVlXG4gIFx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgXHRnZXRSZXF1ZXN0KFwibGlzdGVfYW1pc191c2VyLnBocD91c2VyPTVcIiwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHJlbGF0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgY2xlYW5lZERhdGEgPSBkYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IFtcbiAgICAgICAgICAgICAgaXRlbVsyXSxcbiAgICAgICAgICAgICAgaW5kZXggKyAxXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgdmFyIHBsb3QxID0gJC5qcXBsb3QoXCJjaGFydDFcIiwgW2NsZWFuZWREYXRhXSwge1xuICAgICAgICAgICAgICB0aXRsZTogXCJOb21icmUgZCdhbWlzIGF1IGZpbCBkdSBtb2lzXCIsXG4gICAgICAgICAgICAgIGF4ZXM6IHtcbiAgICAgICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6ICQuanFwbG90LkRhdGVBeGlzUmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VyaWVzOlt7bGluZVdpZHRoOjQsIG1hcmtlck9wdGlvbnM6e3N0eWxlOidzcXVhcmUnfX1dXG4gICAgICAgICAgfSlcbiAgICBcdFx0Y29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNsZWFuZWREYXRhKTtcbiAgXHR9KTtcbn0sIGZhbHNlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBqcy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFIQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);